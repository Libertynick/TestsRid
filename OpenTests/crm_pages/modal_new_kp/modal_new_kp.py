import time
from datetime import datetime
from decimal import Decimal

import allure
from selenium.common import TimeoutException, StaleElementReferenceException
from selenium.webdriver import Keys, ActionChains
from selenium.webdriver.support.color import Color

from base_page.base_page import BasePage
from base_page.raise_exceptions import MyTimeoutException, MyException
from crm_pages.modal_new_kp.modal_new_kp_locators import ModalNewKpLocators, ModalAddedZipLocators, \
    ModalNewKpRolLocators, ModalPleaseIndicateYourMainCompetitorAndSupplierLocators
from base_page.base_page_locators import BaseCrmLocators
from config import ProdEnvironment


@allure.feature('Модалка создания нового КП')
class ModalNewKp(BasePage):
    """Модалка создания нового КП"""

    def check_that_distributor_field_is_empty(self):
        """Проверка, что поле Дистрибьютор пустое"""
        with allure.step('Проверка, что поле Дистрибьютор пустое'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_DROP_UL_DISTRIBUTOR, sec=5)
            text_in_field_distr = self.find_element(ModalNewKpLocators.LOCATOR_DROP_UL_DISTRIBUTOR).text
            assert text_in_field_distr == '', \
                f'Поле Дистрибьютор не пустое - ({text_in_field_distr})'

    def choice_distributor(self, num_distributor='14403847'):
        """Выбор Дистрибьютора"""
        with allure.step('Выбор дистрибьютора при создании нового PQ'):
            with allure.step('Клик по полю для выбора Дистрибьютора'):
                button_drop = self.find_element(ModalNewKpLocators.LOCATOR_DROP_UL_DISTRIBUTOR)
                button_drop.click()
                with allure.step('Ввод названия дистрибьютора'):
                    self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_INPUT_DISTRIBUTOR)
                    input_distributor = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_DISTRIBUTOR)
                    input_distributor.send_keys(num_distributor)
                    time.sleep(1)
                    with allure.step('Выбор из списка нужного дистрибьютора'):
                        self.waiting_element_is_visibility_on_the_page(
                            ModalNewKpLocators.LOCATOR_INPUT_FIXED_DISTRIBUTOR, sec=40)
                        fixed_distributor = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_FIXED_DISTRIBUTOR)
                        fixed_distributor.click()

    def check_display_flag_pinned_another_distr(self):
        """Проверка отображения флага Закреплен другой дистрибьютор у выбранного дистра"""
        with allure.step(''):
            expected_message = 'закреплен другой дистрибьютор'
            self.waiting_element_is_visibility_on_the_page(
                ModalNewKpLocators.LOCATOR_INFO_RED_MESSAGES_IN_SELECTED_DISTR, sec=5)
            info_message = self.find_element(ModalNewKpLocators.LOCATOR_INFO_RED_MESSAGES_IN_SELECTED_DISTR).text
            assert expected_message == info_message, \
                f'У выбранного дистра нет инфо сообщения - ({expected_message}). На странице отображается - ' \
                f'({info_message})'

    def checking_selected_contract_number(self, expected_contract_number: str):
        """Проверка выбора номера договора"""
        with allure.step('Проверка выбора номера договора'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_SELECTED_CONTRACT_NUMBER)
            selected_number_on_page = self.find_element(ModalNewKpLocators.LOCATOR_SELECTED_CONTRACT_NUMBER
                                                        ).text.split(' ')[0]
            assert selected_number_on_page == expected_contract_number, \
                f'Выбранный номер договора ({selected_number_on_page}) не соответствует ожидаемому ' \
                f'({expected_contract_number})'

    def choice_sap_code_main_contract(self, num_contract='RT25-7705238125-HE'):
        """Выбор номера договора"""
        with allure.step('Выбора номера договора'):
            time.sleep(3)
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_DROP_UL_SAP_CODE, sec=15)
            count_sap_main_contract = self.driver.find_elements(
                *ModalNewKpLocators.locator_sap_main_contract(num_contract))
            with allure.step('Выбор вводимого номера договора'):
                if len(count_sap_main_contract) == 0:
                    drop_ul_sap_code = self.find_element(ModalNewKpLocators.LOCATOR_DROP_UL_SAP_CODE)
                    drop_ul_sap_code.click()
                self.waiting_element_is_visibility_on_the_page(
                    ModalNewKpLocators.locator_sap_main_contract(num_contract))
                sap_main_contract = self.find_element(ModalNewKpLocators.locator_sap_main_contract(num_contract))
                sap_main_contract.click()
                loader = self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER)
                if len(loader) > 0:
                    self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER)
                selected_sap_code = self.find_element(
                    ModalNewKpLocators.LOCATOR_SELECTED_SAP_CODE).text  # выбранный сап код
                selected_sap_code = selected_sap_code.split(' ')[0]
                assert selected_sap_code == num_contract, \
                    f'Выбранный sap code ({selected_sap_code}) не равен искомому ({num_contract})'

    def check_that_contract_number_field_is_empty(self):
        """Проверка, что поле Номер договора пустое"""
        with allure.step('Проверка, что поле Номер договора пустое'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_DROP_UL_SAP_CODE, sec=5)
            text_in_field_contract_number = self.find_element(ModalNewKpLocators.LOCATOR_DROP_UL_SAP_CODE).text
            assert text_in_field_contract_number == '', \
                f'Поле Номер договора не пустое - ({text_in_field_contract_number})'

    def checking_that_contract_number_field_is_not_clickable(self):
        """Проверка, что поле Номер договора не кликабельно"""
        with allure.step('Проверка, что поле Номер договора не кликабельно'):
            expected_class = 'disabled'
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BLOCK_DIV_CONTRACT_NUMBER, sec=5)
            class_field_contract_number_on_page = self.find_element(
                ModalNewKpLocators.LOCATOR_BLOCK_DIV_CONTRACT_NUMBER).get_attribute('class')
            assert expected_class in class_field_contract_number_on_page, \
                f'Поле Номер договора кликабельно. ({class_field_contract_number_on_page}) - class element'

    def choice_final_buyer(self, final_buyer='фирма "ВОДОКОМФОРТ" (Офис Москва) (7705238125)'):
        """Выбор Конечного покупателя"""
        with allure.step('Выбор Конечного покупателя'):
            with allure.step('Клик по полю Конечного покупателя'):
                self.final_buyer_dropdown_list_expansion()
                final_buyer_item = self.find_element(
                    ModalNewKpLocators.locator_final_buyer_by_text_final_buyer(final_buyer))
                final_buyer_item.click()
                time.sleep(1)

                selected_end_customer = self.find_element(
                    ModalNewKpLocators.LOCATOR_SELECTED_END_CUSTOMER)  # Выбранный конечный покупатель
                selected_end_customer = selected_end_customer.text
                assert selected_end_customer == final_buyer, \
                    f'Номер выбранного конечного покупателя {selected_end_customer} не равен искомому номеру ' \
                    f'{final_buyer}'

    def final_buyer_dropdown_list_expansion(self):
        """Раскрытие выпадающего списка Конечный покупатель"""
        with allure.step('Клик по полю Конечного покупателя'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_DROP_UL_FINAL_BUYER)
            drop_ul_final_buyer = self.find_element(ModalNewKpLocators.LOCATOR_DROP_UL_FINAL_BUYER)
            drop_ul_final_buyer.click()
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_INPUT_FINAL_BUYER, sec=10)

    def end_customer_input(self, final_buyer: str):
        """Ввод конечного покупателя"""
        with allure.step('Ввод конечного покупателя'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_INPUT_FINAL_BUYER, sec=5)
            input_final_buyer = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_FINAL_BUYER)
            input_final_buyer.send_keys(final_buyer)
            self.waiting_element_is_visibility_on_the_page(
                ModalNewKpLocators.locator_final_buyer_by_text_final_buyer(final_buyer), sec=5)
            found_final_buyer = self.find_element(
                ModalNewKpLocators.locator_final_buyer_by_text_final_buyer(final_buyer))
            found_final_buyer.click()

            self.check_of_selected_end_customer(final_buyer)

    def check_of_selected_end_customer(self, expected_end_customer: str):
        """Проверка выбранного конечного покупателя"""
        with allure.step('Проверка выбранного конечного покупателя'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_SELECTED_END_CUSTOMER, sec=5)
            selected_end_customer = self.find_element(
                ModalNewKpLocators.LOCATOR_SELECTED_END_CUSTOMER)  # Выбранный конечный покупатель
            selected_end_customer = selected_end_customer.text
            assert expected_end_customer in selected_end_customer, \
                f'Ожидаемый конечный покупатель ({expected_end_customer}) не содержится в выбранном ' \
                f'({selected_end_customer})'

    def choice_of_developer(self, num_contract: str):
        """Выбор застройщика"""
        with allure.step('Выбор застройщика'):
            with allure.step('Клик по полю застройщика'):
                self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_DROP_UL_DEVELOPER, sec=5)
                drop_developer_ul = self.find_element(ModalNewKpLocators.LOCATOR_DROP_UL_DEVELOPER)
                drop_developer_ul.click()
                with allure.step('Ввод данных застройщика и выбор из списка'):
                    self.waiting_element_is_visibility_on_the_page(
                        ModalNewKpLocators.locator_sap_main_contract(num_contract))
                    developer = self.find_element(ModalNewKpLocators.locator_sap_main_contract(num_contract))
                    developer.click()
                    time.sleep(1)
                    loader = self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER_RECOUNTING_KP)
                    if len(loader) > 0:
                        self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER_RECOUNTING_KP, sec=30)
                    self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_SELECTED_DEVELOPER,
                                                                   sec=10)
                    selected_developer = self.find_element(ModalNewKpLocators.LOCATOR_SELECTED_DEVELOPER).text
                    assert num_contract in selected_developer, \
                        f'Договор в выбранном застройщике - ({selected_developer}) на соответствует ожидаемому - ({num_contract})'

    def potential_mode_selection(self, potential_mode: str):
        """Выбор режима потенциала"""
        with allure.step('Выбор режима потенциала'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BTN_DROP_UL_POTENTIAL_MODE)
            with allure.step('Клик по полю потенциала'):
                btn_drop_ul_potential_mode = self.find_element(ModalNewKpLocators.LOCATOR_BTN_DROP_UL_POTENTIAL_MODE)
                btn_drop_ul_potential_mode.click()
                with allure.step('Выбор из списка нужного потенциала'):
                    self.waiting_element_is_visibility_on_the_page(
                        ModalNewKpLocators.locator_potential_mode_item(potential_mode))
                    item_potential_mode = self.find_element(
                        ModalNewKpLocators.locator_potential_mode_item(potential_mode))
                    item_potential_mode.click()
                    self.check_potential_mode(potential_mode)

    def check_potential_mode(self, expected_mode: str):
        """Проверка режима потенциала"""
        with allure.step('Проверка режима потенциала'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_SELECTED_POTENTIAL_MODE, sec=5)
            selected_potential_mode = self.find_element(ModalNewKpLocators.LOCATOR_SELECTED_POTENTIAL_MODE).text
            assert selected_potential_mode == expected_mode, \
                f'Выбранный режим потенциала - ({selected_potential_mode}) не соответствует ожидаемому - ({expected_mode})'

    def check_in_potential_mode_previous_value_identifier(self, expected_value_of_previous_potential_mode: str):
        """Проверка значения в идентификаторе предыдущего режима потенциала"""
        with allure.step('Проверка значения в идентификаторе предыдущего режима потенциала'):
            self.driver.refresh()
            self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER)
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.LOCATOR_POTENTIAL_MODE_PREVIOUS_VALUE_IDENTIFIER, sec=5)
            value_of_previous_potential_mode_on_page = self.find_element(
                ModalNewKpLocators.LOCATOR_POTENTIAL_MODE_PREVIOUS_VALUE_IDENTIFIER).get_attribute(
                'data-original-title')
            assert value_of_previous_potential_mode_on_page == expected_value_of_previous_potential_mode, \
                f'Ожидаемое значение в идентификаторе предыдущего режима потенциала - ' \
                f'({expected_value_of_previous_potential_mode}) не соответствует значению на странице - ' \
                f'({value_of_previous_potential_mode_on_page})'

    def check_expiration_value(self, expected_validity_period: str):
        """Проверка значения срока действия"""
        with allure.step('Проверка значения срока действия'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_VALUE_VALIDITY_PERIOD, sec=5)
            validity_period_on_page = self.find_element(ModalNewKpLocators.LOCATOR_VALUE_VALIDITY_PERIOD).text
            assert validity_period_on_page == expected_validity_period, \
                f'Срок действия на странице - ({validity_period_on_page}) не соответствует ожидаемому - ' \
                f'({expected_validity_period})'

    def check_that_expiration_date_field_is_not_clickable(self):
        """Проверка, что поле Срок действия не кликабельно"""
        with allure.step('Проверка, что поле Срок действия не кликабельно'):
            expected_contains_class = 'disabled'

            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_VALUE_VALIDITY_PERIOD, sec=5)
            field_validity_period_class = self.find_element(
                ModalNewKpLocators.LOCATOR_VALUE_VALIDITY_PERIOD).get_attribute('class')
            assert expected_contains_class in field_validity_period_class, \
                f'Поле Срок действия кликабельно. ({field_validity_period_class}) - class element'

    def check_that_full_name_client_field_is_not_empty(self):
        """Проверка, что поле ФИО клиента не пустое"""
        with allure.step('Проверка, что поле ФИО клиента не пустое'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BLOCK_DIV_FULL_NAME_CLIENT, sec=5)
            full_name_client = self.find_element(ModalNewKpLocators.LOCATOR_BLOCK_DIV_FULL_NAME_CLIENT
                                                 ).text.split('\n')[0]
            assert full_name_client != '', f'Поле ФИО клиента пустое. ({full_name_client})'

    def check_full_name_client(self, expected_full_name: str):
        """Проверка ФИО клиента"""
        with allure.step('Проверка ФИО клиента'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BLOCK_DIV_FULL_NAME_CLIENT, sec=5)
            full_name_client = self.find_element(ModalNewKpLocators.LOCATOR_BLOCK_DIV_FULL_NAME_CLIENT
                                                 ).text.split('\n')[0]
            assert expected_full_name == full_name_client, \
                f'ФИО клиента на странице - ({full_name_client}) не соответствует ожидаемым - ({expected_full_name})'

    def check_that_details_client_field_is_not_empty(self):
        """Проверка, что реквизиты клиента в поле ФИО клиента не пустые"""
        with allure.step('Проверка, что реквизиты клиента в поле ФИО клиента не пустые'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BLOCK_DIV_FULL_NAME_CLIENT, sec=5)
            details_client = self.find_element(ModalNewKpLocators.LOCATOR_BLOCK_DIV_FULL_NAME_CLIENT
                                               ).text.split('\n')[1]
            assert details_client != '', f'Реквизиты клиента в поле ФИО клиента пустые. ({details_client})'

    def check_details_client(self, expected_details_client: str):
        """Проверка реквизитов клиента в разделе ФИО клиента"""
        with allure.step('Проверка реквизитов клиента в разделе ФИО клиента'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BLOCK_DIV_FULL_NAME_CLIENT, sec=5)
            details_client = self.find_element(ModalNewKpLocators.LOCATOR_BLOCK_DIV_FULL_NAME_CLIENT
                                               ).text.split('\n')[1]
            assert expected_details_client == details_client, \
                f'Реквизиты клиента на странице - ({details_client}) не соответствует ожидаемым - ' \
                f'({expected_details_client})'

    def expanding_payment_terms_menu(self):
        """Раскрытие меню условий оплаты"""
        with allure.step('Раскрытие меню условий оплаты'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BUTTON_PAYMENT_TERMS_MENU)
            self.scroll_to_height()
            button_payment_terms_menu = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_PAYMENT_TERMS_MENU)
            button_payment_terms_menu.click()
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_UL_PAYMENT_TERMS_MENU)

    def hide_block_payment_terms(self):
        """Скрытие блока Условия оплаты"""
        with allure.step('Скрытие блока Условия оплаты'):
            self.expecting_clickability(ModalNewKpLocators.LOCATOR_SPAN_FOR_HIDE_AND_DISCLOSURE_PAYMENT_TERMS, sec=5)
            btn_hide_block_payment_terms = self.find_element(
                ModalNewKpLocators.LOCATOR_SPAN_FOR_HIDE_AND_DISCLOSURE_PAYMENT_TERMS)
            btn_hide_block_payment_terms.click()
            time.sleep(0.5)
            self.waiting_element_invisibility(ModalNewKpLocators.LOCATOR_BUTTON_PAYMENT_TERMS_MENU, sec=5)

    def disclosure_of_payment_terms_block(self):
        """Раскрытие блока Условия оплаты"""
        self.expecting_clickability(ModalNewKpLocators.LOCATOR_SPAN_FOR_HIDE_AND_DISCLOSURE_PAYMENT_TERMS, sec=5)
        btn_hide_block_payment_terms = self.find_element(
            ModalNewKpLocators.LOCATOR_SPAN_FOR_HIDE_AND_DISCLOSURE_PAYMENT_TERMS)
        btn_hide_block_payment_terms.click()
        time.sleep(0.5)
        self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BUTTON_PAYMENT_TERMS_MENU, sec=5)

    def selection_of_contractual_payment_terms(self, contractual_terms: str):
        """Выбор договорных условий оплаты
        contractual_terms - договорные условия
        """
        with allure.step('Выбор договорных условий оплаты'):
            self.waiting_element_is_visibility_on_the_page(
                ModalNewKpLocators.locator_negotiated_payment_terms(contractual_terms)).click()
            selected_payment_terms = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_PAYMENT_TERMS_MENU).text
            assert selected_payment_terms == contractual_terms, \
                f'Выбранные условия оплаты - ({selected_payment_terms}) не соответствуют ожидаемым - ({contractual_terms})'

    def click_on_button_agree_on_payment_terms(self):
        """Клик по кнопке Согласование условий оплаты"""
        with allure.step('Клик по кнопке Согласование условий оплаты'):
            self.waiting_element_is_visibility_on_the_page(
                ModalNewKpLocators.LOCATOR_BUTTON_COORDINATION_OF_PAYMENT_TERMS)
            button_coordination_of_payment_terms = self.find_element(
                ModalNewKpLocators.LOCATOR_BUTTON_COORDINATION_OF_PAYMENT_TERMS)
            button_coordination_of_payment_terms.click()
            self.waiting_element_is_visibility_on_the_page(
                ModalNewKpLocators.LOCATOR_TOTAL_PAYMENT_BEFORE_SHIPMENT, sec=10)

    def click_button_recalculate(self):
        """Клик по кнопке Пересчитать"""
        with allure.step('Клик по кнопке Пересчитать'):
            self.expecting_clickability(ModalNewKpLocators.LOCATOR_BUTTON_RECALCULATE)
            button_recalculate = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_RECALCULATE)
            button_recalculate.click()
            time.sleep(1)
            self.waiting_for_loader_processing_on_page(ModalNewKpLocators.LOCATOR_LOADER_RECALCULATE)

    def choice_of_total_payment_before_shipment(self, percentage_payment: str):
        """Выбор суммарной оплаты перед отгрузкой, percentage_payment - оплата в процентах"""
        with allure.step('Выбор суммарной оплаты перед отгрузкой'):
            total_payment_before_shipment = self.find_element(ModalNewKpLocators.LOCATOR_TOTAL_PAYMENT_BEFORE_SHIPMENT)
            total_payment_before_shipment.clear()
            total_payment_before_shipment.send_keys(percentage_payment)
            entered_total_payment_before_shipment = total_payment_before_shipment.get_attribute('value'). \
                replace(' ', '').replace('%', '')
            percentage_payment = percentage_payment.replace('%', '')
            assert entered_total_payment_before_shipment == percentage_payment, \
                f'проценты суммарной оплаты перед отгрузкой на странице - ({entered_total_payment_before_shipment}) ' \
                f'не равны введенным - ({percentage_payment})'

    def choice_of_advance_payment_amount_for_placement(self, advance_payment: str):
        """Выбор размера аванса для размещения, advance_payment - размер аванса(%)"""
        with allure.step('Выбор размера аванса для размещения'):
            with allure.step('Очищение поля размера аванса для размещения'):
                advance_payment_for_placement = self.find_element(
                    ModalNewKpLocators.LOCATOR_ADVANCE_PAYMENT_FOR_PLACEMENT)
                advance_payment_for_placement.clear()
                with allure.step('Ввод размера аванса для размещения'):
                    advance_payment_for_placement.send_keys(advance_payment)
                    advance_payment_for_placement_on_page = advance_payment_for_placement.get_attribute(
                        'value').replace(' ', '')
                    assert advance_payment_for_placement_on_page == advance_payment, \
                        f'Размер аванса для размещения заказа на странице - ({advance_payment_for_placement_on_page}) ' \
                        f'не соответствует введенному - ({advance_payment})'

    def saving_advance_payment_for_placing_an_order(self) -> str:
        """Сохранение Размер аванса для размещения заказа"""
        with allure.step('Сохранение размера аванса для размещения'):
            advance_payment = self.find_element(ModalNewKpLocators.LOCATOR_ADVANCE_PAYMENT_FOR_PLACEMENT
                                                ).get_attribute('value').replace(' ', '')
            return advance_payment

    def save_payment_after_shipment(self) -> str:
        """Сохранение значения Оплата после отгрузки"""
        with allure.step('Сохранение значения оплаты после отгрузки'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_PAYMENT_AFTER_SHIPMENT, sec=5)
            payment_after_shipment = self.find_element(ModalNewKpLocators.LOCATOR_PAYMENT_AFTER_SHIPMENT
                                                       ).get_attribute('value').replace(' ', '')
            return payment_after_shipment

    def saving_total_payment_before_shipment(self) -> str:
        """Сохранение Суммарная оплата перед отгрузкой"""
        with allure.step('Сохранение Суммарная оплата перед отгрузкой'):
            total_payment = self.find_element(ModalNewKpLocators.LOCATOR_TOTAL_PAYMENT_BEFORE_SHIPMENT
                                              ).get_attribute('value').replace(' ', '')
            return total_payment

    def saving_loan_duration(self) -> str:
        """Сохранение продолжительности кредитования"""
        with allure.step('Сохранение продолжительности кредитования'):
            loan_duration = self.find_element(ModalNewKpLocators.LOCATOR_LOAN_DURATION).get_attribute('value')
            return loan_duration

    def saving_interest_on_a_loan(self) -> float:
        """Сохранение процента за кредит"""
        with allure.step('Сохранение процента за кредит'):
            interest_on_a_loan = self.find_element(ModalNewKpLocators.LOCATOR_INTEREST_ON_A_LOAN).text
            return float(interest_on_a_loan)

    def entering_loan_interest(self, interest_on_loan: str):
        """Ввод процента за кредит
        interest_on_loan - процент за кредит
        """
        with allure.step('Ввод процента за кредит'):
            time.sleep(3)
            self.waiting_element_is_visibility_on_the_page(
                ModalNewKpLocators.LOCATOR_DISCLOSURE_OF_LIST_OF_LOAN_INTEREST,
                sec=5)
            with allure.step('Раскрытие списка процента за кредит'):
                drop_down_list = self.find_element(ModalNewKpLocators.LOCATOR_DISCLOSURE_OF_LIST_OF_LOAN_INTEREST)
                drop_down_list.click()
                # time.sleep(3)
                with allure.step('Ввод процента за кредит'):
                    self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_INPUT_LOAN_INTEREST,
                                                                   sec=7)

                    # time.sleep(3)
                    self.waiting_element_is_visibility_located_dom(
                        ModalNewKpLocators.locator_interest_on_loan(interest_on_loan),
                        sec=10)
                    interest_on_loan_li = self.find_element(
                        ModalNewKpLocators.locator_interest_on_loan(interest_on_loan))
                    interest_on_loan_li.click()
                    self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_INTEREST_ON_A_LOAN,
                                                                   sec=5)
                    selected_interest_on_loan = self.find_element(ModalNewKpLocators.LOCATOR_INTEREST_ON_A_LOAN).text
                    assert selected_interest_on_loan == interest_on_loan, \
                        f'Выбранный процент за кредит ({selected_interest_on_loan}) не соответствует ожидаемому ' \
                        f'({interest_on_loan})'

    def saving_percentage_for_conversion(self) -> float:
        """Сохранение процента за конвертацию"""
        with allure.step('Сохранение процента за конвертацию'):
            percentage_for_conversion = self.find_element(ModalNewKpLocators.LOCATOR_PERCENTAGE_FOR_CONVERSION
                                                          ).get_attribute('value')
            percentage_for_conversion = percentage_for_conversion.replace(' %', '')
            return float(percentage_for_conversion)

    def entering_percentage_for_conversion(self, percentage_for_conversion: str):
        """Ввод процента за конвертацию"""
        with allure.step('Ввод процента за конвертацию'):
            with allure.step('Очистить поле процента за конвертацию'):
                self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_PERCENTAGE_FOR_CONVERSION)
                input_percentage_for_conversion = self.find_element(
                    ModalNewKpLocators.LOCATOR_PERCENTAGE_FOR_CONVERSION)
                input_percentage_for_conversion.clear()
                with allure.step('Выбрать процента за конвертацию'):
                    input_percentage_for_conversion.send_keys(percentage_for_conversion)
                    selected_percentage_for_conversion = input_percentage_for_conversion.get_attribute('value').replace(
                        ' %', '')
                    assert selected_percentage_for_conversion == percentage_for_conversion, \
                        f'Введенный процент за конвертацию ({selected_percentage_for_conversion}) не соответствует ожидаемому ' \
                        f'({percentage_for_conversion})'

    def save_all_allowance(self) -> list:
        """Сохранение всех надбавок (на всех артикулах)"""
        with allure.step('Сохранение всех надбавок'):
            allowances = self.find_elements(ModalNewKpLocators.LOCATOR_ALLOWANCE)
            allowances_list = [float(allowance.text.replace(',', '.').replace('%', '')) for allowance in allowances]
            return allowances_list

    @staticmethod
    def allowance_calculation(interest_on_a_loan: float, percentage_for_conversion: float) -> int:
        """Вычисление надбавки, percentage_for_conversion - процент за конвертацию,
        interest_on_a_loan - процент за кредит"""
        with allure.step('Вычисление надбавки'):
            allowance = int(interest_on_a_loan) + int(percentage_for_conversion)
            return allowance

    def choice_lending_duration(self, amount_of_days: str):
        """Выбор Продолжительности кредитования"""
        with allure.step('Выбор продолжительности кредитования'):
            with allure.step('Очистка поля продолжительности кредитования'):
                lending_duration = self.find_element(ModalNewKpLocators.LOCATOR_LOAN_DURATION)
                lending_duration.clear()
                with allure.step('Выбор продолжительности кредитования'):
                    lending_duration.send_keys(amount_of_days)
                    selected_amount_of_days = lending_duration.get_attribute('value')
                    assert selected_amount_of_days == amount_of_days, \
                        f'Выбранное количество дней {selected_amount_of_days} не равно искомому {amount_of_days}'

    def check_head_delivery_conditions(self):
        """Проверка, что на странице есть заголовок Условия поставки"""
        with allure.step('Проверка, что на странице есть заголовок Условия поставки'):
            expected_head = 'Условия поставки:'
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_HEAD_DELIVERY_CONDITIONS, sec=5)
            head_on_page = self.find_element(ModalNewKpLocators.LOCATOR_HEAD_DELIVERY_CONDITIONS).text
            assert expected_head == head_on_page, \
                f'Заголовок на странице ({head_on_page}) не соответствует ожидаемому - ({expected_head})'

    def selection_of_delivery_conditions(self, delivery_conditions: str):
        """Выбор условия поставки"""
        with allure.step('Выбор условий поставки'):
            self.disclosure_of_list_of_delivery_conditions()
            locator_delivery_condition_li = ModalNewKpLocators.locator_delivery_condition_li(delivery_conditions)
            with allure.step('Клик по полю условий поставки выбор'):
                specified_address = self.find_element(locator_delivery_condition_li)
                specified_address.click()
                selected_terms_of_delivery = self.find_element(
                    ModalNewKpLocators.LOCATOR_SELECTED_TERMS_OF_DELIVERY).text
                assert selected_terms_of_delivery == delivery_conditions, \
                    f'Выбранные условия поставки {selected_terms_of_delivery} не равны искомым {delivery_conditions}'

    def disclosure_of_list_of_delivery_conditions(self):
        """Раскрытие списка условия поставки"""
        with allure.step('Раскрытие списка условий поставки'):
            self.scroll_to_height()
            self.expecting_clickability(ModalNewKpLocators.LOCATOR_BTN_DELIVERY_CONDITIONS_ACTIVATE_UL, sec=5)
            delivery_conditions_ul = self.find_element(ModalNewKpLocators.LOCATOR_BTN_DELIVERY_CONDITIONS_ACTIVATE_UL)
            delivery_conditions_ul.click()
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_DELIVERY_CONDITIONS_UL)

    def save_payment_terms_code(self) -> str:
        """Сохранение кода условий оплаты"""
        with allure.step('Сохранение кода условий оплаты'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_PAYMENT_TERMS_CODE)
            payment_terms_code = self.find_element(ModalNewKpLocators.LOCATOR_PAYMENT_TERMS_CODE).text
            return payment_terms_code

    def checking_that_delivery_to_specified_address_is_selected(self):
        """Проверка, что выбрана Доставка на указанный адрес"""
        with allure.step('Проверка, что выбрана Доставка на указанный адрес'):
            expected_delivery_conditions = 'Доставка на указанный адрес'
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_SELECTED_TERMS_OF_DELIVERY,
                                                           sec=5)
            selected_delivery_conditions = self.find_element(ModalNewKpLocators.LOCATOR_SELECTED_TERMS_OF_DELIVERY).text
            assert selected_delivery_conditions == expected_delivery_conditions, \
                f'Выбранные условия доставки - ({selected_delivery_conditions}) не соответствуют ожидаемым - ' \
                f'({expected_delivery_conditions})'

    def check_that_drop_down_list_is_for_delivery_to_specified_address(self):
        """Проверка, что в выпадающем списке только доставка на указанный адрес"""
        with allure.step('Проверка, что в выпадающем списке только доставка на указанный адрес'):
            expected_delivery_conditions = 'Доставка на указанный адрес'
            self.disclosure_of_list_of_delivery_conditions()
            list_delivery_conditions = self.find_elements(
                ModalNewKpLocators.LOCATOR_AVAILABLE_DELIVERY_TERMS_IN_DROP_DOWN_LIST)
            len_list_delivery_conditions = len(list_delivery_conditions)
            assert len_list_delivery_conditions == 1, f'Доступных условий поставки больше 1. Количество- ' \
                                                      f'{len_list_delivery_conditions}'
            delivery_conditions_n_drop_ul = list_delivery_conditions[0].text  # Способ доставки в выпадающем списке
            assert delivery_conditions_n_drop_ul == expected_delivery_conditions, \
                f'Способ доставки в выпадающем списке - ({delivery_conditions_n_drop_ul}) не соответствует ожидаемому - ' \
                f'({expected_delivery_conditions})'
            self.find_element(ModalNewKpLocators.LOCATOR_ACTIVE_DROP_UL).click()

    def check_address_header(self):
        """Проверка заголовка Адрес в разделе Дополнительные расходы/Условия поставки"""
        with allure.step('Проверка заголовка Адрес в разделе Дополнительные расходы/Условия поставки'):
            expected_header = 'Адрес'
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_HEADER_ADDRESS, sec=5)
            header_address_on_page = self.find_element(ModalNewKpLocators.LOCATOR_HEADER_ADDRESS).text
            assert expected_header == header_address_on_page, \
                f'Заголовок ({header_address_on_page}) на странице в разделе Дополнительные расходы/Условия поставки ' \
                f'не соответствует ожидаемому - ({expected_header})'

    def check_entered_address(self, expected_address='Россия, г Москва '):
        """Проверка введенного адреса доставки в разделе Дополнительные расходы/Условия поставки"""
        with allure.step('Проверка введенного адреса доставки в разделе Дополнительные расходы/Условия поставки'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_INPUT_ADDRESS, sec=5)
            entered_address = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_ADDRESS).get_attribute('value')
            entered_address = entered_address.strip()
            expected_address = expected_address.strip()
            assert entered_address == expected_address, \
                f'Введенный адрес доставки - ({entered_address}) в разделе Дополнительные расходы/Условия поставки ' \
                f'не соответствует ожидаемому - ({expected_address})'

    def entering_a_shipping_address(self, delivery_address):
        """Ввод адреса доставки"""
        with allure.step('Ввод адреса доставки при создании PQ'):
            with allure.step('Очистка поля с адресом доставки'):
                input_address = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_ADDRESS)
                input_address.clear()
                with allure.step('Ввод адреса доставки'):
                    input_address.send_keys(delivery_address)
                    time.sleep(1)
                    try:
                        self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_DIV_RESULT_ADDRESS)
                        self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_DIV_RESULT_ADDRESS)
                        result_address_list = self.find_elements(ModalNewKpLocators.LOCATOR_DIV_RESULT_ADDRESS)
                        result_address = result_address_list[1]
                        result_address.click()
                    except TimeoutException:
                        pass
                    finally:
                        entered_address = input_address.get_attribute('value').strip()
                        with allure.step('Проверка что адрес доставки соответствует тому который вводили'):
                            assert delivery_address in entered_address, \
                                f'Введенный адрес доставки - ({entered_address}) не соответствует ожидаемому - ({delivery_address})'

                        time.sleep(1)

    def checking_selected_delivery_method(self, expected_delivery_method: str):
        """Проверка выбранного вида доставки"""
        with allure.step('Проверка выбранного вида доставки'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_SELECTED_TYPE_OF_DELIVERY, sec=5)
            selected_delivery_method = self.find_element(ModalNewKpLocators.LOCATOR_SELECTED_TYPE_OF_DELIVERY).text
            assert selected_delivery_method == expected_delivery_method, \
                f'Выбранный вид доставки - ({selected_delivery_method}) не соответствует ожидаемому - ' \
                f'({expected_delivery_method})'

    def choice_of_free_payment_mode(self):
        """Выбор бесплатного режима оплаты"""
        with allure.step('Выбор бесплатного режима оплаты Доставки'):
            with allure.step('Клик по полю режима оплаты доставки'):
                payment_mode = self.find_element(ModalNewKpLocators.LOCATOR_PAYMENT_MODE)
                self.expecting_clickability(ModalNewKpLocators.LOCATOR_PAYMENT_MODE)
                payment_mode.click()
                time.sleep(1)
                with allure.step('Ожидание выпадающего списка с режимами оплаты доставки'):
                    self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_FREE_PAYMENT_MODE)
                    with allure.step('Поиск в выпадающем списке Бесплатного режима оплаты доставки'):
                        free_payment_mode = self.find_element(ModalNewKpLocators.LOCATOR_FREE_PAYMENT_MODE)
                        free_payment_mode_text = self.find_element(ModalNewKpLocators.LOCATOR_FREE_PAYMENT_MODE).text
                        with allure.step('Выбор Бесплатного режима оплаты Доставки'):
                            free_payment_mode.click()
                            selected_payment_mode = self.find_element(ModalNewKpLocators.SELECTED_PAYMENT_MODE).text
                            assert selected_payment_mode == free_payment_mode_text, \
                                f'Выбранный режим оплаты {selected_payment_mode} не равен искомому {free_payment_mode_text}'

    def there_must_be_an_advance_payment(self):
        """Должна быть Предоплата"""
        with allure.step('Проверка условий оплаты Предоплата'):
            expected_payment_terms = 'Предоплата'
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BUTTON_PAYMENT_TERMS_MENU, sec=5)
            payment_terms = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_PAYMENT_TERMS_MENU).text
            assert expected_payment_terms == payment_terms, \
                f'Условия оплаты на странице - ({payment_terms}) не соответствуют ожидаемым - ({expected_payment_terms})'

    def check_that_payment_terms_field_is_not_editable(self):
        """Проверка, что поле Условия оплаты не редактируемо"""
        expected_contains_class = 'disabled'
        self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BLOCK_DIV_PAYMENT_TERMS, sec=5)
        class_payment_terms = self.find_element(ModalNewKpLocators.LOCATOR_BLOCK_DIV_PAYMENT_TERMS
                                                ).get_attribute('class')
        assert expected_contains_class in class_payment_terms, \
            f'Поле Условия оплаты редактируемо. Значение класса - {class_payment_terms}'

    def there_should_be_standard_contractual_terms(self):
        """Условия поставки должны быть - стандартные договорные условия"""
        with allure.step('Проверка что условия поставки - стандартные договорные условия'):
            expected_terms_of_delivery = 'Стандартные договорные условия'
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_SELECTED_TERMS_OF_DELIVERY)
            selected_terms_of_delivery = self.find_element(ModalNewKpLocators.LOCATOR_SELECTED_TERMS_OF_DELIVERY).text
            assert selected_terms_of_delivery == expected_terms_of_delivery, \
                f'Условия поставки на странице - ({selected_terms_of_delivery}) не соответствуют ожидаемым - ' \
                f'({expected_terms_of_delivery})'

    def click_button_add_positions_to_open_add_field(self):
        """Клик по кнопке Добавить позиции для открытия поля добавления кодов"""
        with allure.step('Клик по кнопке Добавить позиции для открытия поля добавления кодов'):
            button_add = self.find_element(ModalNewKpLocators.LOCATOR_ADD_ITEMS_BUTTON_TO_OPEN_ADD_FIELD)
            button_add.click()
            time.sleep(0.2)
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_CODE_ENTRY_FIELD, sec=10)

    def click_button_add_zip(self):
        """Клик по кнопке Добавить ЗИП"""
        with allure.step('Клик по кнопке Добавить ЗИП'):
            btn_add_zip = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_ADD_ZIP)
            btn_add_zip.click()
            time.sleep(0.3)
            self.waiting_element_is_visibility_on_the_page(ModalAddedZipLocators.LOCATOR_H4_HEADER)

    def check_that_add_zip_button_is_blocked(self):
        """Проверка, что кнопка Добавить ЗИП заблочена"""
        with allure.step('Проверка, что кнопка Добавить ЗИП заблочена'):
            expected_contains_class = 'disabled'
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BUTTON_ADD_ZIP_LINK_ELEMENT,
                                                           sec=5)
            class_btn_add_zip = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_ADD_ZIP_LINK_ELEMENT
                                                  ).get_attribute('class')
            assert expected_contains_class in class_btn_add_zip, \
                f'Кнопка Добавить ЗИП не заблочена. Класс элемента кнопки - {class_btn_add_zip}'

    def click_on_button_to_add_items_to_kp(self):
        """Клик по кнопке добавить позиции в кп"""
        with allure.step('Клик по кнопке Добавить ЗИП'):
            self.expecting_clickability(ModalNewKpLocators.LOCATOR_BUTTON_ADD_ITEMS)
            button_add_codes = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_ADD_ITEMS)
            button_add_codes.click()
            self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER_RECOUNTING_KP, sec=180)
            self.waiting_for_loader_processing_in_dom(BaseCrmLocators.LOCATOR_LOADER, sec=180)

    def check_btn_add_position_to_kp_is_blocked(self):
        """Проверка, что кнопка Добавить позиции в КП заблокирована"""
        with allure.step('Проверка, что кнопка Добавить позиции в КП заблокирована'):
            expected_contains_class = 'disabled'
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BUTTON_ADD_ITEMS, sec=5)
            class_btn_add_position = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_ADD_ITEMS).get_attribute(
                'class')
            assert expected_contains_class in class_btn_add_position, \
                f'Кнопка Добавить позиции в КП не заблокирована. Класс элемента кнопки - {class_btn_add_position}'

    def adding_codes(self, codes):
        """Добавление кодов в КП"""
        with allure.step('Добавление кодов в КП'):
            with allure.step('Добавить коды в поле "Вставьте коды"'):
                self.expecting_clickability(ModalNewKpLocators.LOCATOR_CODE_ENTRY_FIELD)
                input_codes = self.find_element(ModalNewKpLocators.LOCATOR_CODE_ENTRY_FIELD)
                input_codes.send_keys(codes)
                with allure.step('Клик по кнопке Добавить позиции'):
                    self.click_on_button_to_add_items_to_kp()
                    time.sleep(1)
                    assert self.is_element_present(*ModalNewKpLocators.LOCATOR_NUM_POSITION_ARTICLE_IN_KP), \
                        f'Коды не добавились в КП'

    def check_placeholder_text_in_code_entry_field(self):
        """Проверка текста плэйсхолдера (инфо сообщение в поле) в поле ввода кодов"""
        with allure.step('Проверка текста плэйсхолдера (инфо сообщение в поле) в поле ввода кодов'):
            expected_placeholder_text = 'Вставьте коды/номер КП/номер заказа из буфера обмена или напишите их вручную.' \
                                        '\nРазделители: пробел, тире, запятая, точка с запятой, перенос строки'
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_CODE_ENTRY_FIELD, sec=5)
            text_placeholder_in_field = self.find_element(ModalNewKpLocators.LOCATOR_CODE_ENTRY_FIELD
                                                          ).get_attribute('placeholder')
            assert expected_placeholder_text == text_placeholder_in_field, \
                f'Текст в плэйсхолдере в поле ввода кодов на странице - ({text_placeholder_in_field}) не соответствует ' \
                f'ожидаемому - ({expected_placeholder_text})'

    def save_name_link_in_pq_details_tab(self) -> list:
        """Сохранение наименований ссылок в разделе Детали КП"""
        with allure.step('Сохранение наименований ссылок в разделе Детали КП'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_LINK_IN_PQ_DETAILS_TAB, sec=5)
            link_in_pq_details_tab = self.find_elements(ModalNewKpLocators.LOCATOR_LINK_IN_PQ_DETAILS_TAB)
            name_link_in_pq_details_tab = [el.text for el in link_in_pq_details_tab]
            return name_link_in_pq_details_tab

    def saving_codes_in_add_positions_field(self) -> list:
        """Сохранение кодов в поле Добавить позиции"""
        with allure.step('Сохранение кодов в поле Добавить позиции'):
            input_codes = self.find_element(ModalNewKpLocators.LOCATOR_CODE_ENTRY_FIELD)
            codes_in_field = input_codes.get_attribute('value').split('\n')
            codes_in_field = [el for el in codes_in_field if len(el) != 0]
            substring = ' '
            res_codes = []
            for el in codes_in_field:
                idx = el.index(substring)
                res_codes.append(el[:idx])
            return res_codes

    def saving_added_code_when_autocorrecting(self, article: str) -> str:
        """Сохранение добавленного кода при автозамене"""
        with allure.step('Сохранение добавленного кода при автозамене'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BLOCK_DIV_CONTRACT_NUMBER, sec=7)
            autocorrect_article = ''
            autocorrect_article_message = self.driver.find_elements(
                *ModalNewKpLocators.locator_message_about_code_auto_replacement_by_code(article))
            if len(autocorrect_article_message) > 0:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.locator_message_about_code_auto_replacement_by_code(article), sec=5)
                autocorrect_article = self.find_element(
                    ModalNewKpLocators.locator_message_about_code_auto_replacement_by_code(article)).text.split(' ')[0]

            return autocorrect_article

    def saving_added_codes(self) -> list:
        """Сохранение добавленных кодов"""
        with allure.step('Сохранение добавленных кодов'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_LIST_CODE_IN_KP)
            list_added_codes = self.find_elements(ModalNewKpLocators.LOCATOR_LIST_CODE_IN_KP)
            list_added_codes = [code.text for code in list_added_codes if code.text != '']
            return list_added_codes

    def check_that_calculation_has_flag_protected_calculation(self, article: str):
        """Проверка, что у расчета есть флаг Защищенный расчет ПТО"""
        with ((allure.step('Проверка, что у расчета есть флаг Защищенный расчет ПТО'))):
            expected_text_in_flag = 'Защищённый расчёт ПТО'
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.locator_info_flag_in_by_article(article),
                                                           sec=5)
            text_in_flag_on_page = self.find_element(
                ModalNewKpLocators.locator_info_flag_in_by_article(article)).text.strip()
            assert expected_text_in_flag == text_in_flag_on_page, \
                f'Нет флага ({expected_text_in_flag}). Текст флага на странице у кода {article} - ({text_in_flag_on_page})'

    def store_amount_nds_total_in_kp_crm_rub(self) -> float:
        """Сохранение итоговой стоимости КП с НДС в рублях """
        with allure.step('Сохранение итоговой стоимости КП с НДС в рублях'):
            try:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.LOCATOR_SPAN_DISTRIBUTOR_AMOUNT_NDS_TOTAL)
                amount_total = self.find_element(ModalNewKpLocators.LOCATOR_SPAN_DISTRIBUTOR_AMOUNT_NDS_TOTAL).text
                amount_total = amount_total.split(' ')[:-1]
                amount_total = ''.join(amount_total).replace(',', '.')
                return float(amount_total)
            except StaleElementReferenceException:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.LOCATOR_SPAN_DISTRIBUTOR_AMOUNT_NDS_TOTAL)
                amount_total = self.find_element(ModalNewKpLocators.LOCATOR_SPAN_DISTRIBUTOR_AMOUNT_NDS_TOTAL).text
                amount_total = amount_total.split(' ')[:-1]
                amount_total = ''.join(amount_total).replace(',', '.')
                return float(amount_total)

    def store_amount_nds_total_in_kp_crm_rub_by_position(self) -> list:
        """Сохранение итоговой стоимости с НДС в рублях по каждой позиции отдельно"""
        with allure.step('Сохранение итоговой стоимости с НДС в рублях по каждой позиции отдельно'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_SUM_WITH_NDS_DISTRIBUTOR, sec=5)
            discounts_by_position = self.find_elements(ModalNewKpLocators.LOCATOR_SUM_WITH_NDS_DISTRIBUTOR)
            discounts_by_position = [
                float(el.
                      text.
                      replace(',', '.').
                      replace(' ', '').
                      replace('₽', '')
                      )
                for el in discounts_by_position
            ]
            return discounts_by_position

    def save_sum_amount_with_nds_distributor_all_lines(self) -> float:
        """Сохранение суммы стоимости с НДС дистрибьютора на всех линиях"""
        with allure.step('Сохранение суммы стоимости с НДС дистрибьютора на всех линиях'):
            sum_amount_all_lines = 0.0

            amount_all_lines = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_SUM_WITH_NDS_DISTRIBUTOR)
            tag_name_amount_all_lines = amount_all_lines[0].tag_name
            if tag_name_amount_all_lines == 'div':
                amount_all_lines = [amount.text for amount in amount_all_lines]

                total_sum_parse = []
                for amount in amount_all_lines:
                    amount = amount.split(' ')[:-1]
                    amount = ''.join(amount).replace(',', '.')
                    total_sum_parse.append(float(amount))
                sum_amount_all_lines = sum(total_sum_parse)

            # В КП на индустрию итоговая сумма дистра с НДС в DOM дереве в виде input
            elif tag_name_amount_all_lines == 'input':
                amount_all_lines = [float(amount.get_attribute('value')) for amount in amount_all_lines]
                sum_amount_all_lines = sum(amount_all_lines)

            sum_amount_all_lines = round(sum_amount_all_lines, 2)
            return sum_amount_all_lines

    def store_amount_nds_total_in_kp_crm_cu(self) -> float:
        """Сохранение итоговой стоимости КП с НДС в уе """
        with allure.step('Сохранение итоговой стоимости КП с НДС в уе'):
            amount_total = self.find_element(ModalNewKpLocators.LOCATOR_SPAN_DISTRIBUTOR_AMOUNT_NDS_TOTAL).text
            amount_total = ''.join(amount_total.split())
            amount_total = float(amount_total.replace(',', '.').replace('у.е.', ''))
            return amount_total

    def save_curse_cu_by_article_taking_into_account_promo(self, article: str) -> float:
        """Сохранение внутреннего курса УЕ по артикулу с учетом промо"""
        with allure.step('Сохранение внутреннего курса УЕ по артикулу с учетом промо'):
            default_value_promo_curse = 115.0
            promo_action = self.driver.find_elements(*ModalNewKpLocators.locator_promo_by_article(article))
            if len(promo_action) == 1:
                promo_text_list = promo_action[0].get_attribute('title').split(' ')
                for word in promo_text_list:
                    if word.isnumeric():
                        curse_cu = float(word)
                        return curse_cu
                    else:
                        curse_cu = default_value_promo_curse
                        return curse_cu

            curse_cu = self.find_element(ModalNewKpLocators.LOCATOR_CURSE_CU).text
            curse_cu = float(curse_cu.replace(' ', '').replace('₽', ''))
            return curse_cu

    @staticmethod
    def calculation_of_cost_in_rubles_at_internal_rate_cu(domestic_rate_cu: float, cost_in_cu: float) -> float:
        """Расчет стоимости в рублях по внутреннему курсу уе
        domestic_rate_cu - внутренний курс
        cost_in_cu - стоимость в уе
        """
        with allure.step('Расчет стоимости в рублях по внутреннему курсу уе'):
            res = domestic_rate_cu * cost_in_cu
            res = round(res, 2)
            return res

    def save_price_one_joke_without_nds(self, article: str) -> float:
        """Сохранение цены за штуку без НДС по артикулу"""
        with allure.step('Сохранение цены за штуку без НДС по артикулу'):
            try:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.locator_price_one_joke_without_nds_by_article(article))
                price_one_joke_without_nds = self.find_element(
                    ModalNewKpLocators.locator_price_one_joke_without_nds_by_article(article)
                ).text
                price_one_joke_without_nds = price_one_joke_without_nds.split(' ')[:-1]
                price_one_joke_without_nds = ''.join(price_one_joke_without_nds).replace(',', '.')
                return float(price_one_joke_without_nds)

            except StaleElementReferenceException:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.locator_price_one_joke_without_nds_by_article(article))
                price_one_joke_without_nds = self.find_element(
                    ModalNewKpLocators.locator_price_one_joke_without_nds_by_article(article)
                ).text
                price_one_joke_without_nds = price_one_joke_without_nds.split(' ')[:-1]
                price_one_joke_without_nds = ''.join(price_one_joke_without_nds).replace(',', '.')
                return float(price_one_joke_without_nds)

    def save_amount_with_nds_at_the_client_by_article(self, article: str) -> float:
        """Сохранение суммы с НДС у клиента на всех линиях по артикулу"""
        with allure.step('Сохранение суммы с НДС у клиента на всех линиях по артикулу'):
            amount_with_nds = self.find_element(
                ModalNewKpLocators.locator_amount_with_nds_at_the_client_by_article(article)).text
            amount_with_nds = amount_with_nds.split(' ')[:-1]
            amount_with_nds = ''.join(amount_with_nds).replace(',', '.')
            return float(amount_with_nds)

    @staticmethod
    def calculation_of_amount_with_nds_client(
            price_without_nds: float, count_code: int, discount_client=0.0) -> float:
        """расчет суммы с ндс клиента
        price_without_nds - сумма без НДС
        count_code - количество штук кода
        """
        with allure.step('Расчет суммы с НДС клиента'):
            if discount_client == 0.0:
                amount_with_nds = price_without_nds * count_code * 1.2
                amount_with_nds = round(amount_with_nds, 2)
            else:
                value_discount = price_without_nds * count_code * 1.2 * (discount_client / 100)
                amount_with_nds = price_without_nds * count_code * 1.2
                amount_with_nds = amount_with_nds - value_discount

            return amount_with_nds

    def calculation_amount_with_nds_distributor(self, article: str, amount_without_nds_by_article: float,
                                                discount: float, count_code: int) -> float:
        """Расчет стоимости с НДС Дистрибьютора
        amount_without_nds_by_article - сумма без НДС
        discount -скидка
        """
        with allure.step('Расчет суммы с НДС дистрибьютора'):
            allowance_by_article = self.save_allowance_by_article(article)

            # decimal_places = len(str(discount).split('.')[1])  # Количество знаков после запятой в скидке
            # discount_article = 0.0
            # if decimal_places < 2:
            #     discount_article = round(discount/100, 2)
            # elif decimal_places > 2:
            discount_article = discount / 100

            if allowance_by_article != 0.0:
                value_allowance = (100 + allowance_by_article) / 100  # значение надбавки
                discount_amount = amount_without_nds_by_article * 1.2 * count_code * discount_article * value_allowance  # сумма скидки
                amount_with_nds = amount_without_nds_by_article * 1.2 * count_code * value_allowance
                amount_with_nds_distributor = amount_with_nds - discount_amount
                amount_with_nds_distributor = round(amount_with_nds_distributor, 2)
            else:
                discount_amount = amount_without_nds_by_article * 1.2 * count_code * discount_article  # сумма скидки
                amount_with_nds = amount_without_nds_by_article * 1.2 * count_code
                amount_with_nds_distributor = amount_with_nds - discount_amount
                amount_with_nds_distributor = round(amount_with_nds_distributor, 2)

            return amount_with_nds_distributor

    def saving_number_of_pieces_of_code(self, article: str) -> int:
        """Сохранение количества штук у кода"""
        with allure.step('Сохранение количества штук у кода'):
            count_code = self.find_element(ModalNewKpLocators.locator_input_count_code(article))
            count_code = count_code.get_attribute('value')
            return int(count_code)

    def save_quantity_of_goods_by_positions(self, article_list: list) -> dict:
        """Сохранение количества товара по позициям"""
        with allure.step('Сохранение количества товара по позициям'):
            dict_count_by_article = {}
            for article in article_list:
                count_article = self.saving_number_of_pieces_of_code(article)
                dict_count_by_article[article] = count_article
            return dict_count_by_article

    def save_allowance_by_article(self, article: str) -> float:
        """Сохранение надбавки по коду"""
        with allure.step('Сохранение надбавок по коду'):
            allowance = self.find_element(ModalNewKpLocators.locator_allowance_by_article(article)).text
            allowance = float(allowance.replace(',', '.').replace('%', ''))
            return allowance

    def check_calculation_does_not_have_flag_pending_ik_approval(self, article: str, num_pq: str):
        """Проверка, что у расчета нет флага Ожидается согласование ИК"""
        with allure.step(f'Проверка, что у расчета {article} нет флага Ожидается согласование ИК'):
            assert_text = 'Ожидается согласование ИК'
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_NAME_ARTICLE, sec=5)
            flag = self.driver.find_elements(*ModalNewKpLocators.locator_calculation_flag_pending_approval_ik(article))
            if len(flag) > 0:
                raise MyTimeoutException(
                    f'Флаг Ожидается согласование ИК у артикула {article} присутствует на странице в КП {num_pq}. '
                    f'len - {len(flag)}')
            else:
                flag_text_on_page = [el.text for el in flag]
                assert assert_text not in flag_text_on_page, \
                    f'Флаг {assert_text} присутствует на странице у артикула {article} в КП {num_pq}. ' \
                    f'Все флаги артикула - ({flag_text_on_page})'

    def checking_that_calculation_has_flag_awaiting_ik_approval(self, article: str, num_pq: str):
        """Проверка, что у расчета есть флаг Ожидается согласование ИК"""
        with allure.step(f'Проверка, что у расчета {article} есть флаг Ожидается согласование ИК'):
            expected_text = 'Ожидается согласование ИК'
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_NAME_ARTICLE, sec=5)
            flag = self.driver.find_elements(*ModalNewKpLocators.locator_calculation_flag_pending_approval_ik(article))
            if len(flag) == 0:
                raise AssertionError(
                    f'В КП {num_pq} у артикула {article} нет флага Ожидается согласование ИК. len - {len(flag)}')
            else:
                text_in_flag_on_page = flag[0].text.strip()
                assert text_in_flag_on_page == expected_text, \
                    (f'В КП {num_pq} у артикула {article} не отображается флаг ({expected_text}). Флаг на странице - '
                     f'({text_in_flag_on_page})')

    def entering_number_of_codes(self, article: str, count_codes: int):
        """Ввод количества кодов в колонке Количество"""
        with allure.step('Ввод количества кодов'):
            with allure.step('Очистить поле с кол-ом'):
                input_count_code = self.find_element(ModalNewKpLocators.locator_input_count_code(article))
                input_count_code.clear()
                with allure.step('Проставление кол-ва'):
                    input_count_code.send_keys(count_codes)
                    info_messages = self.driver.find_elements(*BaseCrmLocators.LOCATOR_INFO_MESSAGE)
                    if len(info_messages) > 0:
                        self.waiting_element_invisibility(BaseCrmLocators.LOCATOR_INFO_MESSAGE, sec=120)
                    selected_count_code = input_count_code.get_attribute('value')
                    assert int(selected_count_code) == count_codes, \
                        f'Введенное количество кода - ({selected_count_code}) не соответствует ожидаемому - ({count_codes})'

    def save_total_cost_client(self) -> float:
        """Сохранение итого стоимости у клиента"""
        with allure.step('Сохранение итоговой стоимости у клиента'):
            total_cost = self.find_element(ModalNewKpLocators.LOCATOR_TOTAL_COST_CLIENT).text
            total_cost = total_cost.split(' ')[:-1]
            total_cost = ''.join(total_cost).replace(',', '.')
            return float(total_cost)

    def saving_total_amount_with_nds_all_lines_client(self) -> float:
        """Сохранение общей суммы с НДС по всем линиям у клиента"""
        with allure.step('Сохранение общей суммы с НДС по всем линиям у клиента'):
            total_sum = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_SUM_WITH_NDS_CLIENT)
            total_sum = [cost.text for cost in total_sum]
            total_sum_parse = []
            for cost in total_sum:
                cost = cost.split(' ')[:-1]
                cost = ''.join(cost).replace(',', '.')
                total_sum_parse.append(float(cost))

            total_sum = sum(total_sum_parse)
            total_sum = round(total_sum, 2)
            return total_sum

    def save_amount_with_nds_distributor_by_article(self, article: str) -> float:
        """Сохранение стоимости с НДС Дистрибьютора по артикулу"""
        with allure.step('Сохранение стоимости с НДС Дистрибьютора по артикулу'):
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.locator_amount_with_nds_distributor_by_article(article), sec=30)
            amount_nds = self.find_element(ModalNewKpLocators.locator_amount_with_nds_distributor_by_article(article))

            tag_name_amount_nds = amount_nds.tag_name
            if tag_name_amount_nds == 'div':
                amount_nds = amount_nds.text
                amount_nds = amount_nds.split(' ')[:-1]
                amount_nds = ''.join(amount_nds).replace(',', '.')

            # В КП на индустрию итоговая сумма дистра с НДС в DOM дереве в виде input
            elif tag_name_amount_nds == 'input':
                amount_nds = amount_nds.get_attribute('value')
            return float(amount_nds)

    def save_cost_price_by_article(self, article: str) -> float:
        """Сохранение себестоимости по артикулу"""
        with allure.step('Сохранение себестоимости по артикулу'):
            try:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.locator_cost_price_by_article(article))
                cost_price = self.find_element(ModalNewKpLocators.locator_cost_price_by_article(article)).text
                cost_price = cost_price.split(' ')[:-1]
                cost_price = ''.join(cost_price).replace(',', '.')
            except StaleElementReferenceException:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.locator_cost_price_by_article(article))
                cost_price = self.find_element(ModalNewKpLocators.locator_cost_price_by_article(article)).text
                cost_price = cost_price.split(' ')[:-1]
                cost_price = ''.join(cost_price).replace(',', '.')

            return float(cost_price)

    def save_cost_price_kp(self) -> float:
        """
        Сохранение себестоимости всего КП
        :return: Себестоимость всего КП; float
        """
        with allure.step('Сохранение себестоимости всего КП'):
            try:
                self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_COST_PRICE_KP, sec=5)
                cost_price = self.find_element(ModalNewKpLocators.LOCATOR_COST_PRICE_KP).text.replace(' ', '').replace(
                    ',', '.').replace('₽', '')
                return float(cost_price)
            except TimeoutException as e:
                raise MyTimeoutException(f'{e}\nНе найден элемент Себестоимость общая в КП')

    def save_discount_distributor_by_article(self, article: str) -> float:
        """Сохранение скидки дистрибьютора по артикулу"""
        with allure.step('Сохранение скидки дистрибьютора по артикулу'):
            time.sleep(0.5)
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.locator_discount_distributor_by_article(article), sec=5)
            discount = self.find_element(
                ModalNewKpLocators.locator_discount_distributor_by_article(article)
            )
            discount = discount.get_attribute('value')
            return float(discount)

    def placing_discounts_on_all_items_to_client(self, value_discount: float):
        """Проставление скидок на всех артикулах клиента
        value_discount - значение скидки
        """
        with allure.step('Проставление скидок на всех артикулах клиента'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_INPUT_DISCOUNT_CLIENT)
            self.expecting_clickability(ModalNewKpLocators.LOCATOR_INPUT_DISCOUNT_CLIENT)
            with allure.step('Сохранение списка для проставления скидки'):
                input_discount_list = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_INPUT_DISCOUNT_CLIENT)
                line_code = 1  # Линия кода
                for input_discount in input_discount_list:
                    input_discount.clear()
                    input_discount.send_keys(str(value_discount))
                    time.sleep(0.3)
                    selected_discount = input_discount.get_attribute('value')
                    selected_discount = float(selected_discount)
                    assert selected_discount == value_discount, \
                        f'Введенная скидка {selected_discount} на линии кода {line_code} не соответствует ожидаемой ' \
                        f'{value_discount}'

    def placing_discounts_on_all_items_to_distributor(self, value_discount: float):
        """Проставление скидок на всех артикулах дистра
        value_discount - значение скидки
        """
        with allure.step('Проставление скидок на всех артикулах дистрибьютора'):
            time.sleep(
                4)  # Сейчас после полной загрузки страницы вызывается еще симуляция. Из-за этого страница дергается один раз
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_INPUT_DISCOUNT_DISTRIBUTOR)
            input_discount_list = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_INPUT_DISCOUNT_DISTRIBUTOR)
            line_code = 1  # Линия кода
            for input_discount in input_discount_list:
                self.scroll_to(input_discount)
                self.expecting_clickability(ModalNewKpLocators.LOCATOR_INPUT_DISCOUNT_DISTRIBUTOR)
                input_discount.clear()
                time.sleep(0.2)
                input_discount.send_keys(str(value_discount))
                time.sleep(0.5)
                selected_discount = input_discount.get_attribute('value')
                selected_discount = float(selected_discount)
                assert selected_discount == value_discount, \
                    f'Введенная скидка {selected_discount} на линии кода {line_code} не соответствует ожидаемой ' \
                    f'{value_discount}'

    def placing_a_discount_distributor_by_article(self, value_discount: float, article: str):
        """Проставление скидки дистра по артикулу"""
        with allure.step('Проставление скидки дистра по артикулу'):
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.locator_discount_distributor_by_article(article)
            )
            input_discount_by_article = self.find_element(
                ModalNewKpLocators.locator_discount_distributor_by_article(article)
            )
            with allure.step('Очистка поля скидки дистра'):
                self.expecting_clickability(ModalNewKpLocators.locator_discount_distributor_by_article(article))
                input_discount_by_article.clear()
                with allure.step('Проставление скидок на всех артикулах клиента'):
                    input_discount_by_article.send_keys(value_discount)

                    self.waiting_element_is_visibility_located_dom(
                        ModalNewKpLocators.locator_discount_distributor_by_article(article)
                    )
                    input_discount_by_article = self.find_element(
                        ModalNewKpLocators.locator_discount_distributor_by_article(article)
                    )
                    entered_discount = float(input_discount_by_article.get_attribute('value'))
                    assert entered_discount == value_discount, \
                        f'Введенная скидка - ({entered_discount}) не соответствует ожидаемой - ({value_discount})'

    @staticmethod
    def calculation_cost_price_rub(cost_price_cu: float, curse_central_bank: float):
        """Расчет себестоимости в рублях
        cost_price_cu - себестоимость в уе
        curse_central_bank - курс Центрального Банка
        """
        with allure.step('Расчет себестоимости в рублях'):
            hedging_percentage = 1.015  # Процент хэджирования
            cost_price_rub = cost_price_cu * hedging_percentage * curse_central_bank
            cost_price_rub = round(cost_price_rub, 2)
            return cost_price_rub

    def store_all_discount(self) -> list:
        """Сохранение скидок на всех линиях"""
        with allure.step('Сохранение скидок на всех линиях'):
            list_all_discount_web_element = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_DISCOUNT)
            list_all_discount = []
            for discount in list_all_discount_web_element:
                list_all_discount.append(float(discount.get_attribute("value")))
            return list_all_discount

    def checking_calculation_of_total_amount_with_nds_by_items(self, list_article):
        """Проверка расчета итоговой суммы с НДС по позициям"""
        # Проверка расчета итоговой суммы с НДС по позициям
        for article in list_article:
            price_per_piece_without_nds = Decimal(self.save_price_one_joke_without_nds(article)
                                                  )  # Цена без НДС за штуку

            quantity = self.saving_number_of_pieces_of_code(article)  # Количество штук артикула

            nds = Decimal(1.2)  # НДС в 20%

            distributor_discount = Decimal(self.save_discount_distributor_by_article(article))  # Скидка дистрибьютора
            distributor_discount = Decimal((100 - distributor_discount) / 100)

            allowance = Decimal(self.save_allowance_by_article(article))  # Надбавка по коду

            # Находим общую сумму без учета скидок дистрибьютора
            total_amount_excluding_discounts = Decimal(price_per_piece_without_nds * quantity * nds)

            #  Находим общую сумму с учетом скидок дистрибьютора
            total_amount_with_discounts_distributor = Decimal(total_amount_excluding_discounts * distributor_discount) \
                if distributor_discount != 0 else total_amount_excluding_discounts

            # Находим общую сумму с учетом надбавок - конечная итоговая сумма по позиции
            total_amount_with_nds_by_position = total_amount_with_discounts_distributor * allowance \
                if allowance != 0 else total_amount_with_discounts_distributor
            total_amount_with_nds_by_position = float(round(total_amount_with_nds_by_position, 2))

            # Сохраняем итоговую сумму по позиции на странице и сравниваем с ожидаемой итоговой суммой,
            # которую рассчитали по формуле
            total_amount_with_nds_by_position_on_page = self.save_amount_with_nds_distributor_by_article(article)

            assert abs(total_amount_with_nds_by_position_on_page - total_amount_with_nds_by_position) < 0.5, \
                f'Итоговая сумма на странице - ({total_amount_with_nds_by_position_on_page}) по позиции {article} ' \
                f'не соответствует ожидаемой итоговой сумме, которую рассчитали по формуле- ' \
                f'({total_amount_with_nds_by_position})'

    def entering_a_comment_in_kp(self, comment='selenium_web_test'):
        """Ввод комментария в КП"""
        with allure.step('Ввод комментария в КП'):
            input_comment = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_COMMENT_IN_KP)
            input_comment.send_keys(comment)
            entered_comment = input_comment.get_attribute('value')
            assert entered_comment == comment, \
                f'Введенный комментарий - ({entered_comment}) не соответствует ожидаемому - ({comment})'

    def save_central_bank_rate(self) -> float:
        """Сохранение курса Центрального Банка"""
        with allure.step('Сохранение курса Центрального банка'):
            check_toggle_currency = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_CURRENCY_SWITCH)
            bool_check_toggle_currency = check_toggle_currency.is_selected()
            if bool_check_toggle_currency:
                # toggle_switch_currency = self.find_element(ModalNewKpLocators.LOCATOR_TOGGLE_SWITCH_CURRENCY)
                # toggle_switch_currency.click()
                self.switching_currency_to_a_fixed_rate()
                bool_check_toggle_currency = check_toggle_currency.is_selected()
                assert bool_check_toggle_currency is False, f'Тумблер переключения валюты переключен на рубли'
            curse_central_bank = self.find_element(ModalNewKpLocators.LOCATOR_RATE_CENTRAL_BANK).get_attribute('value')
            curse_central_bank = curse_central_bank.replace(',', '.').replace('₽', '')
            return float(curse_central_bank)

    def saving_current_course_in_kp_by_article(self, article: str) -> float:
        """Сохранение текущего курса в КП"""
        with allure.step('Сохранение текущего курса в КП'):
            # course_in_kp = 0.0
            check_toggle_currency = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_CURRENCY_SWITCH)
            bool_check_toggle_currency = check_toggle_currency.is_selected()
            print(bool_check_toggle_currency, 'bool_check_toggle_currency')

            promo_action = self.driver.find_elements(*ModalNewKpLocators.locator_promo_by_article(article))
            if not bool_check_toggle_currency:
                course_in_kp = self.find_element(ModalNewKpLocators.LOCATOR_RATE_CENTRAL_BANK).get_attribute('value')
                course_in_kp = float(course_in_kp.replace(',', '.').replace('₽', ''))
                print(course_in_kp, 'course_in_kp')

            elif promo_action:
                course_in_kp = self.save_promo_curse(article)
                print(course_in_kp, 'course_in_kp')
                # promo_action = self.driver.find_elements(*ModalNewKpLocators.locator_promo_by_article(article))
                # print('promo_action')
                # if len(promo_action) == 1:
                #     print(len(promo_action))
                #     promo_text_list = promo_action[0].get_attribute('title').split(' ')
                #     for word in promo_text_list:
                #         if word.isnumeric():
                #             course_in_kp = float(word)
                #             print(course_in_kp, 'course_in_kp promo')
                #             return course_in_kp
            else:
                course_in_kp = self.find_element(ModalNewKpLocators.LOCATOR_CURSE_CU).text
                course_in_kp = float(course_in_kp.replace(' ', '').replace('₽', ''))
            return course_in_kp

    def save_promo_curse(self, article: str) -> float:
        """Сохранение промо курса"""
        with allure.step('Сохранение Промо Курса'):
            default_value = 115.0
            promo_action = self.driver.find_elements(*ModalNewKpLocators.locator_promo_by_article(article))
            if len(promo_action) == 1:
                print(len(promo_action))
                promo_text_list = promo_action[0].get_attribute('title').split(' ')
                for word in promo_text_list:
                    if word.isnumeric():
                        course_in_kp = float(word)
                        print(course_in_kp, 'course_in_kp promo')
                    else:
                        course_in_kp = default_value
                return course_in_kp
            else:
                raise MyTimeoutException(f'Не найден промо-курс у артикула - {article}')

    def check_calculation_by_promo_code_with_price_in_usd(self, price_in_assortments_ue: float, article: str,
                                                          price_without_nds_on_page: float):
        """Проверка расчета цены без НДС у кода, у которого цена в ассортименте в УЕ
        price_in_assortments_ue - цена кода в уе в ассортименте
        price_without_nds_on_page - цена за шт. без НДС в модалке создания КП
        """
        with allure.step('Проверка расчета цены без НДС у кода, у которого цена в ассортименте в УЕ'):
            promo_course_by_article = self.save_promo_curse(article)
            print(promo_course_by_article, '--')

            expected_price = price_in_assortments_ue * promo_course_by_article

            assert expected_price == price_without_nds_on_page, \
                f'Стоимость за шт без НДС кода {article} в модалке создания КП - ({price_without_nds_on_page}) ' \
                f'не соответствует ожидаемой - ({expected_price})'

    def internal_course_toggle_switch_must_be_turned_on(self):
        """Должен быть включен тумблер внутреннего курса"""
        with allure.step('Проверка что включен тумблер внутреннего курса'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_INPUT_CURRENCY_SWITCH, sec=5)
            input_internal_course = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_CURRENCY_SWITCH)
            internal_course_toggle_switch_status = input_internal_course.is_selected()

            assert internal_course_toggle_switch_status is True, \
                f'Внутренний курс не включен. Состояние включения тумблера внутреннего ' \
                f'курса - ({internal_course_toggle_switch_status})'

    def checking_that_internal_rate_switch_is_not_clickable(self):
        """Проверка, что тумблер внутреннего курса не кликабелен"""
        with allure.step('Проверка, что тумблер внутреннего курса не кликабелен'):
            expected_style_span_toggle = 'opacity: 0.5'  # Ожидаемый стиль в элементе span тумблера переключения валюты для блокировки кликабельности
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_INPUT_CURRENCY_SWITCH, sec=5)
            input_internal_course = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_CURRENCY_SWITCH)
            disabled_input_internal_course = input_internal_course.get_attribute('disabled')
            assert disabled_input_internal_course == 'true', \
                f'Переключатель внутреннего курса кликабелен. Значение disabled - {disabled_input_internal_course}'

            read_only_input_internal_course = input_internal_course.get_attribute('readonly')
            assert read_only_input_internal_course == 'true', \
                f'Переключатель внутреннего курса кликабелен'
            # Проверяем свойство стиля opacity у span элемента переключателя

            span_toggle_style = self.find_element(ModalNewKpLocators.LOCATOR_SPAN_TOGGLE_SWITCH_CURRENCY
                                                  ).get_attribute('style')
            assert expected_style_span_toggle in span_toggle_style, \
                f'Переключатель внутреннего курса кликабелен. ' \
                f'Значение style у элемента span тумблера переключения валюты для блокировки кликабельности' \
                f' - {span_toggle_style}'

    def check_inn_checked(self):
        """Проверка, что ИНН проверен (надпись под конечным покупателем)"""
        with allure.step('Проверка, что ИНН проверен (надпись под конечным покупателем)'):
            expected_style = 'green'
            expected_info = 'ИНН проверен'
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_INN_INFO_CHECKED, sec=5)
            inn_info = self.find_element(ModalNewKpLocators.LOCATOR_INN_INFO_CHECKED)
            inn_info_text = inn_info.text
            assert inn_info_text == expected_info, \
                f'Информация о проверке ИНН под конечным покупателем - ({inn_info_text}) не соответствует ожидаемой ' \
                f'- ({expected_info})'

            style_info_inn = inn_info.get_attribute('style')
            assert expected_style in style_info_inn, \
                f'Стиль записи информации о проверке ИНН на странице - ({style_info_inn}) не соответствует ожидаемому ' \
                f'- ({expected_style})'

    def check_heading_in_additional_expenses(self, expected_head: str):
        """Проверка, что есть заголовок expected_head в разделе Дополнительные расходы/Условия поставки"""
        with allure.step('Проверка, что есть заголовок Транспортные расходы в разделе '
                         'Дополнительные расходы/Условия поставки'):
            self.waiting_element_is_visibility_on_the_page(
                ModalNewKpLocators.LOCATOR_HEADINGS_IN_ADDITIONAL_COSTS_SECTION, sec=5)
            headings_in_additional_expenses = self.find_elements(
                ModalNewKpLocators.LOCATOR_HEADINGS_IN_ADDITIONAL_COSTS_SECTION)  # Заголовки в разделе Дополнительные условия
            headers_delivery_terms_section = self.find_elements(
                ModalNewKpLocators.LOCATOR_HEADERS_IN_DELIVERY_TERMS_SECTION)  # Заголовки в разделе Условия поставки
            headings_in_additional_expenses = [el.text for el in headings_in_additional_expenses]
            headers_delivery_terms_section = [el.text for el in headers_delivery_terms_section]
            all_headers = headers_delivery_terms_section + headings_in_additional_expenses

            assert expected_head in all_headers, \
                f'Заголовка ({expected_head}) нет в разделе Дополнительные расходы/Условия поставки. Все заголовки ' \
                f'в разделе -({all_headers})'

    def checking_input_field_transportation_costs_in_rub_is_blocked(self):
        """Проверка, что поле ввода Транспортные расходы заблочено для редактирования"""
        with allure.step('Проверка, что поле ввода Транспортные расходы заблочено для редактирования'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_INPUT_TRANSPORTATION_COSTS_RUB,
                                                           sec=5)
            input_transportation_costs = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_TRANSPORTATION_COSTS_RUB)
            is_not_editable = self.driver.execute_script("return arguments[0].disabled || arguments[0].readOnly",
                                                         input_transportation_costs)
            assert is_not_editable is True, \
                f'Поле ввода Транспортные расходы редактируемо. is_not_editable - {is_not_editable}'

    def check_amount_of_transport_costs_in_rubles(self, expected_amount_transport_costs=0.0):
        """Проверка суммы транспортных расходов в рублях"""
        with allure.step('Проверка суммы транспортных расходов в рублях'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_INPUT_TRANSPORTATION_COSTS_RUB,
                                                           sec=5)
            amount_transport_costs_on_page = float(self.find_element(
                ModalNewKpLocators.LOCATOR_INPUT_TRANSPORTATION_COSTS_RUB).get_attribute('value'))
            assert amount_transport_costs_on_page == expected_amount_transport_costs, \
                f'Сумма транспортных расходов в рублях на странице - ({amount_transport_costs_on_page}) ' \
                f'не соответствует ожидаемой - ({expected_amount_transport_costs})'

    def checking_that_field_shipment_from_warehouse_in_moscow_is_empty(self):
        """Проверка, что поле Отгрузка со склада в г. Москва пустое"""
        with allure.step('Проверка, что поле Отгрузка со склада в г. Москва пустое'):
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.LOCATOR_INPUT_SHIPMENT_FROM_WAREHOUSE_IN_MOSCOW, sec=5)
            input_shipment_from_warehouse_in_moscow = self.find_element(
                ModalNewKpLocators.LOCATOR_INPUT_SHIPMENT_FROM_WAREHOUSE_IN_MOSCOW)
            value_input_shipment_from_warehouse_in_moscow = input_shipment_from_warehouse_in_moscow.get_attribute(
                'value')
            assert value_input_shipment_from_warehouse_in_moscow == '', \
                f'Поле Отгрузка со склада в г. Москва не пустое. value - ({value_input_shipment_from_warehouse_in_moscow})'

    def checking_input_field_shipment_from_warehouse_in_moscow_is_blocked(self):
        """Проверка, что поле Отгрузка со склада в г. Москва не редактируемо"""
        with allure.step('Проверка, что поле Отгрузка со склада в г. Москва не редактируемо'):
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.LOCATOR_INPUT_SHIPMENT_FROM_WAREHOUSE_IN_MOSCOW, sec=5
            )
            input_shipment_from_warehouse_in_moscow = self.find_element(
                ModalNewKpLocators.LOCATOR_INPUT_SHIPMENT_FROM_WAREHOUSE_IN_MOSCOW)
            is_not_editable = self.driver.execute_script("return arguments[0].disabled || arguments[0].readOnly",
                                                         input_shipment_from_warehouse_in_moscow)
            assert is_not_editable is True, \
                f'Поле ввода Отгрузка со склада в г. Москва редактируемо. is_not_editable - {is_not_editable}'

    def checking_input_shipment_from_warehouse_in_dzerzhinsk_is_blocked(self):
        """Проверка, что поле Отгрузка со склада в г. Дзержинск: не редактируемо"""
        with allure.step('Проверка, что поле Отгрузка со склада в г. Дзержинск: не редактируемо'):
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.LOCATOR_INPUT_SHIPMENT_FROM_WAREHOUSE_IN_DZERZHINSK, sec=5)
            input_shipment_from_warehouse_in_dzerzhinsk = self.find_element(
                ModalNewKpLocators.LOCATOR_INPUT_SHIPMENT_FROM_WAREHOUSE_IN_DZERZHINSK)
            is_not_editable = self.driver.execute_script("return arguments[0].disabled || arguments[0].readOnly",
                                                         input_shipment_from_warehouse_in_dzerzhinsk)
            assert is_not_editable is True, \
                f'Поле ввода Отгрузка со склада в г. Дзержинск: редактируемо. is_not_editable - {is_not_editable}'

    def check_invisibility_input_transportation_costs_cu(self):
        """Проверка, что поле ввода Транспортные расходы в УЕ не видно на странице"""
        with allure.step('Проверка, что поле ввода Транспортные расходы в УЕ не видно на странице'):
            expected_style = 'display: none;'
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.LOCATOR_HEADINGS_IN_ADDITIONAL_COSTS_SECTION, sec=5)

            style_block_input_transportation_costs_cu = self.find_element(
                ModalNewKpLocators.LOCATOR_DIV_INPUT_TRANSPORTATION_COSTS_CU).get_attribute('style')
            assert expected_style == style_block_input_transportation_costs_cu, \
                f'Поле ввода Транспортные расходы в УЕ видно на странице. Значение стиля блока input - ' \
                f'({style_block_input_transportation_costs_cu})'

    def check_invisibility_input_weight_shipment_from_warehouse_in_moscow(self):
        """Проверка, что поле ввода веса Отгрузка со склада в г.Москва не видно на странице"""
        with allure.step('Проверка, что поле ввода веса Отгрузка со склада в г.Москва не видно на странице'):
            expected_style = 'display: none;'
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.LOCATOR_DIV_INPUT_WEIGHT_SHIPMENT_FROM_WAREHOUSE_IN_MOSCOW, sec=5)

            style_block_input_transportation_costs_cu = self.find_element(
                ModalNewKpLocators.LOCATOR_DIV_INPUT_WEIGHT_SHIPMENT_FROM_WAREHOUSE_IN_MOSCOW).get_attribute('style')
            assert expected_style == style_block_input_transportation_costs_cu, \
                f'Поле ввода  веса Отгрузка со склада в г.Москва видно на странице. Значение стиля блока input - ' \
                f'({style_block_input_transportation_costs_cu})'

    def check_invisibility_input_shipment_from_warehouse_in_dzerzhinsk(self):
        """Проверка, что поле ввода веса Отгрузка со склада в г. Дзержинск: не видно на странице"""
        with allure.step('Проверка, что поле ввода веса Отгрузка со склада в г. Дзержинск: не видно на странице'):
            expected_style = 'display: none;'
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.LOCATOR_DIV_INPUT_SHIPMENT_FROM_WAREHOUSE_IN_DZERZHINSK, sec=5)

            style_block_input_transportation_costs_cu = self.find_element(
                ModalNewKpLocators.LOCATOR_DIV_INPUT_SHIPMENT_FROM_WAREHOUSE_IN_DZERZHINSK).get_attribute('style')
            assert expected_style == style_block_input_transportation_costs_cu, \
                f'Поле ввода  веса Отгрузка со склада в г. Дзержинск видно на странице. Значение стиля блока input - ' \
                f'({style_block_input_transportation_costs_cu})'

    def click_btn_save_pq(self):
        """Клик по кнопке Сохранение PQ"""
        with allure.step('Клик по кнопке Сохранить PQ'):
            time.sleep(2)
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BUTTON_SAVE)
            button_save = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_SAVE)
            button_save.click()
            time.sleep(0.5)
            self.waiting_element_is_visibility_on_the_page(BaseCrmLocators.LOCATOR_LOADER, sec=5)
            try:
                count_loader = len(self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER))
                while count_loader > 0:
                    self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER, sec=150)
                    time.sleep(1)
                    count_loader = len(self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER))
            except TimeoutException:
                count_loader = len(self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER))
                while count_loader > 0:
                    self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER, sec=150)
                    time.sleep(2)
                    count_loader = len(self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER))

    def checking_that_approvals_have_appeared(self, num_pq: str):
        """Проверка, что появились согласования"""
        with allure.step('Проверка, что появились согласования'):
            time_wait = 5
            try:
                self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_NAME_OF_TYPE_OF_APPROVAL,
                                                               sec=time_wait)
                approvals = self.find_elements(ModalNewKpLocators.LOCATOR_NAME_OF_TYPE_OF_APPROVAL)
                len_approvals = len(approvals)
                assert len_approvals != 0, \
                    f'В модалке создания КП {num_pq} нет ни одного согласования. Количество согласований ({len_approvals})'
            except TimeoutException:
                raise MyTimeoutException(
                    f'В {num_pq} не отображается ни одного согласования во время ожидания в {time_wait} сек')

    def save_code_gcm_by_article(self, article: str) -> str:
        """
        Сохранение кода ГЦМ по артикулу
        :param article: Артикул товара
        :return: Код ГЦМ; str
        """
        with allure.step(f'Сохранение кода ГЦМ по артикулу {article}'):
            try:
                self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.locator_code_gcm_by_article(article),
                                                               sec=3)
                code_gcm = self.find_element(ModalNewKpLocators.locator_code_gcm_by_article(article)).text.split(' ')[0]
            except TimeoutException as e:
                raise MyTimeoutException(f'{e}\nНе найден код ГЦМ по артикулу')
            return code_gcm

    def store_valuation_margin_values(self) -> float:
        """Сохранение значения оценочной маржи"""
        with allure.step('Сохранение значения оценочной маржи'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_ESTIMATE_MARGIN_KP, sec=5)
            margin_value = self.find_element(ModalNewKpLocators.LOCATOR_ESTIMATE_MARGIN_KP
                                             ).text.replace(' ', '').replace('%', '').replace(',', '.')
            return float(margin_value)

    def store_value_percent_margin_by_article(self, article: str) -> float:
        """
        Сохранение процентного значения маржи по артикулу
        :param article: Артикул товара
        :return: Процентное значение маржи по артикулу; float
        """
        with allure.step(f'Сохранение процентного значения маржи по артикулу {article}'):
            try:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.locator_margin_value_by_article(article),
                    sec=5)
                margin_value = self.find_element(ModalNewKpLocators.locator_margin_value_by_article(article)
                                                 ).text.replace('%', '').replace(' ', '').replace(',', '.')
                return float(margin_value)
            except StaleElementReferenceException:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.locator_margin_value_by_article(article),
                    sec=5)
                margin_value = self.find_element(ModalNewKpLocators.locator_margin_value_by_article(article)
                                                 ).text.replace('%', '').replace(' ', '').replace(',', '.')
                return float(margin_value)
            except TimeoutException as e:
                raise MyTimeoutException(f'{e}\nНе найден элемент Значение маржи у артикула {article} на странице')

    def store_value_percent_margin_by_code_gcm(self, code_gcm: str) -> float:
        """
        Сохранение процентного значения маржи по коду ГЦМ
        :param code_gcm: код ГЦМ
        :return: Значение маржи; float
        """
        with allure.step(f'Сохранение процентного значения маржи по коду ГЦМ {code_gcm}'):
            try:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.locator_margin_value_by_code_gcm(code_gcm), sec=3)
                margin_value = self.find_element(ModalNewKpLocators.locator_margin_value_by_code_gcm(code_gcm)
                                                 ).text.replace('%', '').replace(' ', '').replace(',', '.')
                return float(margin_value)
            except TimeoutException as e:
                raise MyTimeoutException(f'{e}\nНе найден элемент Значение маржи по ГЦМ {code_gcm} на странице')

    @staticmethod
    def style_color_background_color_margin_by_actual_margin_to_target_margin_ratio(
            actual_margin_to_target_margin_ratio: float) -> str:
        """
        Определение цвета стиля background-color у маржи в зависимости от коэффициента фактической маржи к целевой маржи
        :param actual_margin_to_target_margin_ratio:  коэффициент фактической маржи к целевой маржи
        :return: style background-color; str
        """
        with allure.step(
                'Определение цвета стиля background-color у маржи в зависимости от коэффициента фактической маржи к целевой маржи'):
            dict_color_style = {
                'green': '#5cb85c',
                'yellow': '#f0ad4e',
                'red': '#d9534f',
                'violet': '#902df0'
            }
            print(actual_margin_to_target_margin_ratio, 'actual_margin_to_target_margin_ratio')
            if actual_margin_to_target_margin_ratio >= 1.02:
                return dict_color_style['green']  # зеленый цвет
            elif 0.98 <= actual_margin_to_target_margin_ratio < 1.02:
                return dict_color_style['yellow']  # желтый цвет
            elif 0 <= actual_margin_to_target_margin_ratio < 0.98:
                return dict_color_style['red']  # красный цвет
            elif actual_margin_to_target_margin_ratio < 0:
                return dict_color_style['violet']  # фиолетовый цвет
            else:
                raise MyException(
                    f'Значение коэффициента {actual_margin_to_target_margin_ratio} не соответствует ни одному условию')

    def save_background_color_hex(self, locator) -> str:
        """
        Сохранение значения стиля background color в hex
        :return: Значение стиля background color в hex; str
        """
        with allure.step('Сохранение значения стиля background color в hex'):
            try:
                self.waiting_element_is_visibility_located_dom(locator, sec=5)
                background_color = self.find_element(locator).value_of_css_property('background-color')
            except StaleElementReferenceException:
                self.waiting_element_is_visibility_located_dom(locator, sec=5)
                background_color = self.find_element(locator).value_of_css_property('background-color')
            background_color_hex = Color.from_string(
                background_color).hex  # Переводим значение rgba в hex
            return background_color_hex

    def checking_color_of_margin_indicator_kp(self, actual_margin_to_target_margin_ratio: float):
        """
        Проверка цвета индикатора маржи во всему КП
        :param actual_margin_to_target_margin_ratio: коэффициент фактической маржи к целевой маржи
        :return: None
        """
        with (allure.step('Проверка цвета индикатора маржи всего КП')):
            expected_value_style = self.style_color_background_color_margin_by_actual_margin_to_target_margin_ratio(
                actual_margin_to_target_margin_ratio
            )
            background_color_margin_on_page = self.save_background_color_hex(
                ModalNewKpLocators.LOCATOR_MARGIN_INDICATOR_KP)

            assert expected_value_style == background_color_margin_on_page, \
                f'Стиль background-color у маржи (цвет индикатора маржи) - ({background_color_margin_on_page}) ' \
                f'в КП не соответствует ожидаемому - ({expected_value_style})'

    def check_equality_colors_indicator_profitability_by_kp_and_estimated_margin_by_kp(self):
        """
        Проверка равенства цветов индикатора доходности по кп и оценочной маржи по кп
        :return: None
        """
        with allure.step('Проверка равенства цветов индикатора доходности по кп и оценочной маржи по кп'):
            color_indicator_profitability_by_kp = self.save_background_color_hex(
                ModalNewKpLocators.LOCATOR_KP_PROFITABILITY_INDICATOR)
            color_margin_indicator_kp = self.save_background_color_hex(ModalNewKpLocators.LOCATOR_MARGIN_INDICATOR_KP)
            assert color_margin_indicator_kp == color_indicator_profitability_by_kp, \
                (
                    f'Цвет индикатора доходности по КП - ({color_indicator_profitability_by_kp}) отличается от цвета оценочной '
                    f'маржи по всему КП - ({color_margin_indicator_kp})')

    def checking_color_of_margin_indicator_for_each_hcm(self, gcm: str,
                                                        actual_margin_to_target_margin_ratio: float):
        """
        Проверка цвета индикатора маржи по каждой ГЦМ
        :param gcm: код ГЦМ
        :param actual_margin_to_target_margin_ratio:  коэффициент фактической маржи к целевой маржи
        :return: None
        """
        with (allure.step('Проверка цвета индикатора маржи по каждой ГЦМ')):
            expected_value_style = self.style_color_background_color_margin_by_actual_margin_to_target_margin_ratio(
                actual_margin_to_target_margin_ratio
            )

            background_color_margin_on_page = self.save_background_color_hex(
                ModalNewKpLocators.locator_margin_value_by_code_gcm(gcm))

            assert expected_value_style == background_color_margin_on_page, \
                f'Стиль background-color у маржи (цвет индикатора маржи) - ({background_color_margin_on_page}) ' \
                f'в ГЦМ {gcm} не соответствует ожидаемому - ({expected_value_style})'

    def calculation_of_sales_amount_without_nds_by_article(self, article: str) -> float:
        """
        Расчет суммы продажи без НДС по артикулу
        :param article: Артикул товара
        :return: Значение суммы продажи без НДС; float
        """
        with allure.step('Расчет суммы продажи без НДС по артикулу'):
            amount_with_nds_distributor = self.save_amount_with_nds_distributor_by_article(article)

            sales_amount_without_nds = amount_with_nds_distributor / 1.2
            return round(sales_amount_without_nds, 2)

    def checking_calculation_of_margin_by_article(self, article: str, sales_amount_without_nds: float):
        """
        Проверка расчета маржи по артикулу.
        Формула: (сумма продажи без НДС артикула - себестоимость артикула) / сумма продажи без НДС артикула
        :param article: артикул товара
        :param sales_amount_without_nds: Сумма продажи без НДС
        :return: None
        """
        with allure.step(f'Проверка расчета маржи по артикулу {article}'):
            cost_price = self.save_cost_price_by_article(article)  # Себестоимость
            margin_on_page = self.store_value_percent_margin_by_article(article)  # Значение маржи
            expected_margin = (
                                      sales_amount_without_nds - cost_price) / sales_amount_without_nds  # Ожидаемое значение маржи
            expected_margin = round(expected_margin * 100, 1)

            assert margin_on_page == expected_margin, \
                f'Значение маржи на странице ({margin_on_page}) артикула {article} не соответствует ожидаемому - ({expected_margin})'

    def check_visible_type_of_agreement(self, expected_type_agreement: list, num_pq: str):
        """Проверка, что тип согласования присутствует на странице PQ или в модалке создания КП"""
        with allure.step('Проверка, что тип согласования присутствует на странице PQ или в модалке создания КП'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_NAME_OF_TYPE_OF_APPROVAL, sec=5)
            all_agreement_on_page = self.find_elements(ModalNewKpLocators.LOCATOR_NAME_OF_TYPE_OF_APPROVAL)
            all_agreement_on_page = [el.text.strip() for el in all_agreement_on_page]

            with allure.step(
                    f'Проверяем, что ожидаемые согласователи - ({expected_type_agreement}) есть на странице PQ {num_pq}'):
                for expected_agreement in expected_type_agreement:
                    found = False
                    for agreement_on_page in all_agreement_on_page:
                        if expected_agreement in agreement_on_page:
                            found = True
                            print(f'Ожидаемое согласование ({expected_agreement}) есть в {num_pq}')
                    if not found:
                        raise MyTimeoutException(
                            f'Тип согласования ({expected_agreement}) не присутствует в общем списке согласования {num_pq}. '
                            f'Общий список согласований - ({agreement_on_page})')

    def check_margin_agreements(self, value_margin: float, num_pq: str):
        """Проверка отображения в кп согласования маржи"""
        with allure.step('Проверка отображения в кп согласования маржи'):
            header_margin_agreement = 'Маржа'
            if value_margin < 30:
                all_agreement_on_page = self.store_all_type_agreements_on_page()
                assert header_margin_agreement in all_agreement_on_page, \
                    f'Значение маржи в КП - ({value_margin}). Согласование Маржа нет в {num_pq}'
            else:
                print(f'Значение маржи в {num_pq} - {value_margin}')
                self.check_no_visible_type_of_agreement(header_margin_agreement, num_pq)

    def store_all_type_agreements_on_page(self) -> list:
        """Сохранение названия всех типов согласований"""
        with allure.step('Сохранение названия всех типов согласований'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_NAME_OF_TYPE_OF_APPROVAL, sec=5)
            all_agreement_on_page = self.find_elements(ModalNewKpLocators.LOCATOR_NAME_OF_TYPE_OF_APPROVAL)
            all_agreement_on_page = [self.get_text_without_nesting(el).strip() for el in all_agreement_on_page]
            return all_agreement_on_page

    def check_no_visible_type_of_agreement(self, type_agreement_no_visible: str, num_pq: str):
        """Проверка отсутствия типа согласования на странице PQ или модалки создания КП
        type_agreement_no_visible - тип согласования, которого не должно быть
        """
        with allure.step('Проверка отсутствия типа согласования на странице PQ или модалки создания КП'):
            all_agreement_on_page = self.store_all_type_agreements_on_page()

            assert type_agreement_no_visible not in all_agreement_on_page, \
                f'Тип согласования ({type_agreement_no_visible}) присутствует в общем списке согласования {num_pq}. ' \
                f'Общий список согласований - ({all_agreement_on_page})'

    def checking_that_there_are_agreements_in_approval_steps(self, num_pq):
        """Проверка, что в шагах согласования есть согласованты(хотя бы один)"""
        with allure.step('Проверка, что в шагах согласования есть согласованты(хотя бы один)'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_NUM_PQ, sec=5)
            count_steps_approval = len(self.find_elements(ModalNewKpLocators.LOCATOR_NAME_OF_TYPE_OF_APPROVAL))

            for step in range(1, count_steps_approval + 1):
                coordinator = self.driver.find_elements(*ModalNewKpLocators.locator_line_number_coordinators(step))
                coordinator = [el.text for el in coordinator]
                assert '' not in coordinator, \
                    f'В {num_pq} есть шаги согласования, в которых ни одного согласователя. {coordinator}. ' \
                    f'Строка согласования {step}'

    def store_num_pq_in_title(self):
        """Сохранение номера PQ в заголовке"""
        with allure.step('Сохранение номера PQ в заголовке'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_NUM_PQ)
            num_pq = self.find_element(ModalNewKpLocators.LOCATOR_NUM_PQ).text
            return num_pq

    def check_name_pq(self, expected_name_pq: str, num_pq: str):
        """Проверка наименования КП
        :param expected_name_pq: Ожидаемое наименование (Пример: IND, PQ)
        :param num_pq: Номер КП
        """
        with allure.step(f'Проверка наименования КП {num_pq}'):
            pq_on_page = self.store_num_pq_in_title()
            name_on_page = ''
            for el in pq_on_page:
                if el.isalpha():
                    name_on_page += el

            assert expected_name_pq == name_on_page, \
                f'Наименование КП на странице ({name_on_page}) не соответствует ожидаемому - ({expected_name_pq})'

    def send_for_approval_from_modal_new_kp(self):
        """Клик по кнопке На согласование из модалки создания КП"""
        with allure.step('Клик по кнопке На согласование'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BUTTON_ON_APPROVAL)
            self.expecting_clickability(ModalNewKpLocators.LOCATOR_BUTTON_ON_APPROVAL)
            button_approval = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_ON_APPROVAL)
            self.click_js(button_approval)
            time.sleep(1)
            # При отправке много лоадеров с разным текстом идут друг за другом
            loader = self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER_MODAL)
            if len(loader) > 0:
                self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER_MODAL)
            # self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER)
            loader = self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER)
            while len(loader) > 0:
                self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER, sec=150)
                time.sleep(1)
                loader = self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER)
            self.modal_send_to_distributor()
            self.modal_kp_has_not_been_pre_screened()
            self.modal_please_indicate_your_main_competitor_and_supplier()
            self.modal_send_to_distributor()
            try:
                self.waiting_element_invisibility(ModalNewKpLocators.LOCATOR_NUM_PQ, sec=5)
            except TimeoutException as e:
                raise MyTimeoutException(f'{e}\n КП не отправлено на согласование. '
                                         f'Модалка создания КП не закрылась после отправки на согласование')

    def check_btn_on_approval_is_disabled(self):
        """Проверка, что кнопка На согласование не активна для нажатия"""
        self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BUTTON_ON_APPROVAL, sec=5)
        btn_on_approval_is_enabled = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_ON_APPROVAL).is_enabled()
        assert btn_on_approval_is_enabled is True, \
            f'Кнопка На согласование активна для нажатия. is_enabled - {btn_on_approval_is_enabled}'

    def modal_send_to_distributor(self):
        """Модалка Отправить дистрибьютору, отправка"""
        with allure.step('Работа в модальном окне Отправить дистрибьютору'):
            h4_send_to_distributor = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_H4_SEND_TO_DISTRIBUTOR)
            with allure.step('Клик по кнопке Отправить'):
                if len(h4_send_to_distributor) > 0:
                    self.expecting_clickability(ModalNewKpLocators.LOCATOR_BUTTON_SEND)
                    button_send = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_SEND)
                    button_send.click()
                    time.sleep(2)
                    loader = self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER)
                    count_time = 0
                    wait_time_sec = 120  # Время ожидания в секундах
                    while len(loader) > 0:
                        count_time += 1
                        self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER,
                                                                   sec=wait_time_sec)
                        time.sleep(1)
                        loader = self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER)
                        if count_time > 3:
                            raise MyTimeoutException(
                                f'Ошибка ожидания лоадера. Время ожидания - ({count_time * wait_time_sec}) сек.')

    def there_should_be_a_modal_kp_did_not_pass_preliminary_check(self):
        """Должна быть Модалка КП не прошло предварительную проверку"""
        with allure.step('Должна быть Модалка КП не прошло предварительную проверку'):
            h4_pre_check = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_H4_PRE_CHECK)
            assert len(h4_pre_check) > 0, f'Модалка КП не прошло предварительную проверку не появилась на странице. ' \
                                          f'{len(h4_pre_check)}'

    def modal_please_indicate_your_main_competitor_and_supplier(self):
        """Модалка Укажите основного конкурента и поставщика. Заполнение и сохранение. Для отправки на согласование"""
        with allure.step('Модалка Укажите основного конкурента и поставщика. Заполнение и сохранение'):
            h4_pre_check = self.driver.find_elements(
                *ModalPleaseIndicateYourMainCompetitorAndSupplierLocators.LOCATOR_HEADER)
            if len(h4_pre_check) == 1:
                self.expecting_clickability(
                    ModalPleaseIndicateYourMainCompetitorAndSupplierLocators.LOCATOR_INPUT_COMPETITOR, sec=5)
                input_competitor = self.find_element(
                    ModalPleaseIndicateYourMainCompetitorAndSupplierLocators.LOCATOR_INPUT_COMPETITOR)
                input_competitor.clear()
                input_competitor.send_keys('autotests')
                btn_save = self.find_element(ModalPleaseIndicateYourMainCompetitorAndSupplierLocators.LOCATOR_BTN_SAVE)
                btn_save.click()
                time.sleep(0.5)
                loader = self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER)
                while loader:
                    self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER)
                    time.sleep(1)
                    loader = self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER)

    def check_text_partial_shipment_is_not_allowed_at_current_discount_level_in_modal(self):
        """Проверка текста в модалке КП не прошло предварительную проверку
        Должен быть текст - Частичная отгрузка недопустима при текущем уровне скидок
        """
        with allure.step('Проверка текста в модалке КП не прошло предварительную проверку'):
            expected_text_in_modal = 'Частичная отгрузка недопустима при текущем уровне скидок'
            self.waiting_element_is_visibility_on_the_page(
                ModalNewKpLocators.LOCATOR_MESSAGE_INFO_IN_MODAL_KP_DID_NOT_PASS_PRELIMINARY_CHECK, sec=5)
            text_modal_on_page = self.find_element(
                ModalNewKpLocators.LOCATOR_MESSAGE_INFO_IN_MODAL_KP_DID_NOT_PASS_PRELIMINARY_CHECK).text

            assert text_modal_on_page == expected_text_in_modal, \
                f'Ожидаемый текст в модалке КП не прошло предварительную проверку - ({expected_text_in_modal}) ' \
                f'не соответствует тексту на странице КП - ({text_modal_on_page})'

    def check_input_partial_shipment_to_full_is_true(self):
        """Проверка, что тумблер Заменить частичную отгрузку на полную в этом КП включен"""
        with allure.step('Проверка, что тумблер Заменить частичную отгрузку на полную в этом КП включен'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_INPUT_PARTIAL_SHIPMENT_TO_FULL,
                                                           sec=5)
            input_partial_shipment_to_full = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_PARTIAL_SHIPMENT_TO_FULL
                                                               ).get_attribute('value')
            assert input_partial_shipment_to_full == 'on', \
                f'Тумблер Заменить частичную отгрузку на полную в этом КП не включен. ({input_partial_shipment_to_full})'

    def modal_kp_has_not_been_pre_screened(self):
        """Модалка КП не прошло предварительную проверку. Ввод комментария и отправка"""
        with allure.step('Модалка КП не прошло предварительную проверку. Ввод комментария и отправка'):
            h4_pre_check = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_H4_PRE_CHECK)
            if len(h4_pre_check) > 0:
                with allure.step('Ввод комментария'):
                    self.expecting_clickability(ModalNewKpLocators.LOCATOR_COMMENT_IN_MODAL_PRE_CHECK)
                    comment_field = self.find_element(ModalNewKpLocators.LOCATOR_COMMENT_IN_MODAL_PRE_CHECK)
                    comment_field.send_keys('selenium_web_ui')

                self.click_btn_send_in_modal_kp_has_not_been_pre_screened()

    def click_btn_send_in_modal_kp_has_not_been_pre_screened(self):
        """Клик по кнопке Отправить в модалке КП не прошло предварительную проверку"""
        with allure.step('Клик по кнопке Отправить в модалке КП не прошло предварительную проверку'):
            self.expecting_clickability(ModalNewKpLocators.LOCATOR_BUTTON_SEND)
            button_send = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_SEND)
            button_send.click()
            time.sleep(0.5)
        with allure.step('Ожидание отработки лоадера после отправки'):
            self.waiting_for_loader_processing_in_dom(BaseCrmLocators.LOCATOR_LOADER, sec=150)

    def click_on_the_button_create_kp_without_request(self):
        """Клик по кнопке Создать КП без запроса в модалке Запрос в группу планирования"""
        time.sleep(1)
        with allure.step('Клик по кнопке Создать КП без запроса в модалке Запрос в группу планирования'):
            modal_request = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_H4_REQUEST_TO_THE_PLANNING_GROUP)
            if len(modal_request) > 0:
                button_create = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_CREATE_PO_WITHOUT_REQUEST)
                button_create.click()
                time.sleep(1)
                self.waiting_element_invisibility(ModalNewKpLocators.LOCATOR_H4_REQUEST_TO_THE_PLANNING_GROUP)

    def switching_currency_to_a_fixed_rate(self):
        """Переключение валюты на фиксированный курс"""
        with allure.step('Переключение валюты на фиксированный курс'):
            toggle_switch_currency = self.find_element(ModalNewKpLocators.LOCATOR_TOGGLE_SWITCH_CURRENCY)
            self.click_js(toggle_switch_currency)
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.INPUT_CURRENCY_DATE)

    def switching_currency_to_a_internal_rate(self):
        """Переключение валюты на внутренний курс"""
        with allure.step('Переключение валюты на внутренний курс'):
            toggle_switch_currency = self.find_element(ModalNewKpLocators.LOCATOR_TOGGLE_SWITCH_CURRENCY)
            toggle_switch_currency.click()
            time.sleep(1)
            count_loader = len(self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER))
            while count_loader > 0:
                self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER, sec=150)
                time.sleep(1)
                count_loader = len(self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER))
            self.waiting_element_invisibility(ModalNewKpLocators.INPUT_CURRENCY_DATE)

    def select_course_date(self, date_curse_cb: str):
        """Выбор даты курса
        date_curse_cb - дата курса (день.месяц.год
                                    xx.xx.xxxx)
        """
        with allure.step('Выбор даты курса после переключения курса на дату'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.INPUT_CURRENCY_DATE)
            input_date_curse = self.find_element(ModalNewKpLocators.INPUT_CURRENCY_DATE)
            input_date_curse.send_keys(Keys.CONTROL + 'a' + 'BackSpace')
            input_date_curse.send_keys(date_curse_cb)
            field_curse = self.find_element(ModalNewKpLocators.LOCATOR_RATE_CENTRAL_BANK)
            field_curse.click()  # Клик по курсу, чтобы убрать окно с датой
            self.checking_entered_date_of_central_bank_exchange_rate(date_curse_cb)

    def checking_entered_date_of_central_bank_exchange_rate(self, expected_date: str):
        """Проверка введенной даты курса Центрального Банка
        expected_date - ожидаемая дата
        """
        with allure.step('Проверка введенной даты курса Центрального Банка'):
            input_date_curse = self.find_element(ModalNewKpLocators.INPUT_CURRENCY_DATE)
            entered_date_curse = input_date_curse.get_attribute('value')
            assert entered_date_curse == expected_date, \
                f'Выбранная дата курса ({entered_date_curse}) не соответствует ожидаемой - ({expected_date})'

    def switching_currency_to_ue(self):
        """Переключение валюты на УЕ"""
        with allure.step('Клик по кнопке переключения валюты на У.Е.'):
            button_switch_ue = self.find_element(ModalNewKpLocators.LOCATOR_SHIFT_BUTTON_ON_UE)
            self.click_js(button_switch_ue)
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_SELECTED_BUTTON_ON_UE)

    def saving_delivery_costs_msk(self) -> float:
        """Сохранение стоимости доставки в рублях склад Москва"""
        with allure.step('Сохранение стоимости доставки в рублях склад Москва'):
            transportation_cost_msk = self.find_element(ModalNewKpLocators.LOCATOR_DELIVERY_COST_MOSCOW).get_attribute(
                "value")
            return float(transportation_cost_msk)

    def saving_delivery_costs_dzr(self) -> float:
        """Сохранение стоимости доставки в рублях склад Дзержинск"""
        with allure.step('Сохранение стоимости доставки в рублях склад Дзержинск'):
            transportation_cost_dzr = self.find_element(ModalNewKpLocators.LOCATOR_DELIVERY_COST_DZR).get_attribute(
                "value")
            return float(transportation_cost_dzr)

    def save_price_one_joke_with_nds_to_category(self, category: str) -> float:
        """Сохранение цены с НДС дистра по категории"""
        with allure.step('Сохранение цены c НДС дистра по категории'):
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.locator_price_one_joke_with_nds_by_category(category))
            price_one_joke_without_nds = self.find_element(
                ModalNewKpLocators.locator_price_one_joke_with_nds_by_category(category)).text
            price_one_joke_without_nds = price_one_joke_without_nds.split(' ')[:-1]
            price_one_joke_without_nds = ''.join(price_one_joke_without_nds).replace(',', '.')
            return float(price_one_joke_without_nds)

    def save_the_selected_delivery_payment_mode(self) -> str:
        """Сохранение условий оплаты доставки"""
        with allure.step('Сохранение условий оплаты доставки'):
            selected_delivery_payment_mode = self.find_element(ModalNewKpLocators.SELECTED_PAYMENT_MODE).text
            return str(selected_delivery_payment_mode)

    def check_the_delivery_paid(self):
        """Проверка, что доставка за счет клиента"""
        with allure.step('Проверка, что условия доставки За счет клиента'):
            expected_delivery = 'Доставка за счет клиента'
            delivery_on_page = self.save_the_selected_delivery_payment_mode()
            assert expected_delivery == delivery_on_page, \
                f'Режим оплаты доставки на странице - ({delivery_on_page}) ' \
                f'не соответствует ожидаемому - ({expected_delivery})'

    def check_that_payment_mode_field_is_not_editable(self):
        """Проверка, что поле Режим оплаты не редактируется"""
        with allure.step('Проверка, что поле Режим оплаты не редактируется'):
            expected_contains_class = 'disabled'
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BLOCK_DIV_PAYMENT_MODE, sec=5)
            style_block_payment_mode = self.find_element(ModalNewKpLocators.LOCATOR_BLOCK_DIV_PAYMENT_MODE
                                                         ).get_attribute('class')
            assert expected_contains_class in style_block_payment_mode, \
                f'Поле ежим оплаты редактируемо. Значение класса блока - {style_block_payment_mode}'

    # """Для ПРОДА!!!"""
    def choice_distributor_prod(self, num_distributor: str):
        """Выбор Дистрибьютора ПРОД"""
        with allure.step('Выбор дистрибьютора на ПРОДе'):
            with allure.step('Клик по полю Дистрибьютор'):
                button_drop = self.find_element(ModalNewKpLocators.LOCATOR_DROP_UL_DISTRIBUTOR)
                button_drop.click()
                self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_INPUT_DISTRIBUTOR)
                input_distributor = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_DISTRIBUTOR)
                with allure.step('Ввод дистрибьютора'):
                    input_distributor.send_keys(num_distributor)
                    time.sleep(1)
                    with allure.step('Выбор дистрибьютора из выпадающего списка'):
                        self.waiting_element_is_visibility_on_the_page(
                            ModalNewKpLocators.LOCATOR_INPUT_FIXED_DISTRIBUTOR_PROD, sec=90)
                        fixed_distributor = self.find_element(ModalNewKpLocators.LOCATOR_INPUT_FIXED_DISTRIBUTOR_PROD)
                        fixed_distributor.click()

    def choice_sap_code_main_contract_prod(self):
        """Выбор Сап кода ПРОД"""
        with allure.step('Выбор номера договора ПРОД'):
            time.sleep(5)
            count_sap_main_contract = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_SAP_MAIN_CONTRACT_PROD)
            if len(count_sap_main_contract) == 0:
                drop_ul_sap_code = self.find_element(ModalNewKpLocators.LOCATOR_DROP_UL_SAP_CODE)
                drop_ul_sap_code.click()
                self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_SAP_MAIN_CONTRACT_PROD)
            sap_main_contract = self.find_element(ModalNewKpLocators.LOCATOR_SAP_MAIN_CONTRACT_PROD)
            sap_main_contract.click()
            self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER)
            selected_sap_code = self.find_element(
                ModalNewKpLocators.LOCATOR_SELECTED_SAP_CODE).text  # выбранный сап код
            selected_sap_code = selected_sap_code.split(' ')[0]
            assert selected_sap_code == ProdEnvironment.DISTRIBUTOR_OPEN_PROD, \
                f'Выбранный sap code {selected_sap_code} не равен искомому {ProdEnvironment.DISTRIBUTOR_OPEN_PROD}'

    def choice_final_buyer_prod(self):
        """Выбор Конечного покупателя ПРОД"""
        with allure.step('Выбор Конечного покупателя ПРОД'):
            drop_ul_final_buyer = self.find_element(ModalNewKpLocators.LOCATOR_DROP_UL_FINAL_BUYER)
            drop_ul_final_buyer.click()
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_FINAL_BUYER_PROD)
            final_buyer = self.find_element(ModalNewKpLocators.LOCATOR_FINAL_BUYER_PROD)
            final_buyer.click()
            time.sleep(1)
            selected_end_customer = self.find_element(
                ModalNewKpLocators.LOCATOR_SELECTED_END_CUSTOMER)  # Выбранный конечный покупатель
            selected_end_customer = selected_end_customer.text
            assert selected_end_customer == ProdEnvironment.FINAL_BUYER_PROD, \
                f'Номер выбранного конечного покупателя {selected_end_customer} не равен искомому номеру ' \
                f'{ProdEnvironment.FINAL_BUYER_PROD}'

    def there_should_be_a_special_price_icon_at_article(self, article: str):
        """Должна быть иконка спец. цены у артикула"""
        with allure.step('Проверка, что есть иконка спец. цена'):
            self.waiting_element_is_visibility_on_the_page(
                ModalNewKpLocators.locator_special_price_icon_by_article(article))

    def click_btn_switch_special_price_retail_at_article(self, article: str):
        """Клик по кнопке Переключатель Спец.цена/Розница у артикула"""
        with allure.step('Клик по кнопке Переключатель Спец. цена/Розница у артикула'):
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.locator_btn_switch_special_price_retail(article), sec=5)
            special_price = self.driver.find_elements(
                *ModalNewKpLocators.locator_special_price_icon_by_article(article))  # Спец цена
            retail = self.driver.find_elements(*ModalNewKpLocators.locator_retail_icon_by_article(article))  # Розница
            self.expecting_clickability(ModalNewKpLocators.locator_btn_switch_special_price_retail(article))
            btn_switch = self.find_element(ModalNewKpLocators.locator_btn_switch_special_price_retail(article))
            self.click_js(btn_switch)
            if len(special_price) == 1:
                self.waiting_element_is_visibility_on_the_page(
                    ModalNewKpLocators.locator_btn_switch_special_price_retail(article), sec=5)
            elif len(retail) == 1:
                self.waiting_element_is_visibility_on_the_page(
                    ModalNewKpLocators.locator_special_price_icon_by_article(article))

    def save_list_articles_in_pq(self) -> list:
        """Сохранение списка артикулов в КП"""
        with allure.step('Сохранение списка артикулов в КП'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_LIST_CODE_IN_KP, sec=5)

            name_codes_link_in_cart = self.find_elements(ModalNewKpLocators.LOCATOR_LIST_CODE_IN_KP)
            name_codes_link_in_cart = [codes.text for codes in name_codes_link_in_cart]

            return name_codes_link_in_cart

    def delete_position_by_article(self, article: str):
        """Удаление кода из КП
        article - артикул кода, который надо удалить"""
        with allure.step('Клик по крестику для удаления кода из КП'):
            time.sleep(3)
            self.expecting_clickability(ModalNewKpLocators.locator_delete_position_by_article(article))
            button_delete_position = self.find_element(ModalNewKpLocators.locator_delete_position_by_article(article))
            self.click_js(button_delete_position)
            self.waiting_element_invisibility(ModalNewKpLocators.locator_delete_position_by_article(article), sec=5)

    def close_modal_new_kp(self):
        """Закрытие модалки создания КП"""
        with allure.step('Клик по кнопке в виде крестика закрытия КП'):
            self.expecting_clickability(ModalNewKpLocators.LOCATOR_BTN_CLOSE_KP, sec=5)
            btn_close_modal_new_kp = self.find_element(ModalNewKpLocators.LOCATOR_BTN_CLOSE_KP)
            btn_close_modal_new_kp.click()
            self.waiting_element_invisibility(ModalNewKpLocators.LOCATOR_MODAL_NEW_KP, sec=5)

    def check_that_block_files_and_comments_is_opened(self):
        """Проверка, что блок Файлы и комментарии раскрыт"""
        with allure.step('Проверка, что блок Файлы и комментарии раскрыт'):
            try:
                self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_DIV_BLOCK_COMMENTS_AND_FILES,
                                                               sec=5)
            except TimeoutException as e:
                raise TimeoutException(f'Блок Файлы и Комментарии не отображается на странице. {e}')

    def check_field_comments_is_invisible(self):
        """Проверка, что блок с полем ввода комментария скрыт"""
        with allure.step('Проверка, что блок с полем ввода комментария скрыт'):
            expected_style = 'display: none;'
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BLOCK_DIV_INPUT_COMMENT_IN_KP,
                                                           sec=5)
            style_block_div_input_comment_in_kp = self.find_element(
                ModalNewKpLocators.LOCATOR_BLOCK_DIV_INPUT_COMMENT_IN_KP).get_attribute('style')
            assert style_block_div_input_comment_in_kp == expected_style, \
                f'Поле ввода комментария не скрыто. Стиль блока div с полем ввода комментария - ' \
                f'({style_block_div_input_comment_in_kp})'

    def check_that_show_discount_column_switch_is_on(self):
        """Проверка, что включен тумблер Показывать колонку со скидкой"""
        with allure.step('Проверка, что включен тумблер  Показывать колонку со скидкой'):
            self.waiting_element_is_visibility_on_the_page(
                ModalNewKpLocators.LOCATOR_BLOCK_DIV_TUMBLE_SWITCH_SHOW_DISCOUNT_COLUMN, sec=5)
            tumble_switch_show_discount_column = self.find_element(
                ModalNewKpLocators.LOCATOR_TUMBLE_SWITCH_SHOW_DISCOUNT_COLUMN).get_attribute('value')
            assert tumble_switch_show_discount_column == 'on', \
                f'Тумблер Показывать колонку со скидкой не включен. Значение - {tumble_switch_show_discount_column}'

    def check_that_show_discount_column_switch_is_blocked(self):
        """Проверка, что тумблер Показывать колонку со скидкой заблочен"""
        with allure.step('Проверка, что тумблер Показывать колонку со скидкой заблочен'):
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.LOCATOR_TUMBLE_SWITCH_SHOW_DISCOUNT_COLUMN, sec=5)
            tumble_switch_show_discount_column = self.find_element(
                ModalNewKpLocators.LOCATOR_TUMBLE_SWITCH_SHOW_DISCOUNT_COLUMN)
            tumble_switch_show_discount_column_is_blocked = self.driver.execute_script(
                "return arguments[0].disabled || arguments[0].readOnly", tumble_switch_show_discount_column)
            assert tumble_switch_show_discount_column_is_blocked is True, \
                f'тумблер Показывать колонку со скидкой редактируем. Значение - {tumble_switch_show_discount_column}'

    def checking_title_in_file_upload_section(self):
        """Проверка заголовка в разделе загрузки файлов"""
        with allure.step('Проверка заголовка в разделе загрузки файлов'):
            expected_header = 'Файлы, отображаемые в личном кабинете клиента на сайте ridan.ru'
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_HEADER_IN_FILE_UPLOAD_SECTION,
                                                           sec=5)
            header_on_page = self.find_element(ModalNewKpLocators.LOCATOR_HEADER_IN_FILE_UPLOAD_SECTION).text
            assert expected_header == header_on_page, \
                f'Заголовок в разделе загрузки файлов на странице - ({header_on_page}) не соответствует ожидаемому - ' \
                f'({expected_header})'

    def checking_number_of_downloaded_files(self, expected_quantity_downloaded_files=0):
        """Проверка количества загруженных файлов"""
        with allure.step('Проверка количества загруженных файлов'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_FILE_UPLOAD_INPUT, sec=5)
            quantity_downloaded_files = self.driver.execute_script(
                "return document.querySelector(arguments[0])",
                ModalNewKpLocators.LOCATOR_CSS_SELECTOR_FILE_UPLOAD_INPUT)
            quantity_downloaded_files = self.driver.execute_script("return arguments[0].files.length",
                                                                   quantity_downloaded_files)

            assert quantity_downloaded_files == expected_quantity_downloaded_files, \
                f'Количество загруженных файлов - ({quantity_downloaded_files}) не соответствует ожидаемому - ' \
                f'({expected_quantity_downloaded_files})'

    def checking_that_in_file_uploads_there_is_only_one_add_button(self):
        """Проверка, что в разделе загрузки файлов только одна кнопка Добавить"""
        with allure.step('Проверка, что в разделе загрузки файлов только одна кнопка Добавить'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BTN_ADD_IN_IN_FILE_UPLOAD_SECTION,
                                                           sec=5)
            btn_add = self.find_elements(ModalNewKpLocators.LOCATOR_BTN_ADD_IN_IN_FILE_UPLOAD_SECTION)
            assert len(btn_add) == 1, f'В модалке создания КП кнопок Добавить в разделе загрузки файлов больше 1. ' \
                                      f'Количество- ({len(btn_add)})'

    def switching_on_tumbler_show_discount_column_if_off(self):
        """Включение тумблера Показывать колонку со скидкой, если он выключен"""
        with allure.step('Включение тумблера Показывать колонку со скидкой, если он выключен'):
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.LOCATOR_INPUT_TUMBLER_SHOW_DISCOUNT_COLUMN,
                sec=5)
            is_tumbler_show_discount_column = self.find_element(
                ModalNewKpLocators.LOCATOR_INPUT_TUMBLER_SHOW_DISCOUNT_COLUMN).is_selected()
            if is_tumbler_show_discount_column is False:
                btn_tumbler_show_discount_column = self.find_element(
                    ModalNewKpLocators.LOCATOR_BTN_TUMBLER_SHOW_DISCOUNT_COLUMN)
                self.scroll_to(btn_tumbler_show_discount_column)
                self.expecting_clickability(ModalNewKpLocators.LOCATOR_BTN_TUMBLER_SHOW_DISCOUNT_COLUMN)
                btn_tumbler_show_discount_column.click()

            is_tumbler_show_discount_column = self.find_element(
                ModalNewKpLocators.LOCATOR_INPUT_TUMBLER_SHOW_DISCOUNT_COLUMN).is_selected()
            assert is_tumbler_show_discount_column is True, \
                f'Тумблер Показывать колонку со скидкой не включен. ({is_tumbler_show_discount_column})'

    def go_to_chapter_discount(self):
        """Переход в раздел Скидки"""
        with allure.step('Переход в раздел Скидки'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BTN_CHAPTER_DISCOUNT, sec=5)
            btn_chapter_discount = self.find_element(ModalNewKpLocators.LOCATOR_BTN_CHAPTER_DISCOUNT)
            self.scroll_to_elem_perform(btn_chapter_discount)
            self.expecting_clickability(ModalNewKpLocators.LOCATOR_BTN_CHAPTER_DISCOUNT)
            btn_chapter_discount.click()
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BTN_CHAPTER_DISCOUNT_ACTIVE,
                                                           sec=5)

    def input_discount_distr_by_gcm_in_tab_discounts(self, num_gcm: str, value_discounts: str):
        """Ввод скидки дистра по ГЦМ в разделе Скидки"""
        with allure.step('Ввод скидки дистра по ГЦМ в разделе Скидки'):
            self.waiting_element_is_visibility_located_dom(
                ModalNewKpLocators.locator_discount_distr_by_gcm_in_tab_discounts(num_gcm), sec=10)
            input_discount_distr_by_gcm = self.find_element(
                ModalNewKpLocators.locator_discount_distr_by_gcm_in_tab_discounts(num_gcm))
            self.scroll_to_elem_perform(input_discount_distr_by_gcm)

            action = ActionChains(self.driver)
            action.click(input_discount_distr_by_gcm).send_keys(value_discounts).perform()
            selected_discount = input_discount_distr_by_gcm.get_attribute('value')
            assert selected_discount == value_discounts, \
                f'Скидки дистра - ({selected_discount}) по ГЦМ {num_gcm} на странице не равны вводимым - ({value_discounts})'

    def input_discount_distr_by_gcm_except_for_exceptions(self, gcm_for_exclusion: list, value_discount: str):
        """Ввод скидок дистра по ГЦМ в разделе Скидки кроме исключений"""
        with allure.step('Ввод скидок дистра по ГЦМ в разделе Скидки кроме исключений'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_CATEGORY_GCM_IN_TAB_DISCOUNT,
                                                           sec=5)
            all_category_gcm = self.find_elements(ModalNewKpLocators.LOCATOR_CATEGORY_GCM_IN_TAB_DISCOUNT)
            all_category_gcm = [el.text.strip() for el in all_category_gcm]

            for category in all_category_gcm:
                if category in gcm_for_exclusion:
                    continue
                elif category not in gcm_for_exclusion:
                    self.input_discount_distr_by_gcm_in_tab_discounts(category, value_discount)

    def checking_delivery_time(self, article: str, expected_delivery_time: str):
        """Проверка срока поставки у кода"""
        with allure.step('Проверка срока поставки у кода'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.locator_delivery_time_by_article(article),
                                                           sec=5)
            delivery_time_on_page = self.find_element(ModalNewKpLocators.locator_delivery_time_by_article(article)).text
            delivery_time_on_page = delivery_time_on_page.split(' ')[0]
            assert expected_delivery_time == delivery_time_on_page, \
                f'Срок поставки - ({delivery_time_on_page}) у кода {article} в модалке создания КП не соответствует ' \
                f'ожидаемому - ({expected_delivery_time})'

    def check_that_pop_up_error_is_one(self):
        """Проверка, что всплывающая ошибка одна"""
        with allure.step('Проверка, что всплывающая ошибка одна'):
            try:
                self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_ERROR_MESSAGES, sec=5)
                len_pop_up_error = len(self.driver.find_elements(*ModalNewKpLocators.LOCATOR_ERROR_MESSAGES))
                assert len_pop_up_error == 1, f'Всплывающих ошибок больше одной. len - {len_pop_up_error}'
            except TimeoutException:
                raise MyTimeoutException('Всплывающая ошибка не появилась')

    def check_message_in_popup_error(self, expected_msg: str):
        """Проверка сообщения во всплывающей ошибке"""
        self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_TEXT_IN_ERROR_MESSAGES_POP_UP, sec=5)
        text_message_in_popup_error = self.find_element(
            ModalNewKpLocators.LOCATOR_TEXT_IN_ERROR_MESSAGES_POP_UP).text.strip()
        assert expected_msg == text_message_in_popup_error, \
            (f'Текст сообщения во всплывающей ошибке - ({text_message_in_popup_error}) '
             f'не соответствует ожидаемому- ({expected_msg})')


@allure.feature('Модалка добавление ЗИП')
class ModalAddedZip(BasePage):
    """Модалка добавление ЗИП"""

    def entering_calculation_number(self, calculation_number: str):
        """Ввод номера расчета
        calculation_number - номер расчет
        """
        with allure.step('Ввод номера расчета в модалке ЗИП'):
            self.waiting_element_is_visibility_on_the_page(
                ModalAddedZipLocators.LOCATOR_INPUT_CALCULATION_NUMBER_ENTRY_FIELD)
            input_entering_num_calc = self.find_element(
                ModalAddedZipLocators.LOCATOR_INPUT_CALCULATION_NUMBER_ENTRY_FIELD)
            input_entering_num_calc.send_keys(calculation_number)
            entered_calculation_number = input_entering_num_calc.get_attribute('value')
            assert entered_calculation_number == calculation_number, \
                f'Введенный номер расчета - ({entered_calculation_number}) не соответствует ожидаемому - ' \
                f'({calculation_number})'

    def click_button_added_zip(self):
        """Клик по кнопке Добавить ЗИП"""
        with allure.step('Клик по кнопке Добавить ЗИП'):
            self.expecting_clickability(ModalAddedZipLocators.LOCATOR_BUTTON_ADDED_ZIP)
            btn_added_zip = self.find_element(ModalAddedZipLocators.LOCATOR_BUTTON_ADDED_ZIP)
            btn_added_zip.click()
            time.sleep(0.2)
            self.waiting_element_invisibility(ModalAddedZipLocators.LOCATOR_H4_HEADER)
            code_entry_field = self.find_element(ModalNewKpLocators.LOCATOR_CODE_ENTRY_FIELD).get_attribute('value')
            assert code_entry_field != '', f'После ввода кодов ЗИП поле пустое - ({code_entry_field})'


@allure.feature('Модалка создания нового КП РОЛ')
class ModalNewKpRol(ModalNewKp):
    """Модалка создания нового КП РОЛ"""

    def check_header_in_modal(self):
        """Проверка заголовка в модалке создания нового КП РОЛ"""
        with allure.step('Проверка заголовка в модалке создания нового КП РОЛ'):
            expected_header = 'Новое КП   РОЛ  '
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_HEADER_DIV)
            header_in_modal_on_page = self.find_element(ModalNewKpLocators.LOCATOR_HEADER_DIV).text
            assert expected_header == header_in_modal_on_page, \
                f'Заголовок в модалке создания нового КП РОЛ на странице - ({header_in_modal_on_page}) не соответствует ' \
                f'ожидаемому - ({expected_header})'

    def check_date_in_deal_section(self):
        """Проверка корректности названия сделки.
        Ожидаем, что название состоит из - РОЛ заказ + дата в формате мм.гг во время создания КП"""
        with allure.step('Проверка корректности названия сделки. Ожидаем, '
                         'что название состоит из - РОЛ заказ + дата в формате мм.гг во время создания КП'):
            current_date = datetime.now()
            expected_name_deal = f'РОЛ заказ {current_date.month}.{current_date.year}'

            self.waiting_element_is_visibility_on_the_page(ModalNewKpRolLocators.LOCATOR_LINK_DEAL, sec=5)
            name_deal_in_modal = self.find_element(ModalNewKpRolLocators.LOCATOR_LINK_DEAL).text
            assert name_deal_in_modal == expected_name_deal, \
                f'Название сделки в модалке создания КП РОЛ - ({name_deal_in_modal}) не соответствует ожидаемому ' \
                f'названию - ({expected_name_deal})'

    def check_in_filling_kp_selected_components_and_to(self):
        """Проверка, что в разделе Наполнение КП выбрано Комп+ТО"""
        with allure.step('Проверка, что в разделе Наполнение КП выбрано Комп+ТО'):
            expected_contains_class = 'active'  # Ожидаемая часть класса
            self.waiting_element_is_visibility_on_the_page(
                ModalNewKpLocators.LOCATOR_BTN_COMP_PLUS_TO_IN_SECTION_FILLING_KP, sec=5)
            btn_components_and_to = self.find_element(ModalNewKpLocators.LOCATOR_BTN_COMP_PLUS_TO_IN_SECTION_FILLING_KP)
            is_selected_btn_components_and_to = btn_components_and_to.get_attribute("class")
            assert expected_contains_class in is_selected_btn_components_and_to, \
                f'Кнопка Комп+ТО не выбрана в разделе Наполнение КП'

    def checking_that_btp_is_not_displayed_in_filling_of_kp(self):
        """Проверка, что в разделе Наполнение КП БТП не отображается"""
        with allure.step('Проверка, что в разделе Наполнение КП БТП не отображается'):
            expected_style_btp_block = 'display: none;'  # Ожидаемый стиль в блоке БТП для выбора наполнения кп
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.LOCATOR_BTN_BTP_IN_SECTION_FILLING_KP,
                                                           sec=5)
            btn_btp = self.find_element(ModalNewKpLocators.LOCATOR_BTN_BTP_IN_SECTION_FILLING_KP).get_attribute('style')
            assert btn_btp == expected_style_btp_block, \
                f'Кнопка БТП в разделе Наполнение КП видна на странице. ({btn_btp})'
