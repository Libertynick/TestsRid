import sys
import time
import re

from selenium.common import StaleElementReferenceException

from base_page.base_page import BasePageCrm
from base_page.base_page_locators import BaseCrmLocators
from base_page.raise_exceptions import MyTimeoutException
from crm_pages.modal_logistics_ridan.modal_logistics_ridan_locators import ModalLogisticsRidanLocators
from crm_pages.modal_new_kp.modal_new_kp import ModalNewKp
from crm_pages.modal_new_kp.modal_new_kp_locators import ModalNewKpLocators
from crm_pages.pq_page.pq_page_locators import PqPageLocators
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.keys import Keys
import allure


@allure.feature('Страница PQ')
class PqPage(BasePageCrm, ModalNewKp):
    """Страница PQ"""

    def agreement_on_all_conditions(self):
        """Согласование всех условий"""
        with allure.step('Согласование всех условий'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_CONSOLIDATION_CHECKBOX, sec=30)
            count_consolidation_checkbox = self.driver.find_elements(
                *PqPageLocators.LOCATOR_CONSOLIDATION_CHECKBOX)  # количество согласований
            while len(count_consolidation_checkbox) != 0:
                count_warning = self.driver.find_elements(*PqPageLocators.LOCATOR_ORANGE_AGREEMENT_FLAGS
                                                          )  # Согласователи с оранжевой меткой
                if len(count_warning) != 0:
                    conciliator_list = self.agreement_with_orange_mark()

                else:
                    conciliator_list = self.agreement_with_blue_mark()

                self.click_user_change(conciliator_list)
                self.reconciliation_of_outdated_costs()

                with allure.step('Клик по галочке согласование напротив согласователя'):
                    self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_AGREEMENT_TRUE, sec=15)
                    agreement_true = self.find_element(PqPageLocators.LOCATOR_AGREEMENT_TRUE)
                    self.scroll_to(agreement_true)
                    self.expecting_clickability(PqPageLocators.LOCATOR_AGREEMENT_TRUE, sec=10)

                    agreement_true = self.find_element(PqPageLocators.LOCATOR_AGREEMENT_TRUE)
                    agreement_true.click()
                    self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_H4_AGREEMENT, sec=90)

                self.agreement_kp_for_client()
                self.entering_a_comment_for_approval()
                self.click_on_the_agree_button()
                self.change_for_yourself()

                count_consolidation_checkbox = self.driver.find_elements(
                    *PqPageLocators.LOCATOR_CONSOLIDATION_CHECKBOX)  # количество согласований

    def agreement_with_orange_mark(self) -> list:
        """Согласование с оранжевой меткой"""
        with allure.step('Сохранение согласователей с оранжевой меткой (флаг у согласователя)'):
            count_warning = self.driver.find_elements(*PqPageLocators.LOCATOR_ORANGE_AGREEMENT_FLAGS
                                                      )  # Согласователи с оранжевой меткой
            if len(count_warning) != 0:
                conciliators = self.find_elements(PqPageLocators.LOCATOR_SURNAME_OF_THE_CONTRACTOR_ORANGE_FLAG)
                conciliator_list_no_parse = [conciliator_name.text for conciliator_name in
                                             conciliators]  # нераспарсенный список
                conciliator_list_parse = [conciliator_name.split('\n') for conciliator_name in conciliator_list_no_parse
                                          ]  # распарсенный список с вложенными списками по каждому согласованию отдельно
                conciliator_list = sum(conciliator_list_parse, [])

                return conciliator_list

    def agreement_with_blue_mark(self) -> list:
        """Согласование с голубой меткой"""
        with allure.step('Сохранение согласователей с голубой меткой (флаг у согласователя)'):
            count_blue = self.driver.find_elements(*PqPageLocators.LOCATOR_BLUE_AGREEMENT_FLAGS
                                                   )  # Согласование с голубой меткой
            if len(count_blue) != 0:
                conciliators = self.find_elements(
                    PqPageLocators.LOCATOR_SURNAME_OF_THE_CONTRACTOR_BLUE_FLAG)
                conciliator_list_no_parse = [conciliator_name.text for conciliator_name in
                                             conciliators]  # нераспарсенный список
                conciliator_list_parse = [conciliator_name.split('\n') for conciliator_name in conciliator_list_no_parse
                                          ]  # распарсенный список с вложенными списками по каждому согласованию отдельно
                conciliator_list = sum(conciliator_list_parse, [])
                return conciliator_list

    def save_coordinators_by_type_agreement(self, type_agreement) -> list:
        """
        Сохранение согласователей по типу согласования
        :return: Список согласователей
        :param type_agreement: Тип согласования
        """
        with allure.step(f'Сохранение согласователей по типу согласования {type_agreement}'):
            self.waiting_element_is_visibility_located_dom(
                PqPageLocators.locator_coordinators_by_type_agreement(type_agreement), sec=5)
            coordinators = self.find_elements(PqPageLocators.locator_coordinators_by_type_agreement(type_agreement))
            coordinators = [el.text for el in coordinators]
            coordinators = coordinators[0].strip().split('\n')
            return coordinators

    def agree_by_type_of_agreement(self, type_agreement: str):
        """Согласовать по типу согласования"""
        with allure.step('Согласовать по типу согласования'):
            self.waiting_element_is_visibility_located_dom(
                PqPageLocators.locator_btn_agreement_true_by_type_agreement(type_agreement), sec=15)
            btn_agreement = self.find_element(
                PqPageLocators.locator_btn_agreement_true_by_type_agreement(type_agreement))
            self.scroll_to(btn_agreement)
            self.expecting_clickability(PqPageLocators.locator_btn_agreement_true_by_type_agreement(type_agreement),
                                        sec=5)
            btn_agreement.click()
            self.entering_a_comment_for_approval()
            self.click_on_the_agree_button()

    def click_btn_approve_logistics_ridan(self):
        """Клик по кнопке согласования логистикой Ридан"""
        with allure.step('Клик по кнопке согласования логистикой Ридан'):
            self.expecting_clickability(PqPageLocators.LOCATOR_BTN_APPROVE_LOGISTICS, sec=5)
            btn_approve_logistic = self.find_element(PqPageLocators.LOCATOR_BTN_APPROVE_LOGISTICS)
            btn_approve_logistic.click()
            self.waiting_element_is_visibility_on_the_page(ModalLogisticsRidanLocators.LOCATOR_HEADER, sec=5)

    def save_contractors_hex(self) -> list:
        """Сохранение согласователей HEX"""
        with allure.step('Сохранение согласователей HEX'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_SURNAME_CONTRACTORS_HEX, sec=10)
            contractors_hex = self.find_elements(PqPageLocators.LOCATOR_SURNAME_CONTRACTORS_HEX)
            contractors_hex = [contractor.text for contractor in contractors_hex]
            return contractors_hex

    def agreement_kp_for_client(self):
        """Согласование 'КП от клиента'"""
        with allure.step('Согласование "КП от клиента"'):
            approval_of_cp_from_client = self.driver.find_elements(
                *PqPageLocators.LOCATOR_CP_APPROVAL_HEADER_FROM_CLIENT)
            if len(approval_of_cp_from_client) > 0:
                approval_toggle_not_kp_for_client_switches_list = self.driver.find_elements(
                    *PqPageLocators.LOCATOR_ALL_APPROVALS_EXCEPT_KP_FROM_CLIENT
                )  # Все тумблеры согласований кроме Кп от клиента
                if len(approval_toggle_not_kp_for_client_switches_list) > 0:
                    for approval in approval_toggle_not_kp_for_client_switches_list:
                        self.expecting_clickability(PqPageLocators.LOCATOR_ALL_APPROVALS_EXCEPT_KP_FROM_CLIENT)
                        approval.click()

    def reconciliation_of_outdated_costs(self):
        """Клик по кнопке Обновить информацию о себестоимости"""
        with allure.step('Согласование устаревшей себестоимости'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_HEADER_KP, sec=30)
            outdated_cost = self.driver.find_elements(*PqPageLocators.LOCATOR_COST_APPROVAL_BUTTON)
            if len(outdated_cost) > 0:
                outdated_cost[0].click()
                with allure.step('Ожидание отработки лоадера'):
                    self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER_PQ)

            elif len(outdated_cost) < 0:
                print('КП не нуждается в согласовании устаревшей себестоимости')

    def check_info_message_in_block_cost_price_approval(self, article_for_approval_cost_price: str):
        """Проверка информационного сообщения в блоке согласования себестоимости
        article_for_approval_cost_price - артикул, у которого требуется согласование себестоимости
        """
        with allure.step('Проверка информационного сообщения в блоке согласования себестоимости'):
            expected_info_message = f'Внимание!\n\nОтсутствует себестоимость: {article_for_approval_cost_price}'
            self.waiting_element_is_visibility_located_dom(
                PqPageLocators.LOCATOR_INFO_MESSAGE_IN_COST_PRICE_APPROVAL_BLOCK, sec=15)
            text_on_page = self.find_element(PqPageLocators.LOCATOR_INFO_MESSAGE_IN_COST_PRICE_APPROVAL_BLOCK).text
            print(text_on_page)
            assert expected_info_message == text_on_page, \
                f'Информационное сообщение в блоке согласования себестоимости артикула {article_for_approval_cost_price} ' \
                f'на странице - ({text_on_page}) не соответствует ожидаемому - ({expected_info_message})'

    def store_total_cost_price(self) -> float:
        """Сохранение общей себестоимости в кп"""
        with allure.step('Сохранение общей себестоимости в кп'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_PRICE_COST_TOTAL, sec=5)
            total_cost_price = float(self.find_element(PqPageLocators.LOCATOR_PRICE_COST_TOTAL
                                                       ).text.replace(',', '.').replace('₽', '').replace(' ', ''))
            return total_cost_price

    def entering_a_comment_for_approval(self):
        """Ввод комментария на согласовании КП"""
        with allure.step('Ввод комментария на согласовании КП'):
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_FIELD_COMMENT)
            comment = 'selenium_web_test_ui'
            comment_field = self.find_element(PqPageLocators.LOCATOR_FIELD_COMMENT)
            comment_field.send_keys(comment)

    def click_on_the_agree_button(self):
        """Клик по кнопке Согласовать в модалке Согласования"""
        with allure.step('Клик по кнопке Согласовать в модалке Согласования'):
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_APPROVE_BUTTON_IN_THE_APPROVAL_MODAL)
            self.expecting_clickability(PqPageLocators.LOCATOR_APPROVE_BUTTON_IN_THE_APPROVAL_MODAL)
            button_agree = self.find_element(PqPageLocators.LOCATOR_APPROVE_BUTTON_IN_THE_APPROVAL_MODAL)
            button_agree.click()
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_in_dom(BaseCrmLocators.LOCATOR_LOADER, sec=30)
                self.waiting_element_invisibility(PqPageLocators.LOCATOR_APPROVE_BUTTON_IN_THE_APPROVAL_MODAL, sec=5)
                self.waiting_for_loader_processing_in_dom(BaseCrmLocators.LOCATOR_LOADER, sec=30)
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_HEADER_KP)
                time.sleep(2)

    def click_btn_reject_in_the_approval_modal(self):
        """Клик по кнопке Отклонить в модалке согласования"""
        with allure.step('Клик по кнопке Отклонить в модалке согласования'):
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_BUTTON_REJECT_IN_THE_APPROVAL_MODAL,
                                                           sec=5)
            btn_reject = self.find_element(PqPageLocators.LOCATOR_BUTTON_REJECT_IN_THE_APPROVAL_MODAL)
            btn_reject.click()
            time.sleep(1)
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER_MODAL, sec=90)
                self.waiting_for_loader_processing_in_dom(BaseCrmLocators.LOCATOR_LOADER, sec=90)
                self.waiting_element_invisibility(PqPageLocators.LOCATOR_BUTTON_REJECT_IN_THE_APPROVAL_MODAL, sec=5)
                self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_HEADER_KP, sec=10)

    def click_btn_consent_failure(self):
        """Клик по кнопке Отказать в согласовании"""
        with allure.step('Клик по кнопке Отказать в согласовании'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_BTN_CONSENT_FAILURE, sec=30)
            btn_consent_failure = self.find_element(PqPageLocators.LOCATOR_BTN_CONSENT_FAILURE)
            self.scroll_to(btn_consent_failure)
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_BTN_CONSENT_FAILURE)
            btn_consent_failure.click()
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_H4_AGREEMENT, sec=10)

    def click_btn_consent_failure_hex(self):
        """Клик по кнопке отказать в согласовании HEX"""
        with allure.step('Клик по кнопке отказать в согласовании HEX'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_BTN_CONSENT_FAILURE_HEX, sec=10)
            btn_consent_failure_hex = self.find_element(PqPageLocators.LOCATOR_BTN_CONSENT_FAILURE_HEX)
            self.scroll_to(btn_consent_failure_hex)
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_BTN_CONSENT_FAILURE)
            btn_consent_failure_hex.click()
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_H4_AGREEMENT, sec=10)
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_HEADER_AGREEMENT_HEX)

    def checking_the_selected_mode_of_payment_for_delivery(self, correct_mode_of_payment_for_delivery: str):
        """Проверка выбранного режима доставки
        correct_mode_of_payment_for_delivery - корректный режим оплаты доставки
        """
        with allure.step(f'Проверка, что выбран режим доставки - ({correct_mode_of_payment_for_delivery})'):
            delivery_payment_mode = self.find_element(PqPageLocators.LOCATOR_DELIVERY_PAYMENT_MODE).text
            assert correct_mode_of_payment_for_delivery == delivery_payment_mode, \
                f'Режим оплаты в PQ ({delivery_payment_mode}) не равен корректному режиму оплаты ' \
                f'({correct_mode_of_payment_for_delivery})'

    def choose_client_kp(self):
        """Отключение согласования Скидки и Скидки ДД в согласовании КП от клиента"""
        with allure.step('Отключение согласования Скидки и Скидки ДД в согласовании КП от клиента'):
            off_discount = self.find_element(PqPageLocators.LOCATOR_OFF_DISCOUNTS)
            self.driver.execute_script("arguments[0].click()", off_discount)
            off_discount_dd = self.find_element(PqPageLocators.LOCATOR_OFF_DISCOUNTS_DD)
            self.driver.execute_script("arguments[0].click()", off_discount_dd)

    def save_pq_on_pq_page(self):
        """Сохранение PQ"""
        with allure.step('Клик по кнопке Сохранить'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BUTTON_SAVE)
            button_save = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_SAVE)
            button_save.click()
            time.sleep(1)
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_LOADER_SAVE_PQ, sec=120)
                self.waiting_for_loader_processing_on_page(PqPageLocators.LOCATOR_LOADER_SAVE_PQ, sec=120)

    def click_button_recalculate_pq_page(self):
        """Клик по кнопке Пересчитать"""
        with allure.step('Клик по кнопке Пересчитать'):
            self.expecting_clickability(ModalNewKpLocators.LOCATOR_BUTTON_RECALCULATE)
            button_recalculate = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_RECALCULATE)
            button_recalculate.click()
            time.sleep(1)
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(PqPageLocators.LOCATOR_LOADER)

    def send_for_approval_pq_page(self):
        """Клик по кнопке На согласование"""
        with allure.step('Клик по кнопке На согласование'):
            self.waiting_element_is_visibility_on_the_page(ModalNewKpLocators.LOCATOR_BUTTON_ON_APPROVAL)
            self.expecting_clickability(ModalNewKpLocators.LOCATOR_BUTTON_ON_APPROVAL)
            button_approval = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_ON_APPROVAL)
            self.click_js(button_approval)
            time.sleep(1)
            count_time = 0
            wait_time_sec = 90  # Время ожидания в секундах
            loader = self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER)
            while len(loader) > 0:
                count_time += 1
                self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER, sec=wait_time_sec)
                time.sleep(1)
                loader = self.driver.find_elements(*BaseCrmLocators.LOCATOR_LOADER)
                if count_time > 3:
                    raise MyTimeoutException(
                        f'Ошибка ожидания лоадера. Время ожидания - ({count_time * wait_time_sec}) сек.')

            self.modal_send_to_distributor_pq_page()
            self.modal_please_indicate_your_main_competitor_and_supplier()
            self.modal_send_to_distributor_pq_page()
            with allure.step('Ожидание появления флага Согласование или Согласовано в заголовке КП'):
                flag_agreement_or_agreed = self.driver.find_elements(
                    *PqPageLocators.LOCATOR_FLAG_AGREED_OR_AGREEMENT_TITLE_KP)  # Флаг Согласовано или Согласование в заголовке КП
                if len(flag_agreement_or_agreed) == 0:
                    raise MyTimeoutException(f'КП не ушло на согласование. '
                                             f'В заголовке КП не отображается флаг Согласование или Согласовано')

    def modal_send_to_distributor_pq_page(self):
        """Модалка Отправить дистрибьютору, отправка"""
        with allure.step('Модалка Отправить дистрибьютору, отправка'):
            h4_send_to_distributor = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_H4_SEND_TO_DISTRIBUTOR)
            if len(h4_send_to_distributor) > 0:
                with allure.step('Клик по кнопке Отправить'):
                    self.expecting_clickability(ModalNewKpLocators.LOCATOR_BUTTON_SEND)
                    button_send = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_SEND)
                    button_send.click()
                    time.sleep(3)
                with allure.step('Ожидание отработки лоадера после отправки'):
                    self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_LOADER_SEND, sec=120)
                    self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER, sec=150)
                    time.sleep(1)
        with allure.step('Если есть модалка КП не прошло предварительную проверку'):
            h4_pre_check = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_H4_PRE_CHECK)
            if len(h4_pre_check) > 0:
                self.modal_kp_has_not_been_pre_screened()
        time.sleep(1)

    def modal_kp_has_not_been_pre_screened_pq_page(self):
        """Модалка КП не прошло предварительную проверку. Ввод комментария и отправка"""
        with allure.step('Модалка КП не прошло предварительную проверку. Ввод комментария и отправка'):
            with allure.step('Если есть заголовок КП не прошло предварительную проверку, то вводим комментарий и '
                             'отправляем'):
                h4_pre_check = self.driver.find_elements(*ModalNewKpLocators.LOCATOR_H4_PRE_CHECK)
                if len(h4_pre_check) > 0:
                    with allure.step('Ввод комментария'):
                        self.expecting_clickability(ModalNewKpLocators.LOCATOR_COMMENT_IN_MODAL_PRE_CHECK)
                        comment_field = self.find_element(ModalNewKpLocators.LOCATOR_COMMENT_IN_MODAL_PRE_CHECK)
                        comment_field.send_keys('selenium_web_ui')
                    with allure.step('Клик по кнопке Отправить'):
                        self.expecting_clickability(ModalNewKpLocators.LOCATOR_BUTTON_SEND)
                        button_send = self.find_element(ModalNewKpLocators.LOCATOR_BUTTON_SEND)
                        button_send.click()
                        time.sleep(0.5)
                    with allure.step('Ожидание отработки лоадера после клика по кнопке Отправить'):
                        self.waiting_for_loader_processing_on_page(PqPageLocators.LOCATOR_LOADER_PQ_PAGE, sec=150)
                        self.waiting_for_loader_processing_on_page(PqPageLocators.LOCATOR_LOADER, sec=150)

    def create_account(self):
        """Создание счета"""
        with allure.step('Клик по кнопке Создать счета'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_BUTTON_CREATE_ACCOUNT)
            button_create_account = self.find_element(PqPageLocators.LOCATOR_BUTTON_CREATE_ACCOUNT)
            button_create_account.click()
            time.sleep(1)
            time.sleep(1)
            with allure.step('Ожидание отработки лоадера после клика по кнопке Создать счет'):
                self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER_PQ, sec=200)

    def waiting_for_account_creation(self):
        """Ожидание создания счета в PQ"""
        with allure.step('Ожидание создания счета в PQ'):
            pause = 10
            maximum_account_creation_time = 300  # максимальное время создания счета в секундах (5 минут)
            current_time = maximum_account_creation_time
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_NUM_DKP)
            num_dkp = self.find_elements(PqPageLocators.LOCATOR_NUM_DKP)
            created_account_list = self.driver.find_elements(*PqPageLocators.LOCATOR_A_CREATED_ACCOUNT)
            while len(created_account_list) != len(num_dkp):
                time.sleep(pause)
                self.driver.refresh()
                time.sleep(1)
                self.waiting_for_loader_processing_in_dom(BaseCrmLocators.LOCATOR_LOADER)
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_HEADER_KP, sec=60)
                created_account_list = self.driver.find_elements(*PqPageLocators.LOCATOR_A_CREATED_ACCOUNT)
                current_time -= pause
                if current_time == 0:
                    print(f'Время ожидания создания заказов: {maximum_account_creation_time / 60} мин.')
                    sys.exit()

    def store_salesman(self) -> str:
        """Сохранение продавца"""
        with allure.step('Сохранение продавца'):
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_SALESMAN)
            salesman = self.find_element(PqPageLocators.LOCATOR_SALESMAN).text
            salesman = salesman.replace('ООО ', '').replace('"', '')
            return salesman

    def store_created_account(self) -> str:
        """Сохранение созданного счета"""
        with allure.step('Сохранение созданного счета'):
            created_account = self.find_element(PqPageLocators.LOCATOR_A_CREATED_ACCOUNT).text
            return created_account

    def store_price_dkp(self) -> str:
        """Сохранение стоимости ДКП"""
        with allure.step('Сохранение стоимости ДКП'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_PRICE_KP)
            price_dkp = self.find_element(PqPageLocators.LOCATOR_PRICE_KP).text
            price_dkp = price_dkp[0:-2]
            return price_dkp

    def store_articles_product(self) -> list:
        """Сохранение артикулов товара"""
        with allure.step('Сохранение артикулов товара'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_NAME_ARTICLE)
            articles_product = self.driver.find_elements(*PqPageLocators.LOCATOR_NAME_ARTICLE)
            articles_product_text = []
            for article in articles_product:
                articles_product_text.append(article.text)
            return articles_product_text

    def store_article_pto_by_calculation_from_1c(self, calculation_from_1c: str) -> str:
        """Сохранение артикула ПТО по расчету из 1с.
        Номер расчета появляется после создания заказа в 1с. Пример: 019-222233 (по расчету w488900)
        :param calculation_from_1c: Расчет из 1с
        :return: Артикул ПТО или пустая строка (если нет замены на расчет из 1с)
        """
        with allure.step(f'Сохранение артикула ПТО по расчету {calculation_from_1c} из 1с. '
                         'Номер расчета появляется после создания заказа в 1с. Пример: 019-222233 (по расчету w488900)'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_NAME_ARTICLE, sec=5)
            pto_calculation_num = self.driver.find_elements(
                *PqPageLocators.locator_description_pto_by_article(calculation_from_1c))

            if len(pto_calculation_num) > 0:
                calculation_num = pto_calculation_num[0].text.strip().split(' ')[-4].replace(',', '')
            else:
                calculation_num = ''
            return calculation_num

    def store_article_pump_by_calculation_from_1c(self, calculation_from_1c: str) -> str:
        """
        Сохранение артикула насоса по расчету из 1с.
        Номер расчета появляется после создания заказа в 1с. Пример: NS25L0459 (по расчету Q0404240004-1)
        :param calculation_from_1c: Расчет из 1с
        :return: Артикул насоса или пустая строка (если нет замены на расчет из 1с)
        """
        with allure.step(f'Сохранение артикула насоса по расчету {calculation_from_1c} из 1с. '):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_NAME_ARTICLE, sec=5)
            pump_calculation_num = self.driver.find_elements(
                *PqPageLocators.locator_description_by_pump_article(calculation_from_1c))

            if len(pump_calculation_num) > 0:
                calculation_num = pump_calculation_num[0].text.strip().split('_')[0].split(' ')[1]
            else:
                calculation_num = ''
            return calculation_num

    def check_article_in_pq(self, expected_article: list, num_pq: str):
        """
        Проверка, что артикулы есть в КП
        :param expected_article: Ожидаемый список артикулов
        :param num_pq: Номер КП
        """
        with allure.step(f'Проверка, что артикулы ({expected_article}) есть в КП {num_pq}'):
            err_list = []  # Список артикулов, которые не найдены на странице
            article_on_page_pq = self.store_articles_product()  # Артикулы на странице КП
            for article in expected_article:
                if article not in article_on_page_pq:
                    err_list.append(article)

            assert len(err_list) == 0, \
                f'Артикулы - ({err_list}) не найдены на странице КП {num_pq}. Артикулы на странице - ({article_on_page_pq})'

    def saving_the_quantity_of_goods_in_the_order(self) -> int:
        """Сохранение количества товара в заказе"""
        with allure.step('Сохранение количества товара в заказе'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_INPUT_QUANTITY_OF_GOODS_IN_THE_ORDER)
            quantity_of_goods = self.driver.find_elements(*PqPageLocators.LOCATOR_INPUT_QUANTITY_OF_GOODS_IN_THE_ORDER)
            quantity_of_goods_result_list = []
            for quantity in quantity_of_goods:
                quantity = quantity.get_attribute('value')
                quantity_of_goods_result_list.append(int(quantity))
            result_quantity_of_goods = sum(quantity_of_goods_result_list)
            return result_quantity_of_goods

    def saving_the_final_amount_rub_after_agreement(self) -> float:
        """Сохранение итоговой суммы в рублях"""
        with allure.step('Сохранение итоговой суммы в рублях'):
            try:
                self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_TOTAL_PRICE_PQ, sec=30)
                total_price = self.find_element(PqPageLocators.LOCATOR_TOTAL_PRICE_PQ).text
                total_price = ''.join(total_price.split())
                total_price = total_price.replace(',', '.')
                total_price = total_price.replace('₽', '')
                return float(total_price)
            except StaleElementReferenceException:
                self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_TOTAL_PRICE_PQ, sec=5)
                total_price = self.find_element(PqPageLocators.LOCATOR_TOTAL_PRICE_PQ).text
                total_price = ''.join(total_price.split())
                total_price = total_price.replace(',', '.')
                total_price = total_price.replace('₽', '')
                return float(total_price)

    def save_total_cost_client(self) -> float:
        """Сохранение итого стоимости у клиента"""
        with allure.step('Сохранение итого стоимости у клиента'):
            total_cost = self.find_element(PqPageLocators.LOCATOR_TOTAL_COST_CLIENT).text
            total_cost = total_cost.split(' ')[:-1]
            total_cost = ''.join(total_cost).replace(',', '.')
            return float(total_cost)

    def saving_the_final_amount_cu_after_agreement(self) -> float:
        """Сохранение итоговой суммы в уе"""
        with allure.step('Сохранение итоговой суммы в уе'):
            total_price = self.find_element(PqPageLocators.LOCATOR_TOTAL_PRICE_PQ).text
            total_price = ''.join(total_price.split())
            total_price = total_price.replace(',', '.')
            total_price = total_price.replace('у.е.', '')
            return float(total_price)

    def store_all_discounts(self) -> list:
        """Сохранение всех скидок в список"""
        with allure.step('Сохранение всех скидок в список'):
            try:
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_DISCOUNTS_DISTR)
                list_all_discount_web_element = self.driver.find_elements(*PqPageLocators.LOCATOR_DISCOUNTS_DISTR)
                list_all_discount = []
                for discount in list_all_discount_web_element:
                    list_all_discount.append(float(discount.get_attribute("value")))
            except StaleElementReferenceException:
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_DISCOUNTS_DISTR)
                list_all_discount_web_element = self.driver.find_elements(*PqPageLocators.LOCATOR_DISCOUNTS_DISTR)
                list_all_discount = []
                for discount in list_all_discount_web_element:
                    list_all_discount.append(float(discount.get_attribute("value")))
            return list_all_discount

    def saving_total_payment_before_shipment(self) -> str:
        """Сохранение Суммарная оплата перед отгрузкой"""
        with allure.step('Сохранение Суммарная оплата перед отгрузкой'):
            total_payment = self.find_element(PqPageLocators.LOCATOR_TOTAL_PAYMENT_BEFORE_SHIPMENT
                                              ).get_attribute('value').replace(' ', '')
            return total_payment

    def saving_advance_payment_for_placing_an_order(self) -> str:
        """Сохранение Размер аванса для размещения заказа"""
        with allure.step('Сохранение Размер аванса для размещения заказа'):
            advance_payment = self.find_element(PqPageLocators.LOCATOR_ADVANCE_PAYMENT
                                                ).get_attribute('value').replace(' ', '')
            return advance_payment

    def saving_loan_duration(self) -> str:
        """Сохранение продолжительности кредитования"""
        with allure.step('Сохранение продолжительности кредитования'):
            loan_duration = self.find_element(PqPageLocators.LOCATOR_LOAN_DURATION).get_attribute('value')
            return loan_duration

    def delete_cookie_by_name(self, name_cookie: str):
        """Удаление куки по имени"""
        with allure.step(f'Удаление куки по имени - ({name_cookie})'):
            self.driver.delete_cookie(name_cookie)
            time.sleep(1)
            ActionChains(self.driver). \
                key_down(Keys.CONTROL). \
                key_down(Keys.F5). \
                key_up(Keys.CONTROL). \
                key_up(Keys.F5).perform()
            time.sleep(2)

    def close_pq(self):
        """Кнопка (крестик) для закрытия PQ"""
        with allure.step('Клик по кнопке Закрыть PQ(в виде крестика)'):
            button_close = self.find_element(PqPageLocators.LOCATOR_CLOSE_PQ)
            button_close.click()
            time.sleep(5)

    def allowance(self) -> float:
        """Поле надбавка (в случае, если в заказе одна линия)"""
        with allure.step('Сохранение надбавки (в случае, если в заказе одна линия)'):
            allowance_order = self.find_element(PqPageLocators.LOCATOR_ALLOWANCE).text
            allowance_order = re.sub(r'[^0-9,]+', r'', allowance_order)
            allowance_order = re.sub(r',+', r'.', allowance_order)
            return float(allowance_order)

    def saving_surcharges_on_all_article_lines(self) -> list:
        """Сохранение надбавок на всех линиях артикулов"""
        with allure.step('Сохранение надбавок на всех линиях артикулов'):
            try:
                all_allowance = self.driver.find_elements(*PqPageLocators.LOCATOR_ALLOWANCE)
                all_allowance = [float(allowance.text.replace('%', '').replace(',', '.')) for allowance in
                                 all_allowance]
                return all_allowance
            except StaleElementReferenceException:
                all_allowance = self.driver.find_elements(*PqPageLocators.LOCATOR_ALLOWANCE)
                all_allowance = [float(allowance.text.replace('%', '').replace(',', '.')) for allowance in
                                 all_allowance]
                return all_allowance

    @staticmethod
    def allowance_bigger(allowance_order: float):
        """Проверка, что надбавка в заказе больше 0"""
        with allure.step('Проверка, что надбавка в заказе больше 0'):
            assert allowance_order > 0, f'Надбавка меньше или равна 0 - ({allowance_order})'

    def lending_duration_days(self) -> str:
        """Продолжительность кредитования дней"""
        with allure.step('Сохранение продолжительности кредитования дней'):
            lending_duration_days = self.find_element(PqPageLocators.LOCATOR_LENDING_DURATION).get_attribute('value')
            return lending_duration_days

    def saving_delivery_costs_in_rubles(self) -> float:
        """Сохранение стоимости доставки в рублях"""
        with allure.step('Сохранение стоимости доставки в рублях'):
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_TRANSPORTATION_COST, sec=10)
            transportation_cost = self.find_element(PqPageLocators.LOCATOR_TRANSPORTATION_COST).get_attribute("value")
            return float(transportation_cost)

    @staticmethod
    def verify_transportation_cost_crm_open(cost_delivery, transportation_cost):
        """Сравнение стоимости доставки в Корзине и в CRM"""
        with allure.step('Сравнение стоимости доставки в Корзине и в CRM'):
            dif = abs(cost_delivery - transportation_cost)
            assert dif <= 1, \
                f'Стоимость доставки {cost_delivery} в корзине не равна стоимости доставки {transportation_cost} в CRM'

    def delivery_check_pto_crm(self, cost_delivery, transportation_cost):
        """Проверка стоимости доставки в зависимости от кода"""
        with allure.step('Проверка стоимости доставки в зависимости от кода - ПТО или материал'):
            pto_on_page = self.is_element_present(*PqPageLocators.LOCATOR_TEXT_MATERIAL_PTO)
            if pto_on_page:
                self.verify_transportation_cost_crm_open(cost_delivery, transportation_cost)
            else:
                assert transportation_cost == 0, \
                    f'Стоимость транспортный расходов указана некорректно. {transportation_cost}'

    def check_order_lines_count_pto(self):
        """Проверка числа позиций в заказе"""
        with allure.step('Проверка числа позиций в заказе'):
            elements = self.find_elements(PqPageLocators.LOCATOR_POSITION)
            assert 2 == len(elements), \
                f'Неверное число позиций в заказе'

    @staticmethod
    def verify_price_crm_with_price_open(price_crm: float, price_open: float):
        """Сравнение стоимости заказа в Опене с заказом в CRM"""
        with allure.step('Сравнение стоимости заказа в Опене с заказом в CRM'):
            assert price_open == price_crm, f'Стоимость заказа в Опене {price_open} не равна стоимости в CRM {price_crm}'

    def store_price_crm_order(self) -> float:
        """Сохранение стоимости заказа в CRM"""
        with allure.step('Сохранение стоимости заказа в CRM'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_PRICE_CRM)
            price_crm = self.find_element(PqPageLocators.LOCATOR_PRICE_CRM).text
            price_crm = price_crm.replace(',', '.')
            price_crm = float(re.sub(r'[^0-9.]+', r'', price_crm))
            return price_crm

    def should_be_free_payment_mode(self):
        """Должен быть режим оплаты доставки Бесплатно"""
        with allure.step('Проверка, что режим оплаты доставки на странице PQ - Бесплатно'):
            true_payment_mode = 'бесплатно'
            payment_mode_on_page = self.find_element(PqPageLocators.LOCATOR_DELIVERY_PAYMENT_MODE).text.strip().lower()
            assert payment_mode_on_page == true_payment_mode, \
                f'Режим оплаты доставки на странице - ({payment_mode_on_page}) не соответствует ожидаемому режиму оплаты ' \
                f'доставки - ({true_payment_mode})'

    def payment_condition_must_be_advance_payment(self):
        """Условие оплаты должно быть предоплата"""
        with allure.step('Проверка, что условия оплаты - Предоплата'):
            true_payment_terms = 'Предоплата'
            payment_terms_on_page = self.find_element(PqPageLocators.LOCATOR_PAYMENT_TERMS).text
            assert true_payment_terms == payment_terms_on_page, \
                f'Условие оплаты на странице - ({payment_terms_on_page}) не соответствуют ожидаемым - ' \
                f'({true_payment_terms})'

    def save_terms_of_payment(self) -> str:
        """Сохранение условий оплаты"""
        with allure.step('Сохранение условий оплаты'):
            terms_of_payment = self.find_element(PqPageLocators.LOCATOR_PAYMENT_TERMS).text
            return terms_of_payment

    def saving_payment_terms_code(self) -> str:
        """Сохранение кода условий оплаты"""
        with allure.step('Сохранение кода условий оплаты'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_PAYMENT_TERMS_CODE)
            payment_terms_code = self.find_element(PqPageLocators.LOCATOR_PAYMENT_TERMS_CODE).text
            payment_terms_code = ' '.join(payment_terms_code.split(' ')[0:-1])
            return payment_terms_code

    def terms_of_delivery_must_be_standard_contractual_terms(self):
        """Условия поставки должны быть стандартные договорные условия"""
        with allure.step('Проверка, что условия оплаты - Стандартные договорные условия'):
            true_terms_of_delivery = 'Стандартные договорные условия'
            terms_of_delivery_on_page = self.find_element(PqPageLocators.LOCATOR_DELIVERY_CONDITIONS).text
            assert terms_of_delivery_on_page == true_terms_of_delivery, \
                f'Условия поставки на странице - ({terms_of_delivery_on_page}) не соответствуют ожидаемым - ' \
                f'({true_terms_of_delivery})'

    def delivery_conditions_must_be_delivery_to_the_specified_address(self):
        """Условия поставки должны быть доставка на указанный адрес"""
        with allure.step('Проверка, что условия поставки - Доставка на указанный адрес'):
            true_terms_of_delivery = 'Доставка на указанный адрес'
            terms_of_delivery_on_page = self.find_element(PqPageLocators.LOCATOR_DELIVERY_CONDITIONS).text
            assert terms_of_delivery_on_page == true_terms_of_delivery, \
                f'Условия поставки на странице заказа в CRM - ({terms_of_delivery_on_page}) не соответствуют ожидаемым - ' \
                f'({true_terms_of_delivery})'

    def go_to_created_order(self):
        """Переход в созданный заказ"""
        with allure.step('Переход в созданный заказ'):
            link_created_order = self.find_element(PqPageLocators.LOCATOR_LINK_TO_CREATED_ORDER)
            self.scroll_to(link_created_order)
            self.expecting_clickability(PqPageLocators.LOCATOR_LINK_TO_CREATED_ORDER)
            link_created_order.click()
            self.switching_window(-1)
            self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER_PQ)
            with allure.step('Проверка появления на странице заказа заголовка'):
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_HEADER_KP, sec=60)

    def go_to_order_by_reference_number(self, num_link_order: int):
        """Переход в заказ по номеру ссылки"""
        with allure.step(f'Переход в заказ по номеру ссылки ({num_link_order})'):
            link_created_order_list = self.find_elements(PqPageLocators.LOCATOR_LINK_TO_CREATED_ORDER)
            link_order = num_link_order - 1
            link_created_order = link_created_order_list[link_order]
            self.scroll_to(link_created_order)
            time.sleep(0.5)
            link_created_order.click()
            self.switching_window(-1)
            with allure.step('Проверка появления на странице заказа заголовка'):
                self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER)
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_HEADER_KP, sec=90)
                time.sleep(
                    3)  # В срм после рендера страницы повторно вызывается симуляция, поэтому страница еще раз рендерится

    def there_should_be_a_special_price_icon_at_article(self, article: str):
        """Должна быть иконка спец цены у артикула"""
        with allure.step(f'Проверка отображения иконки Спец. цены у артикула {article}'):
            try:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.locator_special_price_icon_by_article(article), sec=10)
                self.waiting_element_is_visibility_on_the_page(
                    ModalNewKpLocators.locator_special_price_icon_by_article(article), sec=5)
            except StaleElementReferenceException:
                self.waiting_element_is_visibility_located_dom(
                    ModalNewKpLocators.locator_special_price_icon_by_article(article), sec=10)
                self.waiting_element_is_visibility_on_the_page(
                    ModalNewKpLocators.locator_special_price_icon_by_article(article), sec=5)

    def there_should_be_a_retail_icon_at_article(self, article: str):
        """Должна быть искона Розница у артикула"""
        with allure.step(f'Проверка отображения иконки Розница у артикула {article}'):
            self.waiting_element_is_visibility_located_dom(ModalNewKpLocators.locator_retail_icon_by_article(article),
                                                           sec=10)

    def checking_entered_date_of_central_bank_exchange_rate(self, expected_date: str):
        """Проверка введенной даты курса Центрального Банка
        expected_date - ожидаемая дата
        """
        with allure.step('Проверка введенной даты курса Центрального Банка'):
            input_date_curse = self.find_element(PqPageLocators.INPUT_CURRENCY_DATE)
            entered_date_curse = input_date_curse.get_attribute('value')
            assert entered_date_curse == expected_date, \
                f'Выбранная дата курса ({entered_date_curse}) не соответствует ожидаемой - ({expected_date})'

    def click_btn_kit_contents(self):
        """Клик по кнопке Состав комплекта"""
        with allure.step('Клик по кнопке Состав комплекта'):
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_BTN_KIT_CONTENTS, sec=5)
            btn_kit_contents = self.find_element(PqPageLocators.LOCATOR_BTN_KIT_CONTENTS)
            btn_kit_contents.click()
            with allure.step('Проверка отображения заголовка'):
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_HEADER_IN_MODAL_KIT_CONTENTS,
                                                               sec=7)

    def save_article_in_modal_kit_contents(self) -> list:
        """Сохранение артикулов в модалке Состав комплекта"""
        with allure.step('Сохранение артикулов в модалке Состав комплекта'):
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_ARTICLE_IN_MODAL_KIT_CONTENTS, sec=5)
            articles = self.find_elements(PqPageLocators.LOCATOR_ARTICLE_IN_MODAL_KIT_CONTENTS)
            articles = [article.text for article in articles]
            return articles

    def waiting_for_automatic_approval_dzerzhinsk_plant(self):
        """Ожидание автоматического согласования завод дзержинск"""
        with allure.step('Ожидание автоматического согласования завод дзержинск'):
            time_wait = 180  # Время ожидания в сек
            step_wait = 20  # Время шага
            flag = False

            while not flag:
                count_flag_agreed_by_dzerzhinsk_plant = len(
                    self.driver.find_elements(*PqPageLocators.LOCATOR_FLAG_AGREED_BY_DZERZHINSK_PLANT)
                )

                if count_flag_agreed_by_dzerzhinsk_plant == 0:
                    time.sleep(step_wait)
                    self.driver.refresh()
                    self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER_PQ)
                    time.sleep(1)
                    time_wait -= step_wait

                elif count_flag_agreed_by_dzerzhinsk_plant == 1:
                    print('Дождались автосогласования Завод Дзержинск')
                    flag = True

                elif time_wait == 0:
                    print('Не дождались автосогласования Завод Дзержинск')
                    flag = True

    def checking_selected_potential_mode(self, expected_potential_mode: str):
        """Проверка выбранного режима потенциала"""
        with allure.step(f'Проверка выбранного режима потенциала. Ожидаемый - {expected_potential_mode}'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_POTENTIAL_MODE)
            selected_potential_mode = self.find_element(PqPageLocators.LOCATOR_POTENTIAL_MODE).text
            assert selected_potential_mode == expected_potential_mode, \
                f'Выбранный режим потенциала - ({selected_potential_mode}) не соответствует ожидаемому - ' \
                f'({expected_potential_mode})'

    def saving_grand_total_all_dkp(self) -> float:
        """Сохранение общей итоговой суммы всех ДКП"""
        with allure.step('Сохранение общей итоговой суммы всех ДКП'):
            grand_total_all_dkp = 0.0
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_TOTAL_AMOUNT_DKP_IN_ORDERS_SECTION)
            total_price_dkp_list = self.find_elements(PqPageLocators.LOCATOR_TOTAL_AMOUNT_DKP_IN_ORDERS_SECTION)
            for price in total_price_dkp_list:
                price_dkp = price.text.split(':')[-1]
                price_dkp = float(price_dkp.replace(',', '.').replace('₽', '').replace(' ', ''))
                grand_total_all_dkp += price_dkp
            return round(grand_total_all_dkp, 2)

    def save_total_price_by_dkp(self, num_dkp: str):
        """Сохранение итоговой суммы у ДКП в списке созданных заказов по номеру ДКП вида PQxxxxxx"""
        with allure.step('Сохранение итоговой суммы у ДКП на странице PQ в списке созданных заказов по номеру ДКП '
                         'вида PQxxxxxx'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.locator_total_price_by_num_dkp(num_dkp))
            total_price = self.find_element(PqPageLocators.locator_total_price_by_num_dkp(num_dkp)).text.split(':')[-1]
            total_price = float(total_price.replace(',', '.').replace('₽', '').replace(' ', ''))
            return total_price

    def number_unequal_check_dkp(self):
        """Проверка неравенства номеров ДКП"""
        with allure.step('Проверка неравенства номеров ДКП'):
            list_num_dkp = sorted(self.save_all_num_dkp())
            list_without_repetitions_dkp = sorted(list(set(list_num_dkp)))

            assert list_without_repetitions_dkp == list_num_dkp, \
                f'Номера ДКП повторяются. Список с повторениями - ({list_num_dkp}). Список без повторений номеров ' \
                f'ДКП - ({list_without_repetitions_dkp})'

    def save_num_order_in_title_pq(self) -> str:
        """Сохранение номера заказа в заголовке КП"""
        with allure.step('Сохранение номера заказа в заголовке КП'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_NUM_ORDER_IN_TITLE_PQ, sec=5)
            num_order = self.find_element(PqPageLocators.LOCATOR_NUM_ORDER_IN_TITLE_PQ).text.strip()
            return num_order

    def save_all_num_dkp(self) -> list:
        """Сохранение всех номеров ДКП"""
        with allure.step('Сохранение всех номеров ДКП'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_NUM_DKP, sec=40)
            list_num_dkp = self.find_elements(PqPageLocators.LOCATOR_NUM_DKP)
            list_num_dkp = [el.text for el in list_num_dkp]
            return list_num_dkp

    def saving_amount_from_nds_distributor_in_each_position(self) -> list:
        """Сохранение суммы с НДС Дистра в каждой позиции"""
        with allure.step('Сохранение суммы с НДС Дистра в каждой позиции'):
            try:
                self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_AMOUNT_WITH_NDS_DISTR_IN_POSITION,
                                                               sec=5)
                amount_from_nds_distributor_in_each_position = self.find_elements(
                    PqPageLocators.LOCATOR_AMOUNT_WITH_NDS_DISTR_IN_POSITION)
                amount_from_nds_distributor_in_each_position = [el.text for el in
                                                                amount_from_nds_distributor_in_each_position]
                amount_from_nds_distributor_in_each_position = [
                    float(el.replace(',', '.').replace('₽', '').replace(' ', '')) for el in
                    amount_from_nds_distributor_in_each_position]
            except StaleElementReferenceException:
                self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_AMOUNT_WITH_NDS_DISTR_IN_POSITION,
                                                               sec=5)
                amount_from_nds_distributor_in_each_position = self.find_elements(
                    PqPageLocators.LOCATOR_AMOUNT_WITH_NDS_DISTR_IN_POSITION)
                amount_from_nds_distributor_in_each_position = [el.text for el in
                                                                amount_from_nds_distributor_in_each_position]
                amount_from_nds_distributor_in_each_position = [
                    float(el.replace(',', '.').replace('₽', '').replace(' ', '')) for el in
                    amount_from_nds_distributor_in_each_position]

            return amount_from_nds_distributor_in_each_position

    def save_description_article(self) -> str:
        """Сохранение описания артикула"""
        with allure.step('Сохранение описания артикула'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_DESCRIPTION_ARTICLE)
            description_article = self.find_element(PqPageLocators.LOCATOR_DESCRIPTION_ARTICLE).text
            return description_article

    def click_refresh_supplementary(self):
        """Клик по кнопке Пересоздать документы (бтп доп.соглашение)"""
        with allure.step('Клик по кнопке Пересоздать документы (бтп доп.соглашение)'):
            with allure.step('Перезагрузка страницы и ожидание отработки лоадера'):
                self.driver.refresh()
                self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER)
            with allure.step('Клик по кнопке Пересоздать документы'):
                button_refresh_supplementary = (self.waiting_element_is_visibility_on_the_page
                                                (PqPageLocators.LOCATOR_REFRESH_SUPPLEMENTARY))
                button_refresh_supplementary.click()
                time.sleep(1)
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER_PQ)
            with allure.step('Проверка, что появилась ссылка на документ Доп. соглашение БТП'):
                self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_DOP_SUPPLEMENTARY)
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_DOP_SUPPLEMENTARY, sec=5)

    def download_dop_supplementary(self):
        """Скачать доп. соглашение на БТП"""
        with allure.step('Скачивание документа Доп. соглашение БТП'):
            with allure.step('Клик по ссылке для скачивания документа'):
                dop_supplementary_download = self.find_element(PqPageLocators.LOCATOR_DOP_SUPPLEMENTARY)
                dop_supplementary_download.click()

            name_file = f'Доп соглашение по бтп.pdf'
            with allure.step(f'Удаление файла {name_file} в папке Загрузки, если он есть в данной папке'):
                self.delete_file_by_name_in_download_folder(name_file)
            with allure.step('Проверка, что документ есть в папке Загрузки'):
                self.checking_the_download_document_in_the_download_folder(name_file)
            with allure.step(f'Удаление файла {name_file} в папке Загрузки, если он есть в данной папке'):
                self.delete_file_by_name_in_download_folder(name_file)
            time.sleep(2)

    def click_short_refresh_supplementary(self):
        """Создать сокращенное доп. соглашение на БТП"""
        with allure.step('Создание сокращенного доп. соглашения на БТП'):
            button_short_refresh_supplementary = self.find_element(PqPageLocators.LOCATOR_REFRESH_SHORT_SUPPLEMENTARY)
            button_short_refresh_supplementary.click()
            self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER)

    def download_short_refresh_supplementary(self):
        """Скачать сокращенное доп. соглашение на БТП"""
        with allure.step('Скачивание сокращенного доп. соглашения на БТП'):
            with allure.step('Клик по прикрепленным файлам'):
                self.expecting_clickability(PqPageLocators.LOCATOR_FILE_DOP_SUPPLEMENTARY, sec=5)
                file_dop_supplementary = self.find_element(PqPageLocators.LOCATOR_FILE_DOP_SUPPLEMENTARY)
                self.click_js(file_dop_supplementary)
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_PDF_SHORT_SUPPLEMENTARY)
            with allure.step('Клик по ссылке скачивания сокращенного доп. соглашения на БТП'):
                download_short_refresh_supplementary = self.find_element(PqPageLocators.LOCATOR_PDF_SHORT_SUPPLEMENTARY)
                download_short_refresh_supplementary.click()

            name_file = f'Сокращенное_доп_соглашение_по_БТП.pdf'
            with allure.step(f'Удаление файла {name_file}, если он есть в папке Загрузки'):
                self.delete_file_by_name_in_download_folder(name_file)
            with allure.step(f'Проверка, что файл  {name_file} есть в папке Загрузки'):
                self.checking_the_download_document_in_the_download_folder(name_file)
            with allure.step(f'Удаление файла {name_file}, если он есть в папке Загрузки'):
                self.delete_file_by_name_in_download_folder(name_file)
            time.sleep(2)

    def verification_of_agreement_den(self):
        """Проверка, что появилось согласование DEN"""
        with allure.step('Проверка что есть согласование DEN'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_BLOCK_WITH_APPROVAL, sec=5)
            agreement_den = self.driver.find_elements(*PqPageLocators.LOCATOR_VERIFICATION_OF_AGREEMENT_DEN)
            assert len(agreement_den) > 0, f'Согласование DEN не появилось на странице'

    def save_contractors_den(self) -> list:
        """Сохранение согласователей DEN"""
        with allure.step('Сохранение списка согласователей DEN'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_SURNAME_CONTRACTORS_DEN, sec=10)
            contractors_den = self.find_elements(PqPageLocators.LOCATOR_SURNAME_CONTRACTORS_DEN)
            contractors_den = [contractor.text for contractor in contractors_den]
            return contractors_den

    def agreement_employee_den(self):
        """Согласование скидки DEN"""
        with allure.step('На странице видна видна галочка согласования DEN'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_AGREEMENT_TRUE, sec=60)
            agreement_true = self.find_element(PqPageLocators.LOCATOR_AGREEMENT_TRUE)
            with allure.step('Прокрутить страницу до согласования'):
                self.scroll_to(agreement_true)
            with allure.step('Нажать на зеленую галочку Согласовать скидку DEN'):
                self.driver.execute_script("arguments[0].click()", agreement_true)
                self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_H4_AGREEMENT, sec=90)

    def save_loose_kp(self) -> list:
        """Сохранение согласователей Незакрепленное КП"""
        with allure.step('Сохранение списка согласователей Незакрепелнное КП'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_SURNAME_LOOSE_KP, sec=10)
            contractors_loose_kp = self.find_elements(PqPageLocators.LOCATOR_SURNAME_LOOSE_KP)
            contractors_loose_kp = [contractor.text for contractor in contractors_loose_kp]

            if len(contractors_loose_kp) == 0:
                self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_SURNAME_LOOSE_KP, sec=10)
                contractors_loose_kp = self.find_elements(PqPageLocators.LOCATOR_SURNAME_LOOSE_KP)
                contractors_loose_kp = [contractor.text for contractor in contractors_loose_kp]
            return contractors_loose_kp

    def reject_loose_kp(self):
        """Отклонение согласования Незакрепленного КП"""
        with allure.step('Найти строку согласования и отклонения Незакрелпенного КП'):
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_REJECT_LOOSE_KP, sec=60)
            reject = self.find_element(PqPageLocators.LOCATOR_REJECT_LOOSE_KP)
            with allure.step('Прокрутить страницу до отклонения'):
                self.scroll_to(reject)
            with allure.step('Нажать на красный крестик первый'):
                self.driver.execute_script("arguments[0].click()", reject)
                self.waiting_element_is_visibility_located_dom(
                    PqPageLocators.LOCATOR_BUTTON_REJECT_IN_THE_APPROVAL_MODAL, sec=90)

    def category_gcm(self, category: str) -> str:
        """Сохранение найденного ГЦМ"""
        with allure.step('Найти код с такой ГЦМ'):
            self.waiting_element_is_visibility_located_dom(
                PqPageLocators.locator_category_gcm_sum_distr(category))
            category_gcm = self.find_element(
                PqPageLocators.locator_category_gcm_sum_distr(category)).text
            return str(category_gcm)

    def save_category_in_invoice(self):
        """Сохранение ГЦМ"""
        with allure.step('Сохранить ГЦМ'):
            category_in_invoice = self.find_element(PqPageLocators.LOCATOR_CATEGORY_IN_INVOICE)
            return category_in_invoice

    def check_category_in_invoice(self, category: str):
        """Проверка, что в счете код с нужной группой"""
        with allure.step('Проверка что в счете оборудование с нужной ГЦМ'):
            try:
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_CATEGORY_IN_INVOICE)
                category = self.driver.find_elements(*PqPageLocators.locator_category_gcm(category))
                if len(category) == 0:
                    return False
                else:
                    return True
            except StaleElementReferenceException:
                self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_CATEGORY_IN_INVOICE)
                category = self.driver.find_elements(*PqPageLocators.locator_category_gcm(category))
                if len(category) == 0:
                    return False
                else:
                    return True

    def status_of_checkpoint_must_be_approval(self):
        """Статус КП должен быть Согласование"""
        with allure.step('Проверка статуса КП'):
            expected_status = 'Согласование'
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_STATUS_KP_IN_TITLE, sec=5)
            status_kp = self.find_element(PqPageLocators.LOCATOR_STATUS_KP_IN_TITLE).text
            assert expected_status == status_kp, \
                f'Ожидаемый статус КП - ({expected_status}) не соответствует статусу на странице КП - ({status_kp})'

    def check_that_discount_fields_are_not_editable_on_all_items(self):
        """Проверка, что все поля скидка дистра не редактируемы"""
        with allure.step('Проверка, что все поля скидка дистра не редактируемы'):
            expected_attribute = 'true'
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_DISCOUNTS_DISTR, sec=5)
            input_discounts_attribute = self.find_element(PqPageLocators.LOCATOR_DISCOUNTS_DISTR).get_attribute(
                'disabled')
            assert input_discounts_attribute == expected_attribute, f'Поле скидки на странице PQ редактируемо. Атрибут - ' \
                                                                    f'({input_discounts_attribute})'

    def check_cp_from_client_agreed_by_author_of_cp(self):
        """Проверка, что КП от клиента - согласовано автором КП"""
        with allure.step('Проверка, что КП от клиента - согласовано автором КП'):
            expected_inscription = 'КП от клиента - согласовано автором КП'
            self.waiting_for_loader_processing_in_dom(PqPageLocators.LOCATOR_LOADER_BUILDING_AN_APPROVAL_PLAN, sec=30)
            self.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_BLOCK_WITH_APPROVAL, sec=10)
            line_in_block_with_approval = self.find_elements(PqPageLocators.LOCATOR_TD_LINE_IN_BLOCK_APPROVAL)
            text_in_line_in_block_with_approval = [el.text.strip() for el in line_in_block_with_approval]
            flag = False
            for text in text_in_line_in_block_with_approval:
                if expected_inscription in text:
                    flag = True

            assert flag is True, f'Надпись - ({expected_inscription}) не появилась на странице. Все записи - ' \
                                 f'({text_in_line_in_block_with_approval})'

    def click_btn_cancel_approval(self):
        """Клик по кнопке Отменить согласование"""
        with allure.step('Клик по кнопке Отменить согласование'):
            expected_name_title_kp = 'Черновик'  # Ожидаемый заголовок в КП после отмены согласования
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_BTN_CANCEL_APPROVAL, sec=15)
            btn_cancel_approval = self.find_element(PqPageLocators.LOCATOR_BTN_CANCEL_APPROVAL)
            btn_cancel_approval.click()
            self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER)
            self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER, sec=50)
            time.sleep(1)  # страница после загрузки дергается
            self.waiting_element_is_visibility_on_the_page(PqPageLocators.LOCATOR_STATUS_KP_IN_TITLE, sec=20)
            title_on_page_kp = self.find_element(PqPageLocators.LOCATOR_STATUS_KP_IN_TITLE).text
            assert title_on_page_kp == expected_name_title_kp, \
                f'Заголовок на странице КП - ({title_on_page_kp}) после отмены согласования не соответствует ожидаемому - ' \
                f'({expected_name_title_kp})'

    def checking_approval_status(self, type_agreement: str, expected_status_agreement: str):
        """
        Проверка статуса согласования
        :param type_agreement: Вид согласования
        :param expected_status_agreement: Ожидаемый статус согласования
        :return: None
        """
        with allure.step(f'Проверка статуса согласования {type_agreement}'):
            self.waiting_element_is_visibility_located_dom(
                PqPageLocators.locator_status_agreement_by_type_agreement(type_agreement), sec=3)
            status_agreement_on_page = self.find_element(
                PqPageLocators.locator_status_agreement_by_type_agreement(type_agreement)).text
            assert status_agreement_on_page == expected_status_agreement, \
                f'Статус ({status_agreement_on_page}) у согласования {type_agreement} не соответствует ожидаемому - ({expected_status_agreement})'

    def refresh_page(self):
        """Обновление страницы"""
        with allure.step('Обновление страницы'):
            self.driver.refresh()
            self.waiting_for_loader_processing_on_page(BaseCrmLocators.LOCATOR_LOADER)
