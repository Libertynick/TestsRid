from api_testing_project.utils.http_methods import HttpMethods
import requests
import allure
from requests.auth import HTTPBasicAuth

from base_page.raise_exceptions import MyException
from config import TestEnvironment
from tools.logger import json_logger as logger


class JsonHandler:
    """Класс для работы с JSON данными"""

    def __init__(self):
        """Инициализация класса"""
        logger.info("Инициализация JsonHandler")
        self.json_data = None
        # Кэш для часто используемых данных
        self._cache = {}

    @allure.step("Загрузка JSON данных для заказа {order_number}")
    def download_json_data(self, order_number, pin_code):
        """Загрузка JSON-данных через API"""
        try:
            logger.info(f"Загрузка JSON данных для заказа {order_number}")
            auth = HTTPBasicAuth(
                TestEnvironment.API_LOGIN,
                TestEnvironment.API_PASSWORD
            )

            logger.debug(f"Отправка GET запроса к {TestEnvironment.BTP_API_URL}")
            response = requests.get(
                TestEnvironment.BTP_API_URL,
                verify=False,
                params={"orderNumber": order_number, "pinCode": pin_code},
                auth=auth,
                timeout=45  # Уменьшим тайм-аут для ускорения
            )
            response.raise_for_status()
            self.json_data = response.json()
            # Сбрасываем кэш при загрузке новых данных
            self._cache = {}
            logger.info(f"JSON данные успешно загружены для заказа {order_number}")
            return self.json_data
        except requests.exceptions.RequestException as e:
            logger.error(f"Ошибка при загрузке JSON: {e}")
            return None

    def get_order_object(self):
        """Получение основного объекта заказа"""
        logger.debug("Получение основного объекта заказа")
        if not self.json_data or 'objects' not in self.json_data or not self.json_data['objects']:
            logger.warning("Основной объект заказа не найден в JSON")
            return None
        return self.json_data['objects'][0]

    def get_order_statuses(self):
        """Получение статусов заказа из JSON"""
        logger.debug("Получение статусов заказа из JSON")
        # Используем кэш, если данные уже получены
        if 'order_statuses' in self._cache:
            logger.debug("Использование кэшированных статусов заказа")
            return self._cache['order_statuses']

        order = self.get_order_object()
        if not order or 'progressSummaries' not in order:
            logger.warning("Статусы заказа не найдены в JSON")
            return []

        statuses = [status.get('summary', '') for status in order['progressSummaries'] if 'summary' in status]
        logger.debug(f"Получено {len(statuses)} статусов заказа")

        # Сохраняем в кэше
        self._cache['order_statuses'] = statuses
        return statuses

    def get_order_items(self):
        """Получение списка элементов заказа"""
        logger.debug("Получение списка элементов заказа")
        # Используем кэш, если данные уже получены
        if 'order_items' in self._cache:
            logger.debug("Использование кэшированных элементов заказа")
            return self._cache['order_items']

        order = self.get_order_object()
        if not order or 'items' not in order:
            logger.warning("Элементы заказа не найдены в JSON")
            return []

        items = order['items']
        logger.debug(f"Получено {len(items)} элементов заказа")

        # Сохраняем в кэше
        self._cache['order_items'] = items
        return items

    def get_articles(self):
        """Получение списка артикулов из JSON"""
        logger.debug("Получение списка артикулов из JSON")
        # Используем кэш, если данные уже получены
        if 'articles' in self._cache:
            logger.debug("Использование кэшированных артикулов")
            return self._cache['articles']

        items = self.get_order_items()
        articles = [item.get('materialCode', '') for item in items if 'materialCode' in item]
        logger.debug(f"Получено {len(articles)} артикулов")

        # Сохраняем в кэше
        self._cache['articles'] = articles
        return articles

    def get_delivery_numbers(self):
        """Получение номеров допоставки из JSON"""
        logger.debug("Получение номеров допоставки из JSON")
        # Используем кэш, если данные уже получены
        if 'delivery_numbers' in self._cache:
            logger.debug("Использование кэшированных номеров допоставки")
            return self._cache['delivery_numbers']

        items = self.get_order_items()
        delivery_map = {}

        for item in items:
            material_code = item.get('materialCode')
            if not material_code:
                continue

            delivery = None
            internal_order = item.get('internalOrder', {})
            if internal_order:
                delivery = internal_order.get('internalRequestOrderNumber')
            delivery_map[material_code] = delivery

        logger.debug(f"Получено {len(delivery_map)} номеров допоставки")
        # Сохраняем в кэше
        self._cache['delivery_numbers'] = delivery_map
        return delivery_map

    def get_article_steps(self, article_code):
        """Получение этапов для конкретного артикула"""
        logger.debug(f"Получение этапов для артикула {article_code}")
        # Проверяем, есть ли в кэше
        cache_key = f'article_steps_{article_code}'
        if cache_key in self._cache:
            logger.debug(f"Использование кэшированных этапов для артикула {article_code}")
            return self._cache[cache_key]

        items = self.get_order_items()
        for item in items:
            if item.get('materialCode') == article_code:
                steps = item.get('progressSteps', [])
                logger.debug(f"Получено {len(steps)} этапов для артикула {article_code}")
                # Сохраняем в кэше
                self._cache[cache_key] = steps
                return steps
        logger.warning(f"Этапы для артикула {article_code} не найдены")
        return []

    def get_articles_with_process_stages(self):
        """Получение артикулов и их этапов в статусе 'Process'"""
        logger.debug("Получение артикулов с этапами Process")
        # Используем кэш, если данные уже получены
        if 'process_stages' in self._cache:
            logger.debug("Использование кэшированных этапов Process")
            return self._cache['process_stages']

        result = {}
        items = self.get_order_items()

        for item in items:
            article_code = item.get('materialCode')
            if not article_code:
                continue

            process_stages = []

            for step in item.get('progressSteps', []):
                if step.get('status') == 'Process':
                    process_stages.append(step.get('description'))

            if process_stages:
                result[article_code] = process_stages

        logger.debug(f"Получено {len(result)} артикулов с этапами Process")
        # Сохраняем в кэше
        self._cache['process_stages'] = result
        return result

    def get_next_active_stage_for_article(self, article_code):
        """Получение следующего активного этапа для артикула"""
        logger.debug(f"Получение следующего активного этапа для артикула {article_code}")
        steps = self.get_article_steps(article_code)

        if not steps:
            logger.warning(f"Этапы для артикула {article_code} не найдены")
            return None, None

        # Находим индекс последнего завершенного этапа
        last_finished_idx = -1
        for idx, step in enumerate(steps):
            if step.get('status') == 'Finish':
                last_finished_idx = idx

        # Если все этапы завершены
        if last_finished_idx == len(steps) - 1:
            logger.debug(f"Все этапы для артикула {article_code} завершены")
            return None, None

        # Если есть следующий этап после последнего завершенного
        if last_finished_idx >= 0 and last_finished_idx + 1 < len(steps):
            next_step = steps[last_finished_idx + 1]
            logger.debug(
                f"Следующий этап для {article_code}: {next_step.get('description')}, статус: {next_step.get('status')}")
            return next_step.get('description'), next_step.get('status')

        # Если ничего не завершено, берем первый этап
        if last_finished_idx == -1 and steps:
            first_step = steps[0]
            logger.debug(
                f"Первый этап для {article_code}: {first_step.get('description')}, статус: {first_step.get('status')}")
            return first_step.get('description'), first_step.get('status')

        logger.warning(f"Не удалось определить следующий этап для артикула {article_code}")
        return None, None

    def get_articles_with_photos(self):
        """
        Получает данные о наличии фото для каждого артикула.
        Returns:
            dict: Словарь {артикул: имеет_фото (True/False)}
        """
        logger.debug("Получение данных о наличии фото для артикулов")
        # Используем кэш, если данные уже получены
        if 'articles_photos' in self._cache:
            logger.debug("Использование кэшированных данных о фото")
            return self._cache['articles_photos']

        result = {}

        # Получаем все элементы заказа
        items = self.get_order_items()

        # Проходим по каждому артикулу и проверяем наличие фото
        for item in items:
            article = item.get('materialCode')
            if not article:
                continue

            # Проверяем наличие фото у артикула
            has_photos = False

            # В данной структуре у артикула может быть поле images
            if 'images' in item and item['images']:
                for image in item['images']:
                    if image.get('preview', {}).get('absoluteUrl'):
                        has_photos = True
                        break

            # Сохраняем результат для артикула
            result[article] = has_photos

        logger.debug(f"Получено {len(result)} артикулов с информацией о фото")
        # Сохраняем результат в кэше
        self._cache['articles_photos'] = result
        return result


def get_ruco_user_crm_by_name(cookie, name_user: str) -> str:
    """
    Получение ruco пользователя по имени юзера (Пример: Мишина) через запрос
    :param cookie: cookies сессии
    :param name_user: Имя пользователя
    :return: RUCO пользователя
    """
    url_author = 'https://ruecom-extru-tst.ridancorp.net/OneCRM/Objects/Perform/'  # урл для запроса на получение руко пользователя
    base_api = HttpMethods()
    req = {
        'obj': f'{{"filter":{{"term": "{name_user}","userGroup":"Все"}},"_mode": "dicts.user"}}',
        'objectid': 700
    }

    response = base_api.post(url=url_author, body=req, cookies=cookie)
    response.raise_for_status()
    ruco = response.json()
    ruco = str(ruco['data'][0]['value'])
    ruco = ruco.split('\\')[1].split(' ')[0].replace(')', '')
    return ruco


def release_all_substitutions_crm(cookie):
    """Освободить все подмены в СРМ"""
    url = 'https://ruecom-extru-tst.ridancorp.net/OneCRM/Objects/Perform/'
    base_api = HttpMethods()
    req = {"obj": "{\"_mode\":\"ResetAllUsersContext\"}", "objectid": 700}
    response_code = base_api.post(url=url, body=req, cookies=cookie).status_code
    if response_code != 200:
        raise MyException(f'При запросе Освободить все подмены ошибка. code- {response_code}')
