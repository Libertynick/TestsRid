import time

import allure
from selenium.webdriver.support.select import Select

from base_page.base_page import BasePage
from base_page.base_page_locators import BaseOpenLocators
from open_pages.selection_online_tools_all.configurator_ppto.configurator_ppto_locators import ConfiguratorPptoLocators


@allure.feature('Страница Конфигуратор ППТО. Испаритель')
class ConfiguratorPptoEvaporatorPage(BasePage):
    """Страница Конфигуратор ППТО. Испаритель"""

    def load_must_be_in_kwt(self):
        """Нагрузка должна быть в кВт"""
        with allure.step('Нагрузка должна быть в кВт'):
            expected_load_unit = 'кВт'
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_LOAD_UNIT, sec=5)
            load_unit_on_page = self.find_element(ConfiguratorPptoLocators.LOCATOR_LOAD_UNIT)
            select = Select(load_unit_on_page)
            load_unit_on_page = select.first_selected_option.text
            assert load_unit_on_page == expected_load_unit, \
                f'Выбранное значение единицы измерения Нагрузки - ({load_unit_on_page}) не соответствует ожидаемому ' \
                f'значению - ({expected_load_unit})'

    def load_value_check(self, expected_load_value: str):
        """Проверка значения нагрузки"""
        with allure.step('Проверка значения нагрузки'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_INPUT_LOAD, sec=5)
            load_value_on_page = self.find_element(ConfiguratorPptoLocators.LOCATOR_INPUT_LOAD).get_attribute('value')
            assert load_value_on_page == expected_load_value, \
                f'Значение нагрузки на странице - ({load_value_on_page}) не соответствует ожидаемому значению ' \
                f'- ({expected_load_value})'

    def checking_type_of_coolant_medium_hot(self, expected_type_of_coolant_medium_hot):
        """Проверка типа среды на Теплоносителе"""
        with allure.step('Проверка типа среды на Теплоносителе'):
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_SELECT_COOLANT_ENVIRONMENT_TYPE_HOT, sec=5)
            type_of_coolant_medium_hot_on_page = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_SELECT_COOLANT_ENVIRONMENT_TYPE_HOT)
            select = Select(type_of_coolant_medium_hot_on_page)
            type_of_coolant_medium_hot_on_page = select.first_selected_option.text
            assert type_of_coolant_medium_hot_on_page == expected_type_of_coolant_medium_hot, \
                f'Тип среды на Теплоносителе на странице - ({type_of_coolant_medium_hot_on_page}) не соответствует ' \
                f'ожидаемому - ({expected_type_of_coolant_medium_hot})'

    def checking_type_of_coolant_medium_cold(self, expected_type_of_coolant_medium_cold):
        """Проверка типа среды на Хладоносителе"""
        with allure.step('Проверка типа среды на Хладоносителе'):
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_SELECT_COOLANT_ENVIRONMENT_TYPE_COLD, sec=5)
            type_of_coolant_medium_cold_on_page = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_SELECT_COOLANT_ENVIRONMENT_TYPE_COLD)
            select = Select(type_of_coolant_medium_cold_on_page)
            type_of_coolant_medium_cold_on_page = select.first_selected_option.text
            assert type_of_coolant_medium_cold_on_page == expected_type_of_coolant_medium_cold, \
                f'Тип среды на Хладоноситель на странице - ({type_of_coolant_medium_cold_on_page}) не соответствует ' \
                f'ожидаемому - ({expected_type_of_coolant_medium_cold})'

    def checking_inlet_temperature_hot_value(self, expected_inlet_temperature_hot: str):
        """Проверка значения температуры на входе горячая"""
        with allure.step('Проверка значения температуры на входе горячая'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_INPUT_INLET_TEMPERATURE_HOT,
                                                           sec=5)
            inlet_temperature_value_on_page = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_INPUT_INLET_TEMPERATURE_HOT
            ).get_attribute('value')
            assert inlet_temperature_value_on_page == expected_inlet_temperature_hot, \
                f'Температура на входе горячая на странице - ({inlet_temperature_value_on_page}) не соответствует ' \
                f'ожидаемой - ({expected_inlet_temperature_hot})'

    def checking_inlet_temperature_cold_value(self, expected_inlet_temperature_cold: str):
        """Проверка значения температуры на входе холодная"""
        with allure.step('Проверка значения температуры на входе холодная'):
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_INPUT_INLET_TEMPERATURE_COLD,
                sec=5)
            inlet_temperature_value_on_page = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_INPUT_INLET_TEMPERATURE_COLD).get_attribute('value')
            assert inlet_temperature_value_on_page == expected_inlet_temperature_cold, \
                f'Температура на входе холодная на странице - ({inlet_temperature_value_on_page}) не соответствует ' \
                f'ожидаемой - ({expected_inlet_temperature_cold})'

    def checking_outlet_temperature_hot_value(self, expected_outlet_temperature_hot_value: str):
        """Проверка значения Температуры на выходе горячая"""
        with allure.step('Проверка значения Температуры на выходе горячая'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_OUTLET_TEMPERATURE_HOT,
                                                           sec=5)
            outlet_temperature_value_on_page = self.find_element(ConfiguratorPptoLocators.LOCATOR_OUTLET_TEMPERATURE_HOT
                                                                 ).get_attribute('value')
            assert outlet_temperature_value_on_page == expected_outlet_temperature_hot_value, \
                f'Температура на выходе горячая на странице - ({outlet_temperature_value_on_page}) не соответствует ' \
                f'ожидаемой - ({expected_outlet_temperature_hot_value})'

    def checking_outlet_temperature_cold_value(self, expected_outlet_temperature_cold_value: str):
        """Проверка значения Температуры на выходе холодная"""
        with allure.step('Проверка значения Температуры на выходе холодная'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_OUTLET_TEMPERATURE_COLD,
                                                           sec=5)
            outlet_temperature_value_on_page = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_OUTLET_TEMPERATURE_COLD
            ).get_attribute('value')
            assert outlet_temperature_value_on_page == expected_outlet_temperature_cold_value, \
                f'Температура на входе холодная на странице - ({outlet_temperature_value_on_page}) не соответствует ' \
                f'ожидаемой - ({expected_outlet_temperature_cold_value})'

    def checking_inlet_steam_content_value(self, expected_inlet_steam_content_value: str):
        """Проверка значения Паросодержание на входе"""
        with allure.step('Проверка значения Паросодержание на входе'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_INPUT_INLET_STEAM_CONTENT,
                                                           sec=5)
            inlet_steam_content_value_on_page = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_INPUT_INLET_STEAM_CONTENT
            ).get_attribute('value')
            assert inlet_steam_content_value_on_page == expected_inlet_steam_content_value, \
                f'Значение Паросодержание на входе на странице - ({inlet_steam_content_value_on_page}) не соответствует ' \
                f'ожидаемому - ({expected_inlet_steam_content_value})'

    def checking_boiling_temperature_value(self, expected_boiling_temperature_value: str):
        """Проверка значения Температура кипения"""
        with allure.step('Проверка значения Температура кипения'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_INPUT_BOILING_TEMPERATURE,
                                                           sec=5)
            boiling_temperature_value_on_page = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_INPUT_BOILING_TEMPERATURE
            ).get_attribute('value')
            assert boiling_temperature_value_on_page == expected_boiling_temperature_value, \
                f'Значение Температура кипения на странице - ({boiling_temperature_value_on_page}) не соответствует ' \
                f'ожидаемому - ({expected_boiling_temperature_value})'

    def checking_overheat_value(self, expected_overheat_value: str):
        """Проверка значения Перегрев"""
        with allure.step('Проверка значения Перегрев'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_INPUT_OVERHEAT, sec=5)
            overheat_value_on_page = self.find_element(ConfiguratorPptoLocators.LOCATOR_INPUT_OVERHEAT
                                                       ).get_attribute('value')
            assert overheat_value_on_page == expected_overheat_value, \
                f'Значение Перегрев на странице - ({overheat_value_on_page}) не соответствует ожидаемому - ' \
                f'({expected_overheat_value})'

    def expense_hot_field_must_be_empty(self):
        """Поле Расход - тепло должно быть пустым"""
        with allure.step('Поле Расход - тепло должно быть пустым'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_INPUT_CONSUMPTION_HOT,
                                                           sec=5)
            expense_value = self.find_element(ConfiguratorPptoLocators.LOCATOR_INPUT_CONSUMPTION_HOT
                                              ).get_attribute('value')
            assert expense_value == '', f'Поле Расход Тепло не пустое - ({expense_value})'

    def expense_cold_field_must_be_empty(self):
        """Поле Расход - холод должно быть пустым"""
        with allure.step('Поле Расход - холод должно быть пустым'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_INPUT_CONSUMPTION_COLD,
                                                           sec=5)
            expense_value = self.find_element(ConfiguratorPptoLocators.LOCATOR_INPUT_CONSUMPTION_COLD
                                              ).get_attribute('value')
            assert expense_value == '', f'Поел Расход Холод не пустое - ({expense_value})'

    def checking_maximum_heat_pressure_loss_value(self, expected_maximum_heat_pressure_loss_value: str):
        """Проверка значения Максимальные потери давления Тепло"""
        with allure.step('Проверка значения Максимальные потери давления Тепло'):
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_INPUT_MAXIMUM_HEAT_PRESSURE_LOSS, sec=5)
            maximum_heat_pressure_loss_value_on_page = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_INPUT_MAXIMUM_HEAT_PRESSURE_LOSS).get_attribute('value')
            assert maximum_heat_pressure_loss_value_on_page == expected_maximum_heat_pressure_loss_value, \
                f'Значение Максимальные потери давления Тепло на странице - ({maximum_heat_pressure_loss_value_on_page}) ' \
                f'не соответствует ожидаемому - ({expected_maximum_heat_pressure_loss_value})'

    def checking_maximum_cold_pressure_loss_value(self, expected_maximum_cold_pressure_loss_value: str):
        """Проверка значения Максимальные потери давления Тепло"""
        with allure.step('Проверка значения Максимальные потери давления Тепло'):
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_INPUT_MAXIMUM_COLD_PRESSURE_LOSS, sec=5)
            maximum_heat_pressure_loss_value_on_page = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_INPUT_MAXIMUM_COLD_PRESSURE_LOSS).get_attribute('value')
            assert maximum_heat_pressure_loss_value_on_page == expected_maximum_cold_pressure_loss_value, \
                f'Значение Максимальные потери давления Холод на странице - ({maximum_heat_pressure_loss_value_on_page}) ' \
                f'не соответствует ожидаемому - ({expected_maximum_cold_pressure_loss_value})'

    def checking_maximum_working_pressure_value(self, expected_maximum_working_pressure_value: str):
        """Проверка значения Максимальное рабочее давление"""
        with allure.step('Проверка значения Максимальное рабочее давление'):
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_INPUT_MAXIMUM_WORKING_PRESSURE, sec=5)
            maximum_working_pressure_on_page = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_INPUT_MAXIMUM_WORKING_PRESSURE).get_attribute('value')
            assert maximum_working_pressure_on_page == expected_maximum_working_pressure_value, \
                f'Значение Максимальное рабочее давление на странице - ({maximum_working_pressure_on_page}) не ' \
                f'соответствует ожидаемому - ({expected_maximum_working_pressure_value})'

    def checking_surface_reserve_value(self, expected_surface_reserve_value: str):
        """Проверка значения Запас поверхности"""
        with allure.step('Проверка значения Запас поверхности'):
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_INPUT_SURFACE_RESERVE, sec=5)
            maximum_working_pressure_on_page = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_INPUT_SURFACE_RESERVE).get_attribute('value')
            assert maximum_working_pressure_on_page == expected_surface_reserve_value, \
                f'Значение Запс поверхности на странице - ({maximum_working_pressure_on_page}) не соответствует ' \
                f'ожидаемому - ({expected_surface_reserve_value})'

    def checking_flow_direction_value(self, expected_flow_direction: str):
        """Проверка значения Направление потоков"""
        with allure.step('Проверка значения Направление потоков'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_SELECT_FLOW_DIRECTION,
                                                           sec=5)
            flow_direction = self.find_element(ConfiguratorPptoLocators.LOCATOR_SELECT_FLOW_DIRECTION)
            select = Select(flow_direction)
            flow_direction = select.first_selected_option.text
            assert flow_direction == expected_flow_direction, \
                f'Значение Направление потоков на странице - ({flow_direction}) не соответствует ожидаемому ' \
                f'- ({expected_flow_direction})'

    def click_btn_select_pto(self):
        """Клик по кнопке Подобрать ПТО"""
        with allure.step('Клик по кнопке Подобрать ПТО'):
            self.expecting_clickability(ConfiguratorPptoLocators.LOCATOR_BUTTON_SELECT_PTO)
            btn_select_pto = self.find_element(ConfiguratorPptoLocators.LOCATOR_BUTTON_SELECT_PTO)
            self.click_js(btn_select_pto)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_H2_SOLUTIONS_FOUND, sec=5)
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_LINE_WITH_SOLUTION_FOUND,
                                                           sec=5)

    def revealing_details_of_first_solution_found(self):
        """Открытие деталей 1 -ого найденного решения"""
        with allure.step('Открытие деталей 1 -ого найденного решения'):
            self.expecting_clickability(ConfiguratorPptoLocators.LOCATOR_LINK_SOLUTION_DETAILS)
            link_solution_details = self.find_element(ConfiguratorPptoLocators.LOCATOR_LINK_SOLUTION_DETAILS)
            h2_to_scroll = self.find_element(ConfiguratorPptoLocators.LOCATOR_H2_SOLUTIONS_FOUND)
            self.scroll_to(h2_to_scroll)
            link_solution_details.click()
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_HEADER_IN_MODAL_SOLUTION_DETAILS)

    def close_modal_details_solution(self):
        """Закрытие модалки Детали решения"""
        with allure.step('Закрытие модалки Детали решения'):
            self.expecting_clickability(ConfiguratorPptoLocators.LOCATOR_BTN_CLOSE_IN_MODAL_SOLUTION_DETAILS)
            btn_close = self.find_element(ConfiguratorPptoLocators.LOCATOR_BTN_CLOSE_IN_MODAL_SOLUTION_DETAILS)
            btn_close.click()
            self.waiting_element_invisibility(ConfiguratorPptoLocators.LOCATOR_HEADER_IN_MODAL_SOLUTION_DETAILS)
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_H2_SOLUTIONS_FOUND, sec=5)

    def save_name_of_first_solution_found(self) -> str:
        """Сохранение названия первого найденного решения"""
        with allure.step('Сохранение названия первого найденного решения'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_NAME_OF_SOLUTION_FOUND)
            name_of_first_solution_found = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_NAME_OF_SOLUTION_FOUND).text
            return name_of_first_solution_found

    def click_btn_add_to_basket_first_calc(self):
        """Клик по кнопке добавить в корзину у первого расчета"""
        with allure.step('Клик по кнопке добавить в корзину у первого расчета'):
            self.expecting_clickability(ConfiguratorPptoLocators.LOCATOR_BTN_ADD_TO_BASKET)
            btn_add = self.find_element(ConfiguratorPptoLocators.LOCATOR_BTN_ADD_TO_BASKET)
            self.click_js(btn_add)
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_HEADER_IN_MODAL_ADD_TO_BASKET)

    def click_btn_add_to_basket_in_modal_add_to_basket(self):
        """Клик по кнопке Добавить в корзину в модалке добавления в корзину"""
        with allure.step('Клик по кнопке Добавить в корзину в модалке добавления в корзину'):
            self.expecting_clickability(ConfiguratorPptoLocators.LOCATOR_BTN_ADD_TO_BASKET_IN_MODAL_ADD_TO_BASKET)
            btn_add = self.find_element(ConfiguratorPptoLocators.LOCATOR_BTN_ADD_TO_BASKET_IN_MODAL_ADD_TO_BASKET)
            btn_add.click()
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_HEADER_ITEMS_ADDED_TO_CART,
                                                           sec=20)

    def click_btn_continue_shopping(self):
        """Клик по кнопке Продолжить покупки"""
        with allure.step('Клик по кнопке Продолжить покупки'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_BTN_CONTINUE_SHOPPING,
                                                           sec=15)
            time.sleep(1)
            btn_continue_shopping = self.find_element(ConfiguratorPptoLocators.LOCATOR_BTN_CONTINUE_SHOPPING)
            btn_continue_shopping.click()
            self.waiting_element_invisibility(ConfiguratorPptoLocators.LOCATOR_HEADER_ITEMS_ADDED_TO_CART, sec=5)

    def click_btn_save_calculation_first_calc_on_page(self):
        """Клик по кнопке Скачать расчет у первого расчета на странице"""
        with allure.step('Клик по кнопке Скачать расчет у первого расчета на странице'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_H2_SOLUTIONS_FOUND, sec=5)
            scroll_to = self.find_element(ConfiguratorPptoLocators.LOCATOR_H2_SOLUTIONS_FOUND)
            self.scroll_to(scroll_to)
            self.expecting_clickability(ConfiguratorPptoLocators.LOCATOR_BTN_SAVE_CALCULATION)
            btn_save_calc = self.find_element(ConfiguratorPptoLocators.LOCATOR_BTN_SAVE_CALCULATION)
            btn_save_calc.click()
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_HEADER_SAVE_CALC, sec=5)

    def entering_name_of_object_in_calculation_download_modal(self):
        """Ввод названия объекта в модалке скачивания расчета"""
        name_object = 'selenium_web_test'
        with allure.step(f'Ввод названия объекта {name_object} в модалке скачивания расчета'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_INPUT_NAME_OBJECT, sec=5)
            input_name_object = self.find_element(ConfiguratorPptoLocators.LOCATOR_INPUT_NAME_OBJECT)
            input_name_object.send_keys(name_object)
            entered_name_object = input_name_object.get_attribute('value')
            assert entered_name_object == name_object, \
                f'Введенное имя объекта в модалке скачивания расчета - ({entered_name_object}) не соответствует ' \
                f'ожидаемому - ({name_object})'

    def entering_description_to_calc(self):
        """Ввод описания к расчету"""
        description_to_calc = 'web_test_selenium_oppa'
        with allure.step(f'Ввод описания {description_to_calc} к расчету'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_DESCRIPTION_TO_CALC, sec=5)
            input_description_to_calc = self.find_element(ConfiguratorPptoLocators.LOCATOR_DESCRIPTION_TO_CALC)
            input_description_to_calc.send_keys(description_to_calc)
            entered_description_to_calc = input_description_to_calc.get_attribute('value')
            assert entered_description_to_calc == description_to_calc, \
                f'Введенное описание - ({entered_description_to_calc}) в модалке скачивания расчета не соответствует ' \
                f'ожидаемому - ({description_to_calc})'

    def click_btn_save_calc_in_modal_save_calc_for_evaporator(self, name_of_first_solution_found: str):
        """Клик по кнопке Скачать расчет в модалке скачивания расчета для испарителя
        name_of_first_solution_found - название первого найденного расчета
        """
        with allure.step(f'Клик по кнопке Скачать расчет в модалке скачивания расчета для испарителя. Имя расчета - '
                         f'{name_of_first_solution_found}'):
            name_of_first_solution_found = name_of_first_solution_found.replace('Артикул: ', '')
            expected_name_file = f'{name_of_first_solution_found}.pdf'

            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_BTN_SAVE_CALC_IN_MODAL_SAVE_CALC, sec=10)
            btn_save = self.find_element(ConfiguratorPptoLocators.LOCATOR_BTN_SAVE_CALC_IN_MODAL_SAVE_CALC)
            btn_save.click()
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.checking_the_download_document_in_the_download_folder(expected_name_file)
            self.delete_file_by_name_in_download_folder(expected_name_file)

    def click_btn_save_calc_in_modal_save_calc_for_single_phase(self, name_of_first_solution_found: str):
        """Клик по кнопке Скачать расчет в модалке скачивания расчета для однофазного
        name_of_first_solution_found - название первого найденного расчета
        """
        with allure.step(f'Клик по кнопке Скачать расчет в модалке скачивания расчета для однофазного. Имя расчета - '
                         f'{name_of_first_solution_found}'):
            name_of_first_solution_found = name_of_first_solution_found.replace('Артикул: ', '')
            expected_name_file = f'{name_of_first_solution_found}.pdf'
            # characters_to_delete = [',', '(', ')', '/', '*', '"']
            # for el in characters_to_delete:
            #     if el in expected_name_file:
            #         expected_name_file = expected_name_file.replace(el, '')
            #
            # # Заменяем символ '_' во втором вхождении в строку
            # sub_sting = '_'
            # count = 0
            # for idx, el in enumerate(expected_name_file):
            #     if sub_sting == el:
            #         count += 1
            #     elif count == 2:
            #         expected_name_file = expected_name_file[0:idx - 1] + '-' + expected_name_file[idx:]
            #         count = 0

            self.delete_file_by_name_in_download_folder(expected_name_file)

            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_BTN_SAVE_CALC_IN_MODAL_SAVE_CALC, sec=10)
            btn_save = self.find_element(ConfiguratorPptoLocators.LOCATOR_BTN_SAVE_CALC_IN_MODAL_SAVE_CALC)
            btn_save.click()
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.checking_the_download_document_in_the_download_folder(expected_name_file)
            self.delete_file_by_name_in_download_folder(expected_name_file)

    def go_to_title_design_calculations_single_phase(self):
        """Переход на вкладку Конструкторский расчет - однофазный"""
        with allure.step('Переход на вкладку Конструкторский расчет - однофазный'):
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_BTN_DESIGN_CALCULATIONS_SINGLE_PHASE, sec=5)
            btn_design_calculations_single_phase = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_BTN_DESIGN_CALCULATIONS_SINGLE_PHASE)
            btn_design_calculations_single_phase.click()
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_BTN_DESIGN_CALCULATIONS_SINGLE_PHASE_ACTIVE)

    def click_btn_create_a_questionnaire(self):
        """Клик по кнопке Сформировать опросный лист"""
        with allure.step('Клик по кнопке Сформировать опросный лист'):
            scroll_to = self.find_element(ConfiguratorPptoLocators.LOCATOR_INPUT_MAXIMUM_HEAT_PRESSURE_LOSS)
            self.scroll_to(scroll_to)
            self.expecting_clickability(ConfiguratorPptoLocators.LOCATOR_BTN_CREATE_A_QUESTIONNAIRE)
            btn_create_a_questionnaire = self.find_element(ConfiguratorPptoLocators.LOCATOR_BTN_CREATE_A_QUESTIONNAIRE)
            btn_create_a_questionnaire.click()
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_H2_CREATE_A_QUESTIONNAIRE,
                                                           sec=10)

    def checking_your_name_in_name_input_field(self, expected_full_name: str):
        """Проверка фио в поле ввода фио"""
        with allure.step('Проверка фио в поле ввода фио'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_INPUT_FULL_NAME, sec=5)
            full_name_on_page = self.find_element(ConfiguratorPptoLocators.LOCATOR_INPUT_FULL_NAME
                                                  ).get_attribute('value')
            assert full_name_on_page == expected_full_name, \
                f'ФИО на странице - ({expected_full_name}) не соответствует ожидаемому ФИО - ({expected_full_name})'

    def checking_e_mail_address_in_input_email(self, expected_e_mail_address: str):
        """Проверка электронного адреса в поле ввода эл. адреса"""
        with allure.step('Проверка электронного адреса в поле ввода эл. адреса'):
            self.waiting_element_is_visibility_on_the_page(ConfiguratorPptoLocators.LOCATOR_INPUT_E_MAIL_ADDRESS, sec=5)
            e_email_on_page = self.find_element(ConfiguratorPptoLocators.LOCATOR_INPUT_E_MAIL_ADDRESS
                                                ).get_attribute('value')
            assert e_email_on_page == expected_e_mail_address, \
                f'Эл-ый адрес на странице - ({e_email_on_page}) не соответствует ожидаемому - ({expected_e_mail_address})'

    def phone_input(self):
        """Ввод номера телефона"""
        with allure.step('Ввод номера телефона'):
            number_phone = self.generation_phone()

            number_phone = ''.join(filter(str.isdigit, number_phone))  # Убираем все символы кроме цифр
            number_phone = number_phone[1:]

            self.expecting_clickability(ConfiguratorPptoLocators.LOCATOR_INPUT_PHONE)
            phone_input = self.find_element(ConfiguratorPptoLocators.LOCATOR_INPUT_PHONE)
            phone_input.click()
            phone_input.clear()
            phone_input.send_keys(number_phone)
            entered_phone = phone_input.get_attribute('value')
            entered_phone = ''.join(filter(str.isdigit, entered_phone))  # Убираем все символы кроме цифр

            assert entered_phone == number_phone, \
                f'Введенный номер телефона - ({entered_phone}) не соответствует ожидаемому - ({number_phone})'

    def checking_value_in_field_split_specified_load_into(self, expected_value: str):
        """Проверка значения в поле Разбить указанную нагрузку на"""
        with allure.step('Проверка значения в поле Разбить указанную нагрузку на'):
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_INPUT_DIVIDE_SPECIFIED_LOAD_INTO, sec=5)
            value_on_page = self.find_element(ConfiguratorPptoLocators.LOCATOR_INPUT_DIVIDE_SPECIFIED_LOAD_INTO
                                              ).get_attribute('value')
            assert value_on_page == expected_value, \
                f'Значение на странице - ({value_on_page}) в поле Разбить указанную нагрузку на не соответствует ' \
                f'ожидаемому - ({expected_value})'

    def checking_value_in_number_of_bphe_with_specified_load_field(self, expected_value: str):
        """Проверка значения в поле Количество ППТО с указанной нагрузкой"""
        with allure.step('Проверка значения в поле Количество ППТО с указанной нагрузкой'):
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_INPUT_NUMBER_OF_BPHE_WITH_SPECIFIED_LOAD, sec=5)
            value_on_page = self.find_element(ConfiguratorPptoLocators.LOCATOR_INPUT_NUMBER_OF_BPHE_WITH_SPECIFIED_LOAD
                                              ).get_attribute('value')
            assert value_on_page == expected_value, \
                f'Значение на странице - ({value_on_page}) в поле Количество ППТО с указанной нагрузкой не соответствует ' \
                f'ожидаемому - ({expected_value})'

    def selecting_check_box_for_consent_to_processing_of_personal_data(self):
        """Выбор чек-бокса 'Я согласен на обработку персональных данных'"""
        with allure.step('Выбор чек-бокса "Я согласен на обработку персональных данных"'):
            self.expecting_clickability(ConfiguratorPptoLocators.LOCATOR_CHECK_BOX_PROCESSING_OF_PERSONAL_DATA, sec=5)
            check_box_processing_of_personal_data = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_CHECK_BOX_PROCESSING_OF_PERSONAL_DATA)
            check_box_processing_of_personal_data.click()
            is_selected_check_box = check_box_processing_of_personal_data.is_selected()
            assert is_selected_check_box is True, \
                f'Чек - бокс Я согласен на обработку персональных данных не выбран. {is_selected_check_box}'

    def click_btn_send_to_technical_support(self):
        """Клик по кнопке Отправить в техническую поддержку"""
        with allure.step('Клик по кнопке Отправить в техническую поддержку'):
            self.expecting_clickability(ConfiguratorPptoLocators.LOCATOR_BTN_SEND_TO_TECHNICAL_SUPPORT)
            btn_send_to_technical_support = self.find_element(
                ConfiguratorPptoLocators.LOCATOR_BTN_SEND_TO_TECHNICAL_SUPPORT)
            self.scroll_to_elem_perform(btn_send_to_technical_support)
            self.expecting_clickability(ConfiguratorPptoLocators.LOCATOR_BTN_SEND_TO_TECHNICAL_SUPPORT)
            btn_send_to_technical_support.click()
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT, sec=90)
            self.waiting_element_is_visibility_on_the_page(
                ConfiguratorPptoLocators.LOCATOR_HEADER_IN_MODAL_THANKS_FOR_REACHING_OUT, sec=30)
