import allure
from selenium.webdriver.support.select import Select

from base_page.base_page import BasePage
from base_page.base_page_locators import BaseOpenLocators
from open_pages.cart_page.cart_locators import CartLocators
from open_pages.selection_online_tools_all.tdu_select.selection_of_tdu_distribution_unit_locators import \
    SelectionOfTduDistributionUnitLocators, DistributionNodeTduLocators


@allure.feature('Подбор распределительного узла TDU')
class SelectionOfTduDistributionUnitPage(BasePage):
    """Подбор распределительного узла TDU"""

    def checking_selected_collector_type(self, expected_collector_type: str):
        """Проверка выбранного типа коллектора"""
        with allure.step(f'Проверка выбранного типа коллектора'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_COLLECTOR_TYPE, sec=5)
            collector_type_on_page = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_COLLECTOR_TYPE)
            select = Select(collector_type_on_page)
            collector_type_on_page = select.first_selected_option.text
            assert collector_type_on_page == expected_collector_type, \
                f'Выбранный тип коллектора - ({collector_type_on_page}) на странице не соответствует ожидаемому - ' \
                f'({expected_collector_type})'

    def checking_selected_riser_location(self, expected_riser_location: str):
        """Проверка выбранного Расположения стояка"""
        with allure.step('Проверка выбранного Расположения стояка'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_RISER_LOCATION, sec=5)
            riser_location_on_page = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_RISER_LOCATION)
            select = Select(riser_location_on_page)
            riser_location_on_page = select.first_selected_option.text
            assert riser_location_on_page == expected_riser_location, \
                f'Выбранное расположение стояка - ({riser_location_on_page}) на странице не соответствует ожидаемому - ' \
                f'({expected_riser_location})'

    def checking_selected_diameter_of_connection_to_riser(self, expected_diameter_of_connection_to_riser: str):
        """Проверка выбранного Диаметра присоединения к стояку"""
        with allure.step('Проверка выбранного Диаметра присоединения к стояку'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_DIAMETER_OF_CONNECTION_TO_RISER, sec=5)
            diameter_of_connection_to_riser_on_page = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_DIAMETER_OF_CONNECTION_TO_RISER)
            select = Select(diameter_of_connection_to_riser_on_page)
            diameter_of_connection_to_riser_on_page = select.first_selected_option.text
            assert diameter_of_connection_to_riser_on_page == expected_diameter_of_connection_to_riser, \
                f'Выбранное расположение стояка - ({diameter_of_connection_to_riser_on_page}) на странице не ' \
                f'соответствует ожидаемому - ({expected_diameter_of_connection_to_riser})'

    def checking_selected_manual_balancing_valve_at_manifold_inlet(
            self, expected_manual_balancing_valve_at_manifold_inlet: str):
        """Проверка выбранного значения Ручной балансировочный клапан на вводе коллектора"""
        with allure.step('Проверка выбранного значения Ручной балансировочный клапан на вводе коллектора'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_MANUAL_BALANCING_VALVE_AT_MANIFOLD_INLET, sec=5)
            manual_balancing_valve_at_manifold_inlet_on_page = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_MANUAL_BALANCING_VALVE_AT_MANIFOLD_INLET)
            select = Select(manual_balancing_valve_at_manifold_inlet_on_page)
            manual_balancing_valve_at_manifold_inlet_on_page = select.first_selected_option.text
            assert manual_balancing_valve_at_manifold_inlet_on_page == expected_manual_balancing_valve_at_manifold_inlet, \
                f'Выбранное значение Ручной балансировочный клапан на вводе коллектора - ' \
                f'({manual_balancing_valve_at_manifold_inlet_on_page}) на странице не соответствует ожидаемому - ' \
                f'({expected_manual_balancing_valve_at_manifold_inlet})'

    def checking_selected_number_of_branches_to_apartments(self, expected_number_of_branches_to_apartments: str):
        """Проверка выбранного значения Количество отводов к квартирам"""
        with allure.step('Проверка выбранного значения Количество отводов к квартирам'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_NUMBER_OF_BRANCHES_TO_APARTMENTS, sec=5)
            number_of_branches_to_apartments_on_page = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_NUMBER_OF_BRANCHES_TO_APARTMENTS)
            select = Select(number_of_branches_to_apartments_on_page)
            number_of_branches_to_apartments_on_page = select.first_selected_option.text
            assert number_of_branches_to_apartments_on_page == expected_number_of_branches_to_apartments, \
                f'Выбранное значение Количество отводов к квартирам - ({number_of_branches_to_apartments_on_page}) на ' \
                f'странице не соответствует ожидаемому - ({expected_number_of_branches_to_apartments})'

    def checking_selected_balancing_valve_on_outlet(self, expected_balancing_valve_on_outlet: str):
        """Проверка выбранного значения Балансировочный клапан на отводе"""
        with allure.step('Проверка выбранного значения Балансировочный клапан на отводе'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_BALANCING_VALVE_ON_OUTLET, sec=5)
            balancing_valve_on_outlet_on_page = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_BALANCING_VALVE_ON_OUTLET)
            select = Select(balancing_valve_on_outlet_on_page)
            balancing_valve_on_outlet_on_page = select.first_selected_option.text
            assert balancing_valve_on_outlet_on_page == expected_balancing_valve_on_outlet, \
                f'Выбранное значение Балансировочный клапан на отводе - ({balancing_valve_on_outlet_on_page}) на ' \
                f'странице не соответствует ожидаемому - ({expected_balancing_valve_on_outlet})'

    def click_btn_get_selection_results(self):
        """Клик по кнопке Получить результаты подбора"""
        with allure.step('Клик по кнопке Получить результаты подбора'):
            scroll_to = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_BALANCING_VALVE_ON_OUTLET)
            self.scroll_to(scroll_to)
            self.expecting_clickability(SelectionOfTduDistributionUnitLocators.LOCATOR_BTN_GET_SELECTION_RESULTS)
            btn_get_selection_results = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_BTN_GET_SELECTION_RESULTS)
            btn_get_selection_results.click()
            self.switching_window(-1)
            self.waiting_element_is_visibility_on_the_page(DistributionNodeTduLocators.LOCATOR_HEADER, sec=30)

    def article_in_selection_results_should_not_be_empty(self):
        """Артикул в результатах подбора не должен быть пустым"""
        with allure.step('Артикул в результатах подбора не должен быть пустым'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_ARTICLE_IN_SELECTION_RESULTS, sec=5)
            article_in_selection_results = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_ARTICLE_IN_SELECTION_RESULTS).text
            assert article_in_selection_results != '', f'Строка с Артикулом в результате подбора пустая - ' \
                                                       f'({article_in_selection_results})'

    def name_in_selection_results_should_not_be_empty(self):
        """Наименование в результатах подбора не должен быть пустым"""
        with allure.step('Наименование в результатах подбора не должен быть пустым'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_NAME_IN_SELECTION_RESULTS, sec=5)
            name_in_selection_results = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_NAME_IN_SELECTION_RESULTS).text
            assert name_in_selection_results != '', f'Строка с наименованием в результате подбора пустая - ' \
                                                    f'({name_in_selection_results})'

    def price_with_nds_in_selection_results_should_not_be_empty(self):
        """Цена с НДС в результатах подбора не должен быть пустым"""
        with allure.step('Цена с НДС в результатах подбора не должен быть пустым'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_PRICE_WITH_NDS, sec=5)
            price_with_nds_in_selection_results = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_PRICE_WITH_NDS).text
            assert price_with_nds_in_selection_results != '', f'Строка с ценой с НДС в результате подбора пустая - ' \
                                                              f'({price_with_nds_in_selection_results})'

    def selection_number_of_outlets_to_apartments(self, number_of_branches_to_apartments: str):
        """Выбор Количество отводов к квартирам"""
        with allure.step(f'Выбор Количество отводов к квартирам - {number_of_branches_to_apartments}'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_NUMBER_OF_BRANCHES_TO_APARTMENTS, sec=5)
            select_number_of_branches_to_apartments = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_SELECT_NUMBER_OF_BRANCHES_TO_APARTMENTS)
            select = Select(select_number_of_branches_to_apartments)
            select.select_by_value(number_of_branches_to_apartments)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            selected_number_of_branches_to_apartments = select.first_selected_option.text
            assert selected_number_of_branches_to_apartments == number_of_branches_to_apartments, \
                f'Выбранное значение Количество отводов к квартирам - ({selected_number_of_branches_to_apartments}) на ' \
                f'странице не соответствует ожидаемому - ({number_of_branches_to_apartments})'

    def save_article_as_a_result_of_selection(self) -> str:
        """Сохранение артикула в результате подбора"""
        with allure.step('Сохранение артикула в результате подбора'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_ARTICLE_IN_SELECTION_RESULTS, sec=5)
            article = self.find_element(
                SelectionOfTduDistributionUnitLocators.LOCATOR_ARTICLE_IN_SELECTION_RESULTS).text
            return article

    def save_name_tdu_as_a_result_of_selection(self) -> str:
        """Сохранение наименования ТДУ в результате подбора"""
        with allure.step('Сохранение наименования ТДУ в результате подбора'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_NAME_IN_SELECTION_RESULTS, sec=5)
            name_tdu = self.find_element(SelectionOfTduDistributionUnitLocators.LOCATOR_NAME_IN_SELECTION_RESULTS).text
            return name_tdu

    def save_price_with_nds_as_a_result_of_selection(self) -> float:
        """Сохранение цены с НДС в результате подбора"""
        with allure.step('Сохранение цены с НДС в результате подбора'):
            self.waiting_element_is_visibility_on_the_page(
                SelectionOfTduDistributionUnitLocators.LOCATOR_PRICE_WITH_NDS,
                sec=5)
            price_with_nds = self.find_element(SelectionOfTduDistributionUnitLocators.LOCATOR_PRICE_WITH_NDS
                                               ).text.split(' ')[0]
            price_with_nds = float(price_with_nds.replace(',', '.'))
            return price_with_nds


@allure.feature('Страница Распределительный узел ТДУ')
class DistributionNodeTduPage(BasePage):
    """Страница Распределительный узел ТДУ"""

    def name_of_tdu_must_correspond_to_what_is_expected(self, expected_name_tdu: str):
        """Наименование тду должно соответствовать ожидаемому"""
        with allure.step('Наименование тду должно соответствовать ожидаемому'):
            self.waiting_element_is_visibility_on_the_page(DistributionNodeTduLocators.LOCATOR_NAME_TDU, sec=5)
            name_tdu_on_page = self.find_element(DistributionNodeTduLocators.LOCATOR_NAME_TDU).text
            assert name_tdu_on_page == expected_name_tdu, \
                f'Наименование ТДУ на странице Распределительный узел - ({name_tdu_on_page}) не соответствует ожидаемому' \
                f' - ({expected_name_tdu})'

    def price_with_nds_of_tdu_must_correspond_to_what_is_expected(self, expected_price_with_nds_tdu: float):
        """Цена с НДС ТДУ должно соответствовать ожидаемой"""
        with allure.step('Цена с НДС ТДУ должно соответствовать ожидаемой'):
            self.waiting_element_is_visibility_on_the_page(DistributionNodeTduLocators.LOCATOR_PRICE_WITH_NDS, sec=5)
            price_tdu_on_page = self.find_element(DistributionNodeTduLocators.LOCATOR_PRICE_WITH_NDS).text.split(' ')[0]
            price_tdu_on_page = float(price_tdu_on_page)
            assert abs(price_tdu_on_page - expected_price_with_nds_tdu) < 0.1, \
                f'Цена с НДС ТДУ на странице Распределительный узел - ({price_tdu_on_page}) не соответствует ожидаемой' \
                f' - ({expected_price_with_nds_tdu})'

    def article_of_tdu_must_correspond_to_what_is_expected(self, expected_article: str):
        """Артикул ТДУ должен соответствовать ожидаемому"""
        with allure.step('Артикул ТДУ должен соответствовать ожидаемому'):
            self.waiting_element_is_visibility_on_the_page(DistributionNodeTduLocators.LOCATOR_ARTICLE, sec=5)
            article_tdu_on_page = self.find_element(DistributionNodeTduLocators.LOCATOR_ARTICLE).text
            assert article_tdu_on_page == expected_article, \
                f'Артикул ТДУ на странице Распределительный узел - ({article_tdu_on_page}) не соответствует ожидаемой' \
                f' - ({expected_article})'

    def click_btn_added_to_basket(self, expected_price: float):
        """Клик по кнопке Добавить в корзину"""
        with allure.step('Клик по кнопке Добавить в корзину'):
            self.waiting_element_is_visibility_on_the_page(DistributionNodeTduLocators.LOCATOR_BTN_ADDED_TO_BASKET,
                                                           sec=5)
            btn_added_to_basket = self.find_element(DistributionNodeTduLocators.LOCATOR_BTN_ADDED_TO_BASKET)
            btn_added_to_basket.click()
            self.waiting_element_is_visibility_on_the_page(
                DistributionNodeTduLocators.LOCATOR_HEADER_SELECT_QUANTITY_OF_PRODUCTS, sec=10)
            price_in_modal = self.find_element(DistributionNodeTduLocators.LOCATOR_PRICE_IN_MODAL_ADDED_TO_BASKET
                                               ).text.replace(' ', '')
            price_in_modal = float(price_in_modal)
            assert price_in_modal == expected_price, \
                f'Цена в модалке добавления товара - ({price_in_modal}) не соответствует ожидаемой цене со страницы ' \
                f'Распределительный узел - ({expected_price})'

    def click_btn_add_to_basket_in_modal_added_to_basket(self):
        """Клик по кнопке Добавить в корзину в модалке добавления в корзину"""
        with allure.step('Клик по кнопке Добавить в корзину в модалке добавления в корзину'):
            self.expecting_clickability(
                DistributionNodeTduLocators.LOCATOR_BTN_ADDED_TO_BASKET_IN_MODAL_ADDED_TO_BASKET)
            btn_added_to_basket = self.find_element(
                DistributionNodeTduLocators.LOCATOR_BTN_ADDED_TO_BASKET_IN_MODAL_ADDED_TO_BASKET)
            btn_added_to_basket.click()
            self.waiting_element_is_visibility_on_the_page(
                DistributionNodeTduLocators.LOCATOR_HEADER_IN_MODAL_ITEMS_ADDED_TO_CART, sec=10)

    def click_btn_go_to_basket_in_modal_items_added_to_cart(self):
        """Клик по кнопке Перейти в корзину в модалке Товары добавлены в корзину"""
        with allure.step('Клик по кнопке Перейти в корзину в модалке Товары добавлены в корзину'):
            self.waiting_element_is_visibility_on_the_page(DistributionNodeTduLocators.LOCATOR_BTN_GO_TO_BASKET, sec=5)
            btn_go_to_basket = self.find_element(DistributionNodeTduLocators.LOCATOR_BTN_GO_TO_BASKET)
            btn_go_to_basket.click()
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_H1_BASKET)

    @staticmethod
    def checking_whether_an_item_has_been_added_to_cart(expected_article: str, article_on_page_cart: list):
        """Проверка добавления артикула в корзину"""
        with allure.step(f'Проверка добавления артикула {article_on_page_cart} в корзину'):
            assert len(article_on_page_cart) == 1, f'Количество линий артикулов на странице Корзина больше 1 - ' \
                                                   f'({len(article_on_page_cart)})'
            article_on_page_cart = article_on_page_cart[0]
            assert article_on_page_cart == expected_article, \
                f'Артикул в корзине - ({article_on_page_cart}) не соответствует ожидаемому - ({expected_article})'
