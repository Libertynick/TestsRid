
from selenium.webdriver.common.by import By
from selenium.common import NoSuchElementException
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys
import allure
import time
from open_pages.btp_service_page.btp_service_locators import AuthPageLocators, BTPServicePageLocators
from base_page.base_page import BasePage
from config import TestEnvironment
from tools.logger import btp_logger as logger
from bs4 import BeautifulSoup


class AuthPage(BasePage):
    """Класс страницы авторизации"""

    def __init__(self, browser, url=TestEnvironment.BTP_BASE_URL):
        """Инициализация страницы авторизации"""
        super().__init__(browser, url)
        logger.info("Инициализирована страница авторизации")

    @allure.step("Авторизация в системе, номер заказа: {order_number}")
    def login(self, order_number=TestEnvironment.BTP_DEFAULT_ORDER_NUMBER, pin_code=TestEnvironment.BTP_DEFAULT_PIN_CODE):
        """Авторизация в системе с улучшенным ожиданием лоадера"""
        logger.info(f"Начало авторизации с данными: {order_number}/{pin_code}")
        self.open()

        with allure.step("Ожидание загрузки страницы авторизации"):
            self.waiting_element_is_visibility_located_dom(AuthPageLocators.ORDER_NUMBER_INPUT)
            logger.debug("Страница авторизации загружена")

        with allure.step(f"Ввод номера заказа: {order_number}"):
            order_input = self.find_element(AuthPageLocators.ORDER_NUMBER_INPUT)
            order_input.clear()
            order_input.send_keys(order_number)
            logger.debug(f"Введен номер заказа: {order_number}")

        with allure.step(f"Ввод пин-кода: {pin_code}"):
            pin_input = self.find_element(AuthPageLocators.PIN_CODE_INPUT)
            pin_input.clear()
            pin_input.send_keys(pin_code)
            logger.debug(f"Введен пин-код: {pin_code}")

        with allure.step("Нажатие кнопки входа"):
            self.find_element(AuthPageLocators.SUBMIT_BUTTON).click()
            logger.debug("Кнопка входа нажата")

        # Ожидаем исчезновение лоадера с таймаутом 60 секунд
        with allure.step("Ожидание исчезновения лоадера и загрузки страницы"):
            self._wait_for_spinner_border_disappear(60)
            logger.debug("Лоадер исчез, страница загружается...")

        try:
            with allure.step("Ожидание загрузки страницы заказа"):
                self.waiting_element_is_visibility_located_dom(
                    (By.XPATH, "//div[@class='fs-5 fw-bold'][contains(text(), 'Номер заказа')]"),
                    sec=20
                )
                logger.debug("Страница заказа загружена")
        except Exception:
            logger.error("Ошибка авторизации: не удалось загрузить страницу заказа")
            return False

        # Ждем стабилизации URL
        with allure.step(f"Ожидание перехода на URL заказа: {order_number}"):
            wait = WebDriverWait(self.driver, TestEnvironment.BROWSER_TIMEOUT)
            wait.until(EC.url_contains(f"/{order_number}"))
            logger.debug(f"URL содержит номер заказа: {order_number}")

        # Проверяем, что авторизация успешна
        current_url = self.driver.current_url
        success = current_url == f"{TestEnvironment.BTP_BASE_URL}/{order_number}"

        if success:
            logger.info(f"Авторизация успешна: {current_url}")
        else:
            logger.error(
                f"Авторизация не удалась. Текущий URL: {current_url}, ожидаемый: {TestEnvironment.BTP_BASE_URL}/{order_number}")

        return success

    def _wait_for_spinner_border_disappear(self, timeout_seconds=60):
        """
        Ожидание исчезновения лоадера с классом spinner-border.

        Args:
            timeout_seconds: Максимальное время ожидания в секундах
        """
        logger.info(f"Ожидание исчезновения лоадера spinner-border (таймаут: {timeout_seconds} сек)")

        try:
            # Используем явное ожидание с увеличенным таймаутом
            wait = WebDriverWait(self.driver, timeout_seconds)
            wait.until(EC.invisibility_of_element_located((By.CSS_SELECTOR, "div.spinner-border")))
            logger.info("Лоадер spinner-border исчез")
            return True
        except Exception as e:
            logger.warning(f"Проблема при ожидании исчезновения лоадера spinner-border: {e}")

            # Проверяем, может страница уже загрузилась, несмотря на проблему с ожиданием лоадера
            try:
                header_present = self.driver.find_elements(
                    By.XPATH, "//div[@class='fs-5 fw-bold'][contains(text(), 'Номер заказа')]"
                )
                if header_present:
                    logger.info(
                        "Несмотря на проблему с лоадером, страница, похоже, загрузилась (найден заголовок заказа)")
                    return True
            except:
                pass

            return False


class BTPServicePage(BasePage):
    """Класс страницы сервиса БТП"""

    def __init__(self, browser, json_handler=None, order_number=None):
        """Инициализация страницы сервиса БТП"""
        super().__init__(browser, TestEnvironment.BTP_BASE_URL)
        self.json_handler = json_handler
        self.order_number = order_number
        # Кэш для часто используемых данных
        self._cache = {}
        logger.info(f"Инициализирована страница BTPServicePage с заказом {order_number}")

    @allure.step("Установка обработчика JSON")
    def set_json_handler(self, json_handler):
        """Установка обработчика JSON для проверок"""
        self.json_handler = json_handler
        # Сбрасываем кэш при изменении обработчика
        self._cache = {}
        logger.info("Установлен JSON обработчик для страницы BTP")

    @allure.step("Установка номера заказа: {order_number}")
    def set_order_number(self, order_number):
        """Установка номера заказа для проверок"""
        self.order_number = order_number
        logger.info(f"Установлен номер заказа: {order_number}")

    @allure.step("Получение номера заказа со страницы")
    def get_order_number(self):
        """Получение номера заказа со страницы"""
        order_number_elem = self.find_element(BTPServicePageLocators.ORDER_NUMBER_HEADER)
        order_number = order_number_elem.text.strip()
        logger.info(f"Получен номер заказа со страницы: {order_number}")
        return order_number

    @allure.step("Получение статуса заказа со страницы")
    def get_order_status(self):
        """Получение статуса заказа со страницы"""
        logger.info("Получение статуса заказа со страницы")
        try:
            # Находим блок "Актуальный статус заказа"
            status_block = self.driver.find_element(By.XPATH,
                                                    "//p[contains(text(), 'Актуальный статус заказа')]/following-sibling::ul[@class='list-unstyled']")
            logger.debug("Найден блок статуса заказа")

            # Получаем элементы li из найденного списка
            status_items = status_block.find_elements(By.TAG_NAME, "li")
            logger.debug(f"Найдено {len(status_items)} элементов статуса")

            statuses = []
            for item in status_items:
                # Получаем текст и удаляем часть "подробнее"
                status_text = item.text.strip()
                if "\nподробнее" in status_text:
                    status_text = status_text.replace("\nподробнее", "")
                statuses.append(status_text)
                logger.debug(f"Получен статус: {status_text}")

            return statuses
        except NoSuchElementException:
            logger.warning("Не найден блок статуса заказа, использую запасной вариант")
            # Запасной вариант: ищем просто первый список list-unstyled на странице
            try:
                first_list = self.driver.find_element(By.CSS_SELECTOR, "ul.list-unstyled")
                status_items = first_list.find_elements(By.TAG_NAME, "li")
                statuses = []
                for item in status_items:
                    # Получаем текст и удаляем часть "подробнее"
                    status_text = item.text.strip()
                    if "\nподробнее" in status_text:
                        status_text = status_text.replace("\nподробнее", "")
                    statuses.append(status_text)
                    logger.debug(f"Получен статус (запасной вариант 1): {status_text}")
                return statuses
            except NoSuchElementException:
                logger.warning("Не найден список статусов, использую второй запасной вариант")
                # Крайний случай - используем оригинальный локатор
                status_items = self.find_elements(BTPServicePageLocators.STATUS_ITEMS)
                statuses = []
                for item in status_items:
                    status_text = item.text.strip()
                    if "\nподробнее" in status_text:
                        status_text = status_text.replace("\nподробнее", "")
                    statuses.append(status_text)
                    logger.debug(f"Получен статус (запасной вариант 2): {status_text}")
                return statuses

    @allure.step("Получение списка артикулов со страницы")
    def get_articles(self):
        """Получение списка артикулов со страницы"""
        logger.info("Получение списка артикулов со страницы")

        # Используем кэш, если данные уже получены
        if 'articles' in self._cache:
            logger.debug("Используются кэшированные артикулы")
            return self._cache['articles']

        articles = []

        # Находим все элементы аккордеона с артикулами
        with allure.step("Поиск элементов аккордеона с артикулами"):
            accordion_items = self.find_elements(BTPServicePageLocators.ARTICLE_ACCORDION_ITEMS)
            logger.debug(f"Найдено {len(accordion_items)} элементов аккордеона")

        for item in accordion_items:
            try:
                # Ищем номер артикула в заголовке каждого аккордеона
                article_element = item.find_element(*BTPServicePageLocators.ARTICLE_HEADERS)
                article_number = article_element.text.strip()

                if article_number:
                    articles.append(article_number)
                    logger.debug(f"Найден артикул: {article_number}")
            except NoSuchElementException:
                logger.warning("Не удалось найти заголовок артикула в элементе аккордеона")
                continue

        logger.info(f"Всего получено {len(articles)} артикулов со страницы")

        # Сохраняем в кэше
        self._cache['articles'] = articles
        return articles

    @allure.step("Закрытие попапа")
    def close_popup(self):
        """Закрывает попап, если он открыт."""
        logger.info("Попытка закрыть попап, если он открыт")
        try:
            # Проверяем, есть ли открытый попап
            popup_elements = self.driver.find_elements(*BTPServicePageLocators.POPUP_DIALOG)
            if len(popup_elements) > 0 and popup_elements[0].is_displayed():
                logger.debug("Найден открытый попап")
                close_button = popup_elements[0].find_element(*BTPServicePageLocators.POPUP_CLOSE_BUTTON)
                close_button.click()
                logger.debug("Нажата кнопка закрытия")

                # Ждем исчезновения попапа
                wait = WebDriverWait(self.driver,TestEnvironment.BROWSER_TIMEOUT)
                wait.until(EC.invisibility_of_element_located(BTPServicePageLocators.POPUP_DIALOG))
                logger.info("Попап успешно закрыт")
                return True
        except Exception as e:
            logger.warning(f"Ошибка при закрытии попапа: {e}")
            pass

        logger.debug("Открытый попап не найден или уже закрыт")
        return False

    # Основные методы для проверки всех этапов

    @allure.step("Проверка этапов для всех артикулов")
    def verify_stages_one_by_one(self):
        """
        Сверхбыстрая проверка этапов для всех артикулов.
        Получает все содержимое всех аккордеонов за один раз без открытия,
        затем анализирует данные в памяти Python.
        """
        if not self.json_handler:
            logger.error("JSON обработчик не установлен")
            raise ValueError("JSON обработчик не установлен")

        logger.info("Начинаем сверхбыструю проверку этапов без открытия аккордеонов...")

        # 1. Получаем данные из JSON
        with allure.step("Получение данных о этапах из JSON"):
            json_data = self._get_json_stages_data()
            logger.debug(f"Собрано из JSON: {len(json_data)} артикулов")

        # 2. Получаем данные со страницы
        with allure.step("Получение HTML содержимого страницы"):
            page_html = self._get_html_content()
            logger.debug(f"Получен HTML страницы размером {len(page_html)} символов")

        # 3. Извлекаем данные из HTML
        with allure.step("Извлечение данных о этапах из HTML"):
            page_data = self._parse_html_for_stages(page_html)
            logger.info(f"Обработка HTML завершена, собраны данные для: {len(page_data)} артикулов")

        # 4. Сравниваем данные и формируем отчет
        with allure.step("Сравнение данных и формирование отчета"):
            results = self._compare_and_report_stages(json_data, page_data)

        # Определяем общий результат
        all_match = all(r['match'] for r in results)

        # Выводим общую статистику
        logger.info("=" * 80)
        logger.info("ИТОГОВАЯ СТАТИСТИКА")
        logger.info("=" * 80)

        matches = sum(1 for r in results if r['match'])
        logger.info(f"Проверено артикулов: {len(results)}")
        logger.info(f"Совпадений: {matches}")
        logger.info(f"Несовпадений: {len(results) - matches}")
        logger.info(f"Общий результат: {'✓' if all_match else '✗'}")

        return all_match, results

    def _get_json_stages_data(self):
        """Получение данных о этапах из JSON с учетом группы 'Производство'"""
        logger.debug("Получение данных о этапах из JSON")
        json_data = {}

        for item in self.json_handler.get_order_items():
            article = item.get('materialCode')
            if not article:
                continue

            article_data = {'Process': [], 'Finish': [], 'Wait': []}

            # Создаем структуру для отслеживания этапов производства по группам
            production_stages = {
                'Process': [], 'Finish': [], 'Wait': []
            }

            for step in item.get('progressSteps', []):
                status_type = step.get('status')
                if status_type not in article_data:
                    continue

                text = step.get('description', '').lower()
                if text:
                    article_data[status_type].append(text)

                # Проверяем groupName этапа
                group_name = step.get('groupName', '').lower()

                # Если это группа "Производство", запоминаем отдельно
                if group_name == 'производство':
                    production_stages[status_type].append(text)

            # Добавляем информацию о производственных этапах в данные артикула
            json_data[article] = {
                **article_data,
                'production_stages': production_stages
            }

        logger.debug(f"Собраны данные о этапах для {len(json_data)} артикулов из JSON")
        return json_data

    def _get_html_content(self):
        """Получение HTML-содержимого страницы"""
        logger.debug("Получаем содержимое всей страницы для анализа...")

        try:
            all_accordion_container = self.driver.find_element(By.CSS_SELECTOR, "div.accordion")
            page_html = all_accordion_container.get_attribute('outerHTML')
            logger.debug(f"Получен HTML аккордеона, размер: {len(page_html)} символов")
        except Exception as e:
            logger.error(f"Ошибка при получении HTML аккордеона: {e}")
            # Запасной вариант - получаем HTML всей страницы
            page_html = self.driver.find_element(By.TAG_NAME, "body").get_attribute('outerHTML')
            logger.warning(f"Используется запасной вариант - HTML всей страницы, размер: {len(page_html)} символов")

        return page_html

    def _parse_html_for_stages(self, page_html):
        """Извлечение данных о этапах из HTML"""
        global article
        logger.info("Обработка HTML страницы...")

        soup = BeautifulSoup(page_html, 'html.parser')

        # Находим все аккордеоны
        accordion_items = soup.select("div.accordion-item")
        logger.debug(f"Найдено аккордеонов в HTML: {len(accordion_items)}")

        # Словарь для результатов
        page_data = {}

        # Обрабатываем каждый аккордеон
        for item in accordion_items:
            try:
                # Получаем номер артикула
                header = item.select_one("div.fs-4.fw-bold")
                if not header:
                    continue

                article = header.get_text().strip()
                if not article:
                    continue

                logger.debug(f"Обработка артикула: {article}")

                # Инициализируем данные для артикула
                page_data[article] = {'Process': [], 'Finish': [], 'Wait': []}

                # Находим содержимое аккордеона - div с классом accordion-body
                accordion_body = self._find_accordion_body(item)

                if not accordion_body:
                    logger.warning(f"Не найдено содержимое аккордеона для {article}")
                    continue

                logger.debug(f"Найдено содержимое аккордеона для {article}")

                # Извлекаем этапы для артикула
                self._extract_stages_from_accordion(accordion_body, page_data[article])

                # Выводим информацию о собранных этапах
                logger.debug(f"Этапы для {article}: Process={len(page_data[article]['Process'])}, " +
                             f"Finish={len(page_data[article]['Finish'])}, Wait={len(page_data[article]['Wait'])}")

            except Exception as e:
                logger.error(f"Ошибка при обработке артикула {article}: {e}")

        return page_data

    def _find_accordion_body(self, accordion_item):
        """Поиск тела аккордеона в HTML"""
        logger.debug("Поиск тела аккордеона")
        accordion_body = accordion_item.select_one("div.accordion-body")
        if not accordion_body:
            # Пробуем альтернативный вариант, ищем по id
            logger.debug("Не найдено тело аккордеона по прямому селектору, пробуем альтернативный вариант")
            accordion_collapse = accordion_item.select_one("div.accordion-collapse")
            if accordion_collapse:
                accordion_body = accordion_collapse.select_one("div.accordion-body")

        return accordion_body

    def _extract_stages_from_accordion(self, accordion_body, article_data):
        """Извлечение этапов из тела аккордеона с особой обработкой производственных этапов"""
        logger.debug("Извлечение этапов из тела аккордеона")
        # Ищем элементы с этапами - они в div с классами d-flex align-items-center
        stage_containers = accordion_body.select("div.d-flex.align-items-center")
        logger.debug(f"Найдено {len(stage_containers)} контейнеров с этапами")

        for container in stage_containers:
            # Определяем статус по индикатору
            status_type = self._detect_status_type(container)

            if not status_type:
                continue

            # Ищем текст этапа - он находится в div рядом с индикатором
            stage_text_elem = container.select_one("div.fs-5") or container.select_one(
                "div.fs-6") or container.select_one("div.text-gray")

            if stage_text_elem:
                text = stage_text_elem.get_text().strip().lower()
                if text and text not in ['', '.', 'подробнее']:
                    article_data[status_type].append(text)
                    logger.debug(f"Добавлен этап типа {status_type}: {text}")

                    # Если это этап производства, сохраняем его в специальную структуру
                    if "производство" in text:
                        if 'production_stages' not in article_data:
                            article_data['production_stages'] = {'Process': [], 'Finish': [], 'Wait': []}
                        article_data['production_stages'][status_type].append(text)
                        logger.debug(f"Добавлен производственный этап типа {status_type}: {text}")

    def _detect_status_type(self, container):
        """Определение типа статуса по индикатору"""
        if container.select_one("i.service-btp_icon--blue") or container.select_one(
                "svg.text-primary") or container.select_one("[class*='blue']"):
            return 'Process'
        elif container.select_one("i.service-btp_icon--green") or container.select_one(
                "svg.text-success") or container.select_one("[class*='green']"):
            return 'Finish'
        elif container.select_one("i.service-btp_icon--gray") or container.select_one(
                "svg.text-secondary") or container.select_one("[class*='gray']"):
            return 'Wait'
        return None

    def _compare_and_report_stages(self, json_data, page_data):
        """Сравнение данных и формирование отчета с учетом группы 'Производство'"""
        logger.info("Сравнение данных из JSON и страницы")
        results = []

        # Детальный вывод всех данных
        logger.info("=" * 80)
        logger.info("ДЕТАЛЬНЫЙ ВЫВОД ВСЕХ ЭТАПОВ ДЛЯ КАЖДОГО АРТИКУЛА")
        logger.info("=" * 80)

        # Сортируем артикулы для удобства анализа
        all_articles = sorted(list(set(list(json_data.keys()) + list(page_data.keys()))))

        for article in all_articles:
            logger.info(f"\nАРТИКУЛ: {article}")
            logger.info("-" * 50)

            json_article_data = json_data.get(article, {})
            page_article_data = page_data.get(article, {})

            article_match = True
            mismatches = []

            # Проверяем наличие этапа "Производство" среди завершенных (зеленых) этапов в UI
            production_in_finish = False
            for stage in page_article_data.get('Finish', []):
                if "производство" in self._normalize_stage_text(stage):
                    production_in_finish = True
                    logger.info("  Обнаружен завершенный этап 'Производство' в UI")
                    break

            # Если есть завершенный этап "Производство" в UI, проверяем этапы производства в JSON
            if production_in_finish:
                # Получаем незавершенные этапы производства из JSON
                production_process = json_article_data.get('production_stages', {}).get('Process', [])
                production_wait = json_article_data.get('production_stages', {}).get('Wait', [])

                unfinished_production = production_process + production_wait

                if unfinished_production:
                    logger.warning(
                        "  ✗ Несоответствие! В UI 'Производство' завершено, но в JSON есть незавершенные этапы производства:")
                    for stage in unfinished_production:
                        logger.warning(f"    - {stage}")

                    article_match = False
                    mismatches.append({
                        'status_type': 'Finish',
                        'message': "В UI 'Производство' завершено, но в JSON есть незавершенные этапы производства",
                        'unfinished_production_stages': unfinished_production
                    })
                else:
                    logger.info("  ✓ Все этапы производства в JSON завершены, соответствует UI")

                # Исключаем этап "Производство" из стандартной проверки, так как мы его уже проверили
                filtered_finish_stages = []
                for stage in page_article_data.get('Finish', []):
                    if "производство" not in self._normalize_stage_text(stage):
                        filtered_finish_stages.append(stage)

                page_article_data['Finish'] = filtered_finish_stages

            # Стандартная проверка для всех типов статусов
            for status_type in ['Process', 'Finish', 'Wait']:
                json_stages = json_article_data.get(status_type, [])
                page_stages = page_article_data.get(status_type, [])

                # Выводим данные для каждого типа статуса
                logger.info(f"\nСтатус: {status_type}")
                logger.info(f"  В UI ({len(page_stages)}):")
                for stage in page_stages:
                    logger.info(f"    - {stage}")

                logger.info(f"  В JSON ({len(json_stages)}):")
                for stage in json_stages:
                    logger.info(f"    - {stage}")

                # Если нет этапов на странице, пропускаем сравнение
                if not page_stages:
                    logger.info("  Результат: На странице нет этапов для сравнения")
                    continue

                # Нормализуем тексты этапов для сравнения
                json_stages_norm = [self._normalize_stage_text(stage) for stage in json_stages]
                page_stages_norm = [self._normalize_stage_text(stage) for stage in page_stages]

                # Проверяем, что каждый этап из UI присутствует в JSON
                missing_stages = []

                for i, page_stage in enumerate(page_stages_norm):
                    found = False
                    for json_stage in json_stages_norm:
                        # Проверяем, что текст этапа из UI содержится в JSON или наоборот
                        if (page_stage in json_stage) or (json_stage in page_stage):
                            found = True
                            break

                    if not found:
                        missing_stages.append(page_stages[i])

                # Выводим результат сравнения
                if missing_stages:
                    logger.warning("  Результат: ✗ Несоответствие!")
                    logger.warning("  Этапы из UI, не найденные в JSON:")
                    for stage in missing_stages:
                        logger.warning(f"    - {stage}")

                    article_match = False
                    mismatches.append({
                        'status_type': status_type,
                        'json_stages': json_stages,
                        'page_stages': page_stages,
                        'missing_in_json': missing_stages
                    })
                else:
                    logger.info("  Результат: ✓ Все этапы из UI найдены в JSON")

            results.append({
                'article': article,
                'match': article_match,
                'mismatches': mismatches
            })

        return results

    def _normalize_stage_text(self, text):
        """Нормализация текста этапа для корректного сравнения"""
        if not text:
            return ""

        # Приводим к нижнему регистру
        text = text.lower().strip()

        # Удаляем точки и другие знаки пунктуации
        text = text.replace('.', '').replace(',', '')

        # Удаляем лишние пробелы
        text = ' '.join(text.split())

        return text

    @allure.step("Проверка номеров допоставки")
    @allure.step("Проверка попапов доставки")
    def verify_delivery_popups_fast(self):
        """
        Быстрая проверка попапов с информацией о доставке.
        Сначала проверяет наличие данных в JSON, затем быстро проверяет UI.
        """
        logger.info("Выполняется быстрая проверка попапов доставки")
        # 1. Получаем информацию из JSON (без ожидания)
        with allure.step("Получение информации о доставке из JSON"):
            json_delivery_info = self._get_delivery_info_from_json()
            json_delivery_count = len(json_delivery_info) if isinstance(json_delivery_info, list) else 0
            logger.debug(f"Количество записей о доставке в JSON: {json_delivery_count}")

        # 2. Если в JSON нет данных, быстро проверяем UI
        if json_delivery_count == 0:
            with allure.step("Проверка наличия ссылок на попапы в UI"):
                try:
                    # Ищем ссылки на попапы с минимальным таймаутом
                    delivery_links = self.find_elements(BTPServicePageLocators.DELIVERY_POPUP_LINKS, sec=1)
                    logger.debug(f"Найдено ссылок на попапы в UI: {len(delivery_links)}")

                    if not delivery_links:
                        logger.info("Нет элементов доставки в JSON и UI - тест пропущен")
                        return {
                            "success": True,
                            "skip_test": True,
                            "skip_reason": "Нет элементов доставки в JSON и UI"
                        }
                except Exception as e:
                    logger.warning(f"Ошибка при проверке ссылок на попапы: {e}")
                    logger.info("Нет элементов доставки в JSON и UI - тест пропущен")
                    return {
                        "success": True,
                        "skip_test": True,
                        "skip_reason": "Нет элементов доставки в JSON и UI"
                    }

        # 3. Получаем количество ссылок на попапы в UI
        with allure.step("Подсчет количества ссылок на попапы в UI"):
            timeout = 5 if json_delivery_count > 0 else 2
            logger.debug(f"Таймаут для поиска ссылок: {timeout} секунд")

            try:
                delivery_links = self.find_elements(BTPServicePageLocators.DELIVERY_POPUP_LINKS, sec=timeout)
                ui_delivery_count = len(delivery_links)
                logger.debug(f"Найдено ссылок на попапы в UI: {ui_delivery_count}")
            except Exception as e:
                logger.warning(f"Ошибка при поиске ссылок на попапы: {e}")
                ui_delivery_count = 0

        # 4. Проверяем соответствие количества
        count_match = json_delivery_count == ui_delivery_count
        logger.info(f"Совпадение количества записей о доставке: {count_match}")

        # 5. Если количество не совпадает, возвращаем результат
        if not count_match:
            logger.warning(
                f"Количество элементов доставки не совпадает: в JSON {json_delivery_count}, на странице {ui_delivery_count}")
            return {
                "success": False,
                "skip_test": False,
                "json_delivery_count": json_delivery_count,
                "ui_delivery_count": ui_delivery_count,
                "count_match": False,
                "message": (f"Количество элементов доставки не совпадает: " +
                            f"в JSON {json_delivery_count}, на странице {ui_delivery_count}")
            }

        # 6. Если нет элементов для проверки, возвращаем успешный результат
        if ui_delivery_count == 0:
            logger.info("Нет элементов доставки в JSON и UI - тест пропущен")
            return {
                "success": True,
                "skip_test": True,
                "skip_reason": "Нет элементов доставки в JSON и UI",
                "count_match": True
            }

        # 7. Проверяем попапы, только если есть данные для проверки
        with allure.step("Проверка попапов доставки"):
            processed_count = 0

            # 8. Для каждой ссылки на попап
            for i in range(min(ui_delivery_count, 3)):  # Проверяем не более 3 попапов
                try:
                    # Находим все ссылки заново (они могли измениться после открытия/закрытия попапа)
                    delivery_links = self.find_elements(BTPServicePageLocators.DELIVERY_POPUP_LINKS, sec=2)
                    logger.debug(f"Найдено ссылок на попапы: {len(delivery_links)}")

                    if i >= len(delivery_links):
                        logger.warning(f"Не найдено достаточно ссылок на попапы, пропуск попапа #{i + 1}")
                        break

                    # Получаем ID целевого попапа
                    popup_target = delivery_links[i].get_attribute("data-bs-target")
                    popup_id = popup_target.replace("#", "")
                    logger.debug(f"ID попапа #{i + 1}: {popup_id}")

                    # Открываем попап
                    logger.debug(f"Нажатие на ссылку попапа #{i + 1}")
                    delivery_links[i].click()

                    # Ждем открытия попапа с коротким таймаутом
                    logger.debug(f"Ожидание открытия попапа #{i + 1}...")
                    wait = WebDriverWait(self.driver, 3)
                    wait.until(
                        EC.visibility_of_element_located((By.ID, popup_id))
                    )
                    logger.info(f"Попап #{i + 1} успешно открыт")

                    # Закрываем попап
                    logger.debug(f"Закрытие попапа #{i + 1}")
                    close_button = self.driver.find_element(By.CSS_SELECTOR, f"#{popup_id} button.btn-close")
                    close_button.click()

                    # Ждем закрытия попапа
                    logger.debug(f"Ожидание закрытия попапа #{i + 1}...")
                    wait.until(
                        EC.invisibility_of_element_located((By.ID, popup_id))
                    )
                    logger.info(f"Попап #{i + 1} успешно закрыт")

                    processed_count += 1

                except Exception as e:
                    logger.error(f"Ошибка при проверке попапа #{i + 1}: {e}")

            logger.info(f"Проверено попапов: {processed_count} из {ui_delivery_count}")

        # 9. Результат
        result = {
            "success": processed_count > 0,
            "json_delivery_count": json_delivery_count,
            "ui_delivery_count": ui_delivery_count,
            "processed_count": processed_count,
            "count_match": count_match,
            "all_popups_processed": processed_count == ui_delivery_count,
            "skip_test": False
        }

        logger.info(f"Общий результат проверки попапов доставки: {'✓' if result['success'] else '✗'}")
        return result

    def _get_page_delivery_numbers(self, timeout=3):
        """
        Оптимизированное получение номеров допоставки со страницы
        Сохраняет оригинальный текст с префиксом "(в работе)"
        Принимает параметр timeout для быстрых проверок
        """
        logger.debug(f"Получение номеров допоставки со страницы (таймаут: {timeout})")
        page_delivery_numbers = {}

        try:
            # Находим все элементы артикулов с коротким таймаутом
            article_elements = self.find_elements(
                BTPServicePageLocators.ARTICLE_ACCORDION_ITEMS,
                timeout
            )
            logger.debug(f"Найдено {len(article_elements)} элементов артикулов")

            for element in article_elements:
                try:
                    # Ищем номер артикула
                    article_element = element.find_element(*BTPServicePageLocators.ARTICLE_HEADERS)
                    article = article_element.text.strip()
                    if not article:
                        continue

                    # Ищем элементы с номером допоставки
                    delivery_elements = element.find_elements(*BTPServicePageLocators.DELIVERY_NUMBER)

                    delivery_number = None
                    # Обрабатываем найденные элементы
                    for delivery_elem in delivery_elements:
                        text = delivery_elem.text.strip()
                        if "№" in text:
                            parts = text.split("№", 1)
                            if len(parts) > 1:
                                delivery_number = parts[1].strip()
                                logger.debug(f"Для артикула {article} найден номер допоставки: {delivery_number}")
                                break

                    # Добавляем в словарь
                    page_delivery_numbers[article] = delivery_number

                except Exception as e:
                    logger.warning(f"Ошибка при обработке артикула для номера допоставки: {e}")
                    continue

        except Exception as e:
            logger.error(f"Ошибка при получении номеров допоставки: {e}")
            # В случае ошибки (например, истек таймаут) возвращаем пустой словарь
            return {}

        return page_delivery_numbers

    @allure.step("Проверка номера заказа")
    def verify_order_number(self):
        """Проверка совпадения номера заказа на странице с введенным при авторизации"""
        logger.info("Проверка номера заказа")
        if not self.order_number:
            logger.error("Номер заказа не установлен")
            raise ValueError("Номер заказа не установлен")

        with allure.step("Получение номера заказа со страницы"):
            page_order_number = self.get_order_number()
            logger.info(f"Номер заказа на странице: {page_order_number}")
            logger.info(f"Ожидаемый номер заказа: {self.order_number}")

        with allure.step("Сравнение номеров заказа"):
            match = page_order_number == self.order_number
            logger.info(f"Номера заказов совпадают: {match}")

        return match, {
            'page': page_order_number,
            'expected': self.order_number
        }

    @allure.step("Проверка статуса заказа")
    def verify_order_status(self):
        """Проверка статуса заказа на странице и в JSON"""
        logger.info("Проверка статуса заказа")
        if not self.json_handler:
            logger.error("JSON обработчик не установлен")
            raise ValueError("JSON обработчик не установлен")

        with allure.step("Получение статусов заказа со страницы"):
            page_statuses = self.get_order_status()
            logger.info(f"Статусы на странице: {page_statuses}")

        with allure.step("Получение статусов заказа из JSON"):
            json_statuses = self.json_handler.get_order_statuses()
            logger.info(f"Статусы в JSON: {json_statuses}")

        # Сравниваем статусы
        with allure.step("Сравнение статусов"):
            status_match = set(page_statuses) == set(json_statuses)
            logger.info(f"Статусы совпадают: {status_match}")

        return status_match, {
            'page': page_statuses,
            'json': json_statuses
        }

    @allure.step("Проверка артикулов")
    def verify_articles(self):
        """Проверка артикулов на странице и в JSON"""
        logger.info("Проверка артикулов")
        if not self.json_handler:
            logger.error("JSON обработчик не установлен")
            raise ValueError("JSON обработчик не установлен")

        with allure.step("Получение артикулов со страницы"):
            page_articles = self.get_articles()
            logger.info(f"Артикулы на странице: {page_articles}")

        with allure.step("Получение артикулов из JSON"):
            json_articles = self.json_handler.get_articles()
            logger.info(f"Артикулы в JSON: {json_articles}")

        # Сравниваем артикулы
        with allure.step("Сравнение артикулов"):
            articles_match = set(page_articles) == set(json_articles)
            logger.info(f"Артикулы совпадают: {articles_match}")

        return articles_match, {
            'page': page_articles,
            'json': json_articles
        }

    @allure.step("Проверка номеров материалов")
    def verify_material_numbers(self):
        """
        Простой и быстрый тест проверки номеров материалов допоставки.
        """
        logger.info("Проверка номеров материалов допоставки")

        # Шаг 1: Безопасная проверка наличия кнопки подробнее и материалов в JSON
        with allure.step("Проверка кнопки 'подробнее' и материалов в JSON"):
            try:
                # Устанавливаем минимальное ожидание для быстрой проверки
                original_implicit_wait = self.driver.timeouts.implicit_wait
                self.driver.implicitly_wait(1)

                # Проверяем наличие кнопки "подробнее"
                try:
                    details_buttons = self.driver.find_elements(By.XPATH,
                                                                "//span[contains(@class, 'cursor-pointer') and contains(@class, 'text-danger') and contains(text(), 'подробнее')]")
                    has_button = len(details_buttons) > 0
                    logger.debug(f"Найдено кнопок 'подробнее': {len(details_buttons)}")
                except Exception as e:
                    logger.warning(f"Ошибка при поиске кнопок 'подробнее': {e}")
                    has_button = False
                    details_buttons = []

                # Восстанавливаем исходное значение ожидания
                self.driver.implicitly_wait(original_implicit_wait)

            except Exception as e:
                logger.error(f"Ошибка при проверке кнопки 'подробнее': {e}")
                return False, {"error": f"Ошибка при проверке кнопки 'подробнее': {str(e)}"}

            # Получаем материалы из JSON
            try:
                json_materials = self._get_materials_from_json()
                has_json_materials = any(materials for materials in json_materials.values())
                logger.debug(f"Артикулов с материалами в JSON: {len(json_materials)}")
            except Exception as e:
                logger.error(f"Ошибка при получении материалов из JSON: {e}")
                return False, {"error": f"Ошибка при получении материалов из JSON: {str(e)}"}

            # Принимаем решение на основе наличия кнопки и материалов
            if not has_button and not has_json_materials:
                logger.info("Ни кнопки, ни материалов в JSON не найдено - тест успешен")
                return True, {"message": "Нет кнопки 'подробнее' и нет материалов в JSON"}

            if not has_button and has_json_materials:
                logger.warning("Ошибка: нет кнопки 'подробнее', но есть материалы в JSON")
                return False, {"message": "Нет кнопки 'подробнее', но есть материалы в JSON"}

            if has_button and not has_json_materials:
                logger.warning("Ошибка: есть кнопка 'подробнее', но нет материалов в JSON")
                return False, {"message": "Есть кнопка 'подробнее', но нет материалов в JSON"}

        # Шаг 2: Открытие попапа с материалами
        with allure.step("Открытие попапа с материалами"):
            popup = self._open_details_popup(details_buttons)
            if not popup:
                logger.error("Не удалось открыть попап с материалами")
                return False, {"error": "Не удалось открыть попап с материалами"}

        # Шаг 3: Сбор данных из аккордеонов в попапе
        with allure.step("Сбор кодов материалов из попапа"):
            try:
                ui_materials = self._collect_material_codes_from_popup(popup)
                if not ui_materials:
                    logger.warning("Не удалось собрать материалы из попапа")
                    # Продолжаем выполнение, это может быть нормальной ситуацией
            except Exception as e:
                logger.error(f"Ошибка при сборе материалов из попапа: {e}")
                # Пытаемся закрыть попап перед возвратом ошибки
                self._close_popup()
                return False, {"error": f"Ошибка при сборе материалов из попапа: {str(e)}"}

        # Шаг 4: Закрытие попапа
        with allure.step("Закрытие попапа"):
            if not self._close_popup():
                logger.warning("Не удалось закрыть попап, продолжаем выполнение")
                # Продолжаем выполнение, это не критическая ошибка

        # Шаг 5: Сравнение данных из UI и JSON
        with allure.step("Сравнение материалов из UI и JSON"):
            try:
                results = self._compare_materials(json_materials, ui_materials)
            except Exception as e:
                logger.error(f"Ошибка при сравнении материалов: {e}")
                return False, {"error": f"Ошибка при сравнении материалов: {str(e)}"}

        # Общий результат
        all_match = all(r["match"] for r in results)
        logger.info(f"Общий результат проверки номеров материалов: {'✓' if all_match else '✗'}")

        return all_match, results

    def _check_details_button_and_json(self):
        """
        Шаг 1: Проверка наличия кнопки "подробнее" и материалов в JSON.
        """
        logger.info("Шаг 1: Проверка наличия кнопки 'подробнее' и материалов в JSON")

        # Временно отключаем имплицитное ожидание
        original_implicit_wait = self.driver.timeouts.implicit_wait
        self.driver.implicitly_wait(1)  # Используем минимальное ожидание

        try:
            # Ищем кнопку "подробнее"
            details_buttons = self.find_elements((By.XPATH,
                                                "//span[contains(@class, 'cursor-pointer') and contains(@class, 'text-danger') and contains(text(), 'подробнее')]"),
                                               sec=1)
            has_button = len(details_buttons) > 0
            logger.debug(f"Найдено кнопок 'подробнее': {len(details_buttons)}")
        finally:
            # Восстанавливаем имплицитное ожидание
            self.driver.implicitly_wait(original_implicit_wait)

        # Получаем материалы из JSON
        json_materials = self._get_materials_from_json()
        has_json_materials = any(materials for materials in json_materials.values())
        logger.debug(f"Артикулов с материалами в JSON: {len(json_materials)}")

        # Принимаем решение
        if not has_button and not has_json_materials:
            logger.info("Ни кнопки, ни материалов в JSON не найдено - тест успешен")
            return True, {"message": "Нет кнопки 'подробнее' и нет материалов в JSON"}

        if not has_button and has_json_materials:
            logger.warning("Ошибка: нет кнопки 'подробнее', но есть материалы в JSON")
            return False, {"message": "Нет кнопки 'подробнее', но есть материалы в JSON"}

        if has_button and not has_json_materials:
            logger.warning("Ошибка: есть кнопка 'подробнее', но нет материалов в JSON")
            return False, {"message": "Есть кнопка 'подробнее', но нет материалов в JSON"}

        return True, {"details_buttons": details_buttons, "json_materials": json_materials}

    def _get_materials_from_json(self):
        """
        Получает номера материалов из JSON для всех артикулов.
        """
        logger.debug("Получение номеров материалов из JSON")
        materials_by_article = {}

        for item in self.json_handler.get_order_items():
            article = item.get('materialCode')
            if not article:
                continue

            materials_by_article[article] = []

            internal_order = item.get('internalOrder')
            if not internal_order:
                continue

            for material in internal_order.get('items', []):
                material_code = material.get('materialCode')
                if material_code:
                    materials_by_article[article].append(material_code)
                    logger.debug(f"Для артикула {article} найден материал: {material_code}")

        return materials_by_article

    def _open_details_popup(self, details_buttons=None):
        """
        Шаг 2: Открытие попапа с материалами.
        """
        logger.info("Шаг 2: Открытие попапа с материалами")

        try:
            # Если кнопки не переданы, ищем их с увеличенным таймаутом
            if details_buttons is None or len(details_buttons) == 0:
                details_buttons = self.find_elements(BTPServicePageLocators.DETAILS_POPUP_BUTTON, sec=20)

            if not details_buttons or len(details_buttons) == 0:
                logger.error("Ошибка: кнопка 'подробнее' не найдена")
                return None

            # # Скроллим к кнопке и делаем паузу после скролла
            # self.scroll_to(details_buttons[0])
            # time.sleep(1)  # Даем время странице стабилизироваться после скролла

            # Ждем кликабельности с увеличенным таймаутом (30 секунд)
            logger.debug("Ожидание кликабельности кнопки (до 30 секунд)...")
            self.expecting_clickability(BTPServicePageLocators.DETAILS_POPUP_BUTTON, sec=30)

            # # Повторный скролл для гарантии видимости после ожидания
            # self.scroll_to(details_buttons[0])
            # time.sleep(0.5)

            # Клик
            logger.debug("Выполнение клика на кнопку")
            details_buttons[0].click()

            # Ждем открытия попапа - достаточно долго (40 секунд)
            logger.debug("Ожидание открытия попапа (до 40 секунд)...")
            self.waiting_element_is_visibility_on_the_page(BTPServicePageLocators.MODAL_DIALOG, sec=40)

            # Короткая пауза для полной загрузки попапа
            time.sleep(1)

            # Получаем попап
            popup = self.find_element(BTPServicePageLocators.MODAL_DIALOG)
            logger.info("Попап успешно открыт")

            return popup

        except Exception as e:
            logger.error(f"Ошибка при открытии попапа: {e}")
            return None

    def _collect_material_codes_from_popup(self, popup):
        """
        Шаг 3: Сбор кодов материалов из попапа.
        """
        import re
        logger.info("Шаг 3: Сбор кодов материалов из попапа")

        ui_materials = {}

        try:
            # Находим контейнер с аккордеонами в попапе по ID
            try:
                accordion_container = popup.find_element(By.ID, "service-btp-items-detail")
                logger.debug("Найден контейнер аккордеонов по ID")
            except:
                # Запасной вариант - поиск по классу
                accordion_container = popup.find_element(By.CSS_SELECTOR, "div.accordion.mt-4")
                logger.debug("Найден контейнер аккордеонов по классу")

            # Находим все аккордеоны внутри контейнера
            accordion_items = accordion_container.find_elements(By.CSS_SELECTOR, "div.accordion-item")
            logger.debug(f"Найдено аккордеонов в попапе: {len(accordion_items)}")

            # Проверяем, есть ли открытый аккордеон изначально
            open_accordion = popup.find_elements(By.CSS_SELECTOR, "div.accordion-collapse.show")
            initially_open = len(open_accordion) > 0
            logger.debug(f"Изначально открыт аккордеон: {initially_open}")

            # Если нет открытого аккордеона, открываем первый
            if not initially_open and accordion_items:
                first_button = accordion_items[0].find_element(By.CSS_SELECTOR, "div.accordion-button")
                logger.debug("Открываем первый аккордеон")
                self.scroll_to(first_button)
                time.sleep(0.5)  # Пауза перед кликом
                first_button.click()
                time.sleep(1)  # Пауза после клика

            # Обрабатываем каждый аккордеон
            for i, item in enumerate(accordion_items):
                try:
                    # Получаем артикул
                    article_header = item.find_element(By.CSS_SELECTOR, "div.fs-4.fw-bold")
                    article = article_header.text.strip()

                    if not article:
                        logger.warning(f"Аккордеон {i + 1}: артикул не найден, пропускаем")
                        continue

                    logger.debug(f"Обработка аккордеона {i + 1}: {article}")

                    # Находим кнопку аккордеона
                    accordion_button = item.find_element(By.CSS_SELECTOR, "div.accordion-button")

                    # Проверяем, открыт ли аккордеон
                    is_expanded = accordion_button.get_attribute("aria-expanded") == "true"
                    logger.debug(f"Аккордеон {article} открыт: {is_expanded}")

                    # Если не открыт - открываем
                    if not is_expanded:
                        # Скроллируем к кнопке
                        self.scroll_to(accordion_button)
                        time.sleep(0.5)  # Пауза перед кликом

                        # Клик
                        logger.debug(f"Открываем аккордеон {article}")
                        accordion_button.click()

                        # Ждем открытия аккордеона
                        logger.debug("Ожидание открытия аккордеона...")
                        wait = WebDriverWait(self.driver, 10)
                        wait.until(
                            EC.presence_of_element_located((By.CSS_SELECTOR, "div.accordion-collapse.show"))
                        )

                        # Небольшая пауза для стабильности
                        time.sleep(1)

                    # Находим открытый раздел аккордеона
                    accordion_body = None
                    try:
                        # Сначала ищем аккордеон по ID
                        accordion_bodies = popup.find_elements(By.CSS_SELECTOR, "div.accordion-collapse.show")
                        if accordion_bodies:
                            accordion_body = accordion_bodies[0]
                            logger.debug(f"Найдено содержимое открытого аккордеона")
                        else:
                            logger.warning(f"Ошибка: не найдено открытое содержимое аккордеона")
                            continue
                    except Exception as e:
                        logger.error(f"Ошибка при поиске содержимого аккордеона: {e}")
                        continue

                    # Находим элементы с текстом материалов
                    material_elements = accordion_body.find_elements(By.CSS_SELECTOR, "div.text-gray")
                    logger.debug(f"Найдено элементов с материалами: {len(material_elements)}")

                    # Выводим текст для отладки
                    for j, elem in enumerate(material_elements):
                        text = elem.text.strip()
                        logger.debug(f"Материал {j + 1}: '{text}'")

                    # Извлекаем коды материалов
                    material_codes = []
                    for elem in material_elements:
                        text = elem.text.strip()
                        if text:
                            # Извлекаем код материала между номером и вертикальной чертой
                            match = re.search(r'\d+\.\s+([\w-]+)\s*\|', text)
                            if match:
                                material_code = match.group(1).strip()  # Убираем пробелы
                                material_codes.append(material_code)
                                logger.debug(f"Извлечен код: {material_code}")

                    ui_materials[article] = material_codes
                    logger.debug(f"Собрано кодов материалов: {len(material_codes)}")

                except Exception as e:
                    logger.error(f"Ошибка при обработке аккордеона {i + 1}: {e}")

        except Exception as e:
            logger.error(f"Общая ошибка при сборе материалов: {e}")

        return ui_materials

    def _close_popup(self):
        """
        Шаг 4: Закрытие попапа.
        """
        logger.info("Шаг 4: Закрытие попапа")

        try:
            # Находим кнопку закрытия
            close_button = self.find_element((By.CSS_SELECTOR, "button.btn-close"))
            logger.debug("Нажатие на кнопку закрытия попапа")
            close_button.click()

            # Ждем закрытия попапа
            wait = WebDriverWait(self.driver, 10)
            wait.until(
                EC.invisibility_of_element_located((By.CSS_SELECTOR, "div.modal-dialog.modal-dialog-centered"))
            )
            logger.info("Попап успешно закрыт")
            return True

        except Exception as e:
            logger.error(f"Ошибка при закрытии попапа кнопкой: {e}")

            # Пробуем закрыть клавишей ESC
            try:
                logger.debug("Попытка закрыть попап клавишей ESC")
                body = self.find_element((By.TAG_NAME, "body"))
                body.send_keys(Keys.ESCAPE)

                wait = WebDriverWait(self.driver, 10)
                wait.until(
                    EC.invisibility_of_element_located((By.CSS_SELECTOR, "div.modal-dialog.modal-dialog-centered"))
                )
                logger.info("Попап успешно закрыт клавишей ESC")
                return True

            except Exception as e2:
                logger.error(f"Ошибка при закрытии попапа клавишей ESC: {e2}")
                return False

    def _compare_materials(self, json_materials, ui_materials):
        """
        Шаг 5: Сравнение материалов из JSON и UI.
        """
        logger.info("Шаг 5: Сравнение материалов из JSON и UI")

        results = []

        # Все уникальные артикулы
        all_articles = set(list(json_materials.keys()) + list(ui_materials.keys()))

        for article in all_articles:
            json_codes = sorted(json_materials.get(article, []))
            ui_codes = sorted(ui_materials.get(article, []))

            # Определяем совпадение
            match = json_codes == ui_codes

            # Формируем результат
            result = {
                "article": article,
                "match": match,
                "json_materials": json_codes,
                "ui_materials": ui_codes
            }

            # Если есть различия, добавляем подробности
            if not match:
                only_in_json = set(json_codes) - set(ui_codes)
                only_in_ui = set(ui_codes) - set(json_codes)

                if only_in_json:
                    result["only_in_json"] = list(only_in_json)

                if only_in_ui:
                    result["only_in_ui"] = list(only_in_ui)

            results.append(result)
            logger.debug(f"Артикул {article}: совпадение = {match}")

        return results

    @allure.step("Проверка актуальных статусов артикулов")
    def verify_statuses_simplest(self):
        """
        Быстрый тест проверки статусов артикулов с использованием коллекций.
        Собирает коллекцию артикулов с их статусами и индикаторами одним запросом,
        затем обрабатывает и сравнивает с данными из JSON.
        """
        logger.info("Быстрая проверка статусов артикулов")

        # 1. Собираем коллекцию артикулов и их статусов из UI
        with allure.step("Сбор статусов артикулов из UI"):
            ui_statuses = self._collect_ui_statuses()
            logger.debug(f"Собрано {len(ui_statuses)} статусов из UI")

        # 2. Получаем данные из JSON
        with allure.step("Получение статусов артикулов из JSON"):
            json_statuses = self._collect_json_statuses()
            logger.debug(f"Собрано {len(json_statuses)} статусов из JSON")

        # 3. Сравниваем данные и формируем результаты
        with allure.step("Сравнение статусов из UI и JSON"):
            results = self._compare_statuses(ui_statuses, json_statuses)

        # 4. Определяем общий результат
        all_match = all(r["match"] for r in results)
        logger.info(f"Общий результат проверки статусов: {'✓' if all_match else '✗'}")

        return all_match, results

    def _collect_ui_statuses(self):
        """
        Собирает коллекцию статусов артикулов из UI.
        Возвращает словарь: {артикул: {"indicator": класс_индикатора, "text": текст_статуса}}
        """
        logger.debug("Сбор статусов артикулов из UI")
        result = {}

        try:
            # Получаем все артикулы с их статусами одним запросом
            elements = self.find_elements((By.CSS_SELECTOR, "div.accordion-item"))
            logger.debug(f"Найдено {len(elements)} элементов аккордеона")

            for element in elements:
                try:
                    # Получаем номер артикула
                    article_element = element.find_element(By.CSS_SELECTOR, "div.fs-4.fw-bold")
                    article = article_element.text.strip()

                    # Ищем индикатор статуса
                    indicator = None
                    status_text = None

                    # Поиск индикатора статуса в заголовке аккордеона
                    indicators = element.find_elements(By.CSS_SELECTOR,
                                                       "div.accordion-header i.service-btp_icon--blue, " +
                                                       "div.accordion-header i.service-btp_icon--green, " +
                                                       "div.accordion-header i.service-btp_icon--gray, " +
                                                       "div.accordion-header i[class*='blue'], " +
                                                       "div.accordion-header i[class*='green'], " +
                                                       "div.accordion-header i[class*='gray']")

                    if indicators:
                        # Берем первый найденный индикатор
                        indicator_element = indicators[0]
                        indicator_class = indicator_element.get_attribute("class")
                        logger.debug(f"Для артикула {article} найден индикатор: {indicator_class}")

                        # Находим текст статуса (следующий элемент div после индикатора)
                        parent = indicator_element.find_element(By.XPATH, "./..")
                        text_elements = parent.find_elements(By.CSS_SELECTOR, "div.fs-5, div.fw-bold")

                        if text_elements:
                            status_text = text_elements[0].text.strip()
                            logger.debug(f"Для артикула {article} найден текст статуса: {status_text}")

                    # Добавляем в результат
                    if article:
                        result[article] = {
                            "indicator": indicator_class,
                            "text": status_text
                        }

                except Exception as e:
                    logger.warning(f"Ошибка при обработке артикула: {e}")
                    continue

        except Exception as e:
            logger.error(f"Ошибка при сборе статусов из UI: {e}")

        return result

    def _collect_json_statuses(self):
        """
        Собирает коллекцию статусов артикулов из JSON.
        Возвращает словарь: {артикул: {"status": тип_статуса, "text": текст_статуса}}
        """
        logger.debug("Сбор статусов артикулов из JSON")
        result = {}

        # Получаем все элементы заказа
        items = self.json_handler.get_order_items()
        logger.debug(f"Получено {len(items)} элементов заказа из JSON")

        for item in items:
            article = item.get("materialCode")
            if not article:
                continue

            # Находим статусы Process и Finish
            process_status = None
            finish_status = None

            for step in item.get("progressSteps", []):
                status = step.get("status")
                description = step.get("description", "")

                if status == "Process":
                    process_status = {"status": "Process", "text": description}
                    logger.debug(f"Для артикула {article} найден статус Process: {description}")
                elif status == "Finish" and not process_status:
                    finish_status = {"status": "Finish", "text": description}
                    logger.debug(f"Для артикула {article} найден статус Finish: {description}")

            # Приоритет: Process > Finish
            if process_status:
                result[article] = process_status
            elif finish_status:
                result[article] = finish_status
            else:
                result[article] = {"status": None, "text": None}
                logger.debug(f"Для артикула {article} не найдено активных статусов")

        return result

    def _compare_statuses(self, ui_statuses, json_statuses):
        """
        Сравнивает статусы артикулов из UI и JSON.
        Конвертирует классы индикаторов в типы статусов для сравнения.
        """
        logger.info("Сравнение статусов артикулов из UI и JSON")
        results = []

        # Все уникальные артикулы
        all_articles = set(list(ui_statuses.keys()) + list(json_statuses.keys()))
        logger.debug(f"Всего артикулов для сравнения: {len(all_articles)}")

        for article in all_articles:
            ui_info = ui_statuses.get(article, {"indicator": None, "text": None})
            json_info = json_statuses.get(article, {"status": None, "text": None})

            # Конвертируем класс индикатора в тип статуса
            ui_status = self._convert_indicator_to_status(ui_info.get("indicator"))

            # Проверяем совпадение типа статуса
            status_match = ui_status == json_info.get("status")

            # Проверяем совпадение текста
            text_match = True
            ui_text = ui_info.get("text")
            json_text = json_info.get("text")

            if ui_text and json_text:
                ui_text_lower = ui_text.lower()
                json_text_lower = json_text.lower()
                text_match = (ui_text_lower in json_text_lower) or (json_text_lower in ui_text_lower)
                if not text_match:
                    logger.warning(f"Несовпадение текстов статуса для артикула {article}:")
                    logger.warning(f"  В UI: '{ui_text_lower}'")
                    logger.warning(f"  В JSON: '{json_text_lower}'")

            # Если нет статусов ни в UI, ни в JSON - это совпадение
            if not ui_status and not json_info.get("status"):
                status_match = True
                text_match = True

            # Формируем результат
            match = status_match and text_match
            results.append({
                "article": article,
                "match": match,
                "page_color": ui_status or "Отсутствует",
                "page_text": ui_text,
                "json_status": json_info.get("status"),
                "json_text": json_info.get("text"),
                "status_type_match": status_match,
                "text_match": text_match
            })

            logger.debug(f"Артикул {article}: совпадение = {match}")

        return results

    def _convert_indicator_to_status(self, indicator_class):
        """
        Конвертирует класс индикатора в тип статуса.
        """
        if not indicator_class:
            return None

        indicator_class = indicator_class.lower()

        if "blue" in indicator_class:
            return "Process"
        elif "green" in indicator_class:
            return "Finish"
        elif "gray" in indicator_class:
            return "Wait"

        return None

    @allure.step("Проверка кнопок фото")
    def verify_photo_buttons_simple(self):
        """
        Простой и быстрый метод проверки кнопок фото.
        Собирает два списка и сравнивает их.
        Использует небольшое ожидание для стабильности.
        """
        logger.info("Выполняется быстрая проверка кнопок фото")
        # Сохраняем текущее значение
        old_timeout = self.driver.timeouts.implicit_wait

        try:
            # Устанавливаем небольшое ожидание (1 секунды) для стабильности
            self.driver.implicitly_wait(1)
            logger.debug("Установлено минимальное неявное ожидание: 1 секунда")

            # 1. Собираем данные из UI
            with allure.step("Сбор артикулов с кнопками фото из UI"):
                ui_articles_with_photo = []

                # Ищем все артикулы и проверяем наличие кнопок фото
                article_elements = self.find_elements((By.CSS_SELECTOR, "div.accordion.mt-4 div.fs-4.fw-bold"), sec=1)
                logger.debug(f"Найдено {len(article_elements)} элементов артикулов")

                for article_elem in article_elements:
                    article = article_elem.text.strip()
                    if not article:
                        continue

                    # Ищем кнопку фото для этого артикула
                    try:
                        parent = article_elem.find_element(By.XPATH,
                                                           "./ancestor::div[contains(@class, 'accordion-item')]")
                        photo_buttons = parent.find_elements(By.XPATH, ".//button[contains(text(), 'Фото')]")

                        if photo_buttons:
                            ui_articles_with_photo.append(article)
                            logger.debug(f"Для артикула {article} найдена кнопка фото")
                    except Exception as e:
                        logger.warning(f"Ошибка при поиске кнопки фото для артикула {article}: {e}")
                        # Если не удалось найти родительский элемент, считаем что кнопки нет
                        pass

                logger.info(f"Всего артикулов с кнопками фото в UI: {len(ui_articles_with_photo)}")

            # 2. Собираем данные из JSON
            with allure.step("Получение артикулов с фото из JSON"):
                json_articles_with_photo = []

                if self.json_handler and self.json_handler.json_data:
                    items = self.json_handler.json_data.get('objects', [{}])[0].get('items', [])
                    logger.debug(f"Получено {len(items)} элементов заказа из JSON")

                    for item in items:
                        article = item.get('materialCode')
                        if not article:
                            continue

                        # Проверяем наличие фото
                        if 'images' in item and item['images']:
                            for image in item['images']:
                                if image.get('preview', {}).get('absoluteUrl'):
                                    json_articles_with_photo.append(article)
                                    logger.debug(f"Для артикула {article} найдено фото в JSON")
                                    break

                logger.info(f"Всего артикулов с фото в JSON: {len(json_articles_with_photo)}")

            # 3. Проверяем соответствие списков
            with allure.step("Сравнение списков артикулов с фото"):
                match = set(ui_articles_with_photo) == set(json_articles_with_photo)
                logger.info(f"Совпадение списков артикулов с фото: {match}")

                # Дополнительная информация о различиях
                only_in_ui = set(ui_articles_with_photo) - set(json_articles_with_photo)
                only_in_json = set(json_articles_with_photo) - set(ui_articles_with_photo)

                if only_in_ui:
                    logger.warning(f"Артикулы с кнопками фото только в UI: {only_in_ui}")

                if only_in_json:
                    logger.warning(f"Артикулы с фото только в JSON: {only_in_json}")

            # Готовим результат для отчета
            result = {
                'match': match,
                'ui_articles': ui_articles_with_photo,
                'json_articles': json_articles_with_photo
            }

            return match, result

        finally:
            # Восстанавливаем исходное значение ожидания
            self.driver.implicitly_wait(old_timeout)
            logger.debug(f"Восстановлено исходное неявное ожидание: {old_timeout} секунд")

    def get_photos_from_json(self):
        """
        Получает информацию о наличии фото из JSON данных.
        Возвращает словарь {артикул: имеет_фото (True/False)}
        """
        logger.debug("Получение информации о наличии фото из JSON")
        if not self.json_handler:
            logger.warning("JSON обработчик не установлен")
            return {}

        # Делегируем запрос к json_handler
        result = self.json_handler.get_articles_with_photos()
        logger.debug(f"Получено {len(result)} артикулов с информацией о фото")
        return result

    @allure.step("Проверка номеров допоставки")
    def verify_delivery_numbers_fast(self):
        """
        Сверхбыстрая проверка номеров допоставки без длительного ожидания.
        """
        logger.info("Выполняется быстрая проверка номеров допоставки")
        if not self.json_handler:
            logger.error("JSON обработчик не установлен")
            raise ValueError("JSON обработчик не установлен")

        # Сохраняем текущее значение implicit wait
        current_implicit_wait = self.driver.timeouts.implicit_wait

        try:
            # Устанавливаем минимальное время неявного ожидания
            self.driver.implicitly_wait(1)
            logger.debug("Установлено минимальное неявное ожидание: 1 секунда")

            # 1. Сначала проверяем JSON (это быстрая операция)
            with allure.step("Получение номеров допоставки из JSON"):
                json_delivery_numbers = self.json_handler.get_delivery_numbers()
                has_json_deliveries = any(num is not None for num in json_delivery_numbers.values())
                logger.debug(
                    f"Найдено номеров допоставки в JSON: {sum(1 for num in json_delivery_numbers.values() if num is not None)}")

            # 2. Безопасная проверка наличия элементов допоставки на странице
            with allure.step("Проверка наличия элементов допоставки на странице"):
                try:
                    # Используем прямое обращение к driver для надежности
                    delivery_elements = self.driver.find_elements(*BTPServicePageLocators.DELIVERY_NUMBER_ELEMENT)
                    has_ui_deliveries = len(delivery_elements) > 0
                    logger.debug(f"Найдено элементов допоставки на странице: {len(delivery_elements)}")
                except Exception as e:
                    logger.warning(f"Ошибка при поиске элементов допоставки: {e}")
                    has_ui_deliveries = False

            # 3. Если нет допоставок ни в JSON, ни на странице - тест успешен
            if not has_json_deliveries and not has_ui_deliveries:
                logger.info("Нет номеров допоставки в JSON и на странице - тест успешен")
                return True, {"message": "Нет номеров допоставки в JSON и на странице"}

            # 4. Если данные только в одном месте - несоответствие
            if has_json_deliveries and not has_ui_deliveries:
                logger.warning("Несоответствие: есть номера допоставки в JSON, но нет на странице")
                return False, {"message": "Есть номера допоставки в JSON, но нет на странице"}

            if not has_json_deliveries and has_ui_deliveries:
                logger.warning("Несоответствие: есть элементы допоставки на странице, но нет в JSON")
                return False, {"message": "Есть элементы допоставки на странице, но нет в JSON"}

            # 5. Если дошли сюда, выполняем нормальную проверку
            with allure.step("Сбор номеров допоставки со страницы"):
                page_deliveries = self._get_page_delivery_numbers(timeout=3)

            # 6. Сравниваем результаты
            with allure.step("Сравнение номеров допоставки из JSON и страницы"):
                results = []
                all_articles = set(list(json_delivery_numbers.keys()) + list(page_deliveries.keys()))
                logger.debug(f"Всего артикулов для сравнения: {len(all_articles)}")

                for article in all_articles:
                    json_delivery = json_delivery_numbers.get(article)
                    page_delivery_raw = page_deliveries.get(article)

                    # Очищаем номер от "(в работе)"
                    page_delivery_clean = None
                    if page_delivery_raw:
                        page_delivery_clean = page_delivery_raw.replace("(в работе)", "").strip()
                        if not page_delivery_clean:
                            page_delivery_clean = None

                    # Определяем совпадение
                    match = (json_delivery == page_delivery_clean)

                    # Формируем результат
                    result = {
                        'article': article,
                        'match': match,
                        'json_delivery': json_delivery,
                        'page_delivery_raw': page_delivery_raw,
                        'page_delivery_clean': page_delivery_clean
                    }

                    # Добавляем пояснительное сообщение для более понятного вывода
                    if json_delivery is None and page_delivery_clean is None:
                        result['message'] = "Номер допоставки отсутствует в JSON и на странице"
                    elif json_delivery is None:
                        result['message'] = "Номер допоставки есть на странице, но отсутствует в JSON"
                    elif page_delivery_clean is None:
                        result['message'] = "Номер допоставки есть в JSON, но отсутствует на странице"
                    elif json_delivery != page_delivery_clean:
                        result[
                            'message'] = f"Несовпадение номеров: в JSON '{json_delivery}', на странице '{page_delivery_clean}'"

                    results.append(result)
                    logger.debug(f"Артикул {article}: совпадение = {match}")

                # Общий результат
                all_match = all(r['match'] for r in results)
                logger.info(f"Общий результат проверки номеров допоставки: {'✓' if all_match else '✗'}")
                return all_match, results

        finally:
            # Возвращаем исходное значение implicit wait
            self.driver.implicitly_wait(current_implicit_wait)
            logger.debug(f"Восстановлено исходное неявное ожидание: {current_implicit_wait} секунд")

    def _get_delivery_info_from_json(self):
        """Получение информации о доставке из JSON"""
        logger.debug("Получение информации о доставке из JSON")
        if not self.json_handler or not self.json_handler.json_data:
            logger.warning("JSON обработчик не установлен или данные не загружены")
            return []

        try:
            order_object = self.json_handler.get_order_object()
            if not order_object:
                logger.warning("Объект заказа не найден в JSON")
                return []

            # Проверяем, существует ли ключ 'deliveryInfo'
            delivery_info = order_object.get('deliveryInfo')
            if delivery_info is None:
                logger.warning("Ключ 'deliveryInfo' не найден в объекте заказа")
                return []

            logger.debug(f"Получено {len(delivery_info)} записей о доставке из JSON")
            return delivery_info
        except Exception as e:
            logger.error(f"Ошибка при получении данных о доставке из JSON: {e}")
            return []