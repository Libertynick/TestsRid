
from selenium.webdriver.common.by import By
from selenium.common import NoSuchElementException
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys
import allure
import time
from open_pages.btp_service_page.btp_service_locators import AuthPageLocators, BTPServicePageLocators
from base_page.base_page import BasePage
from config import TestEnvironment
from tools.logger import btp_logger as logger
from bs4 import BeautifulSoup


class AuthPage(BasePage):
    """Класс страницы авторизации"""

    def __init__(self, browser, url=TestEnvironment.BTP_BASE_URL):
        """Инициализация страницы авторизации"""
        super().__init__(browser, url)
        logger.info("Инициализирована страница авторизации")

    @allure.step("Авторизация в системе, номер заказа: {order_number}")
    def login(self, order_number=TestEnvironment.BTP_DEFAULT_ORDER_NUMBER, pin_code=TestEnvironment.BTP_DEFAULT_PIN_CODE):
        """Авторизация в системе с улучшенным ожиданием лоадера"""
        logger.info(f"Начало авторизации с данными: {order_number}/{pin_code}")
        self.open()

        with allure.step("Ожидание загрузки страницы авторизации"):
            self.waiting_element_is_visibility_located_dom(AuthPageLocators.ORDER_NUMBER_INPUT)
            logger.debug("Страница авторизации загружена")

        with allure.step(f"Ввод номера заказа: {order_number}"):
            order_input = self.find_element(AuthPageLocators.ORDER_NUMBER_INPUT)
            order_input.clear()
            order_input.send_keys(order_number)
            logger.debug(f"Введен номер заказа: {order_number}")

        with allure.step(f"Ввод пин-кода: {pin_code}"):
            pin_input = self.find_element(AuthPageLocators.PIN_CODE_INPUT)
            pin_input.clear()
            pin_input.send_keys(pin_code)
            logger.debug(f"Введен пин-код: {pin_code}")

        with allure.step("Нажатие кнопки входа"):
            self.find_element(AuthPageLocators.SUBMIT_BUTTON).click()
            logger.debug("Кнопка входа нажата")

        # Ожидаем исчезновение лоадера с таймаутом 60 секунд
        with allure.step("Ожидание исчезновения лоадера и загрузки страницы"):
            self._wait_for_spinner_border_disappear(60)
            logger.debug("Лоадер исчез, страница загружается...")

        try:
            with allure.step("Ожидание загрузки страницы заказа"):
                self.waiting_element_is_visibility_located_dom(
                    (By.XPATH, "//div[@class='fs-5 fw-bold'][contains(text(), 'Номер заказа')]"),
                    sec=20
                )
                logger.debug("Страница заказа загружена")
        except Exception:
            logger.error("Ошибка авторизации: не удалось загрузить страницу заказа")
            return False

        # Ждем стабилизации URL
        with allure.step(f"Ожидание перехода на URL заказа: {order_number}"):
            wait = WebDriverWait(self.driver, TestEnvironment.BROWSER_TIMEOUT)
            wait.until(EC.url_contains(f"/{order_number}"))
            logger.debug(f"URL содержит номер заказа: {order_number}")

        # Проверяем, что авторизация успешна
        current_url = self.driver.current_url
        success = current_url == f"{TestEnvironment.BTP_BASE_URL}/{order_number}"

        if success:
            logger.info(f"Авторизация успешна: {current_url}")
        else:
            logger.error(
                f"Авторизация не удалась. Текущий URL: {current_url}, ожидаемый: {TestEnvironment.BTP_BASE_URL}/{order_number}")

        return success

    def _wait_for_spinner_border_disappear(self, timeout_seconds=60):
        """
        Ожидание исчезновения лоадера с классом spinner-border.

        Args:
            timeout_seconds: Максимальное время ожидания в секундах
        """
        logger.info(f"Ожидание исчезновения лоадера spinner-border (таймаут: {timeout_seconds} сек)")

        try:
            # Используем явное ожидание с увеличенным таймаутом
            wait = WebDriverWait(self.driver, timeout_seconds)
            wait.until(EC.invisibility_of_element_located((By.CSS_SELECTOR, "div.spinner-border")))
            logger.info("Лоадер spinner-border исчез")
            return True
        except Exception as e:
            logger.warning(f"Проблема при ожидании исчезновения лоадера spinner-border: {e}")

            # Проверяем, может страница уже загрузилась, несмотря на проблему с ожиданием лоадера
            try:
                header_present = self.driver.find_elements(
                    By.XPATH, "//div[@class='fs-5 fw-bold'][contains(text(), 'Номер заказа')]"
                )
                if header_present:
                    logger.info(
                        "Несмотря на проблему с лоадером, страница, похоже, загрузилась (найден заголовок заказа)")
                    return True
            except:
                pass

            return False


class BTPServicePage(BasePage):
    """Класс страницы сервиса БТП"""

    def __init__(self, browser, json_handler=None, order_number=None):
        """Инициализация страницы сервиса БТП"""
        super().__init__(browser, TestEnvironment.BTP_BASE_URL)
        self.json_handler = json_handler
        self.order_number = order_number
        # Кэш для часто используемых данных
        self._cache = {}
        logger.info(f"Инициализирована страница BTPServicePage с заказом {order_number}")

    @allure.step("Установка обработчика JSON")
    def set_json_handler(self, json_handler):
        """Установка обработчика JSON для проверок"""
        self.json_handler = json_handler
        # Сбрасываем кэш при изменении обработчика
        self._cache = {}
        logger.info("Установлен JSON обработчик для страницы BTP")

    @allure.step("Установка номера заказа: {order_number}")
    def set_order_number(self, order_number):
        """Установка номера заказа для проверок"""
        self.order_number = order_number
        logger.info(f"Установлен номер заказа: {order_number}")

    @allure.step("Получение номера заказа со страницы")
    def get_order_number(self):
        """Получение номера заказа со страницы"""
        order_number_elem = self.find_element(BTPServicePageLocators.ORDER_NUMBER_HEADER)
        order_number = order_number_elem.text.strip()
        logger.info(f"Получен номер заказа со страницы: {order_number}")
        return order_number

    @allure.step("Получение статуса заказа со страницы")
    def get_order_status(self):
        """Получение статуса заказа со страницы"""
        logger.info("Получение статуса заказа со страницы")
        try:
            # Находим блок "Актуальный статус заказа"
            status_block = self.driver.find_element(By.XPATH,
                                                    "//p[contains(text(), 'Актуальный статус заказа')]/following-sibling::ul[@class='list-unstyled']")
            logger.debug("Найден блок статуса заказа")

            # Получаем элементы li из найденного списка
            status_items = status_block.find_elements(By.TAG_NAME, "li")
            logger.debug(f"Найдено {len(status_items)} элементов статуса")

            statuses = []
            for item in status_items:
                # Получаем текст и удаляем часть "подробнее"
                status_text = item.text.strip()
                if "\nподробнее" in status_text:
                    status_text = status_text.replace("\nподробнее", "")
                statuses.append(status_text)
                logger.debug(f"Получен статус: {status_text}")

            return statuses
        except NoSuchElementException:
            logger.warning("Не найден блок статуса заказа, использую запасной вариант")
            # Запасной вариант: ищем просто первый список list-unstyled на странице
            try:
                first_list = self.driver.find_element(By.CSS_SELECTOR, "ul.list-unstyled")
                status_items = first_list.find_elements(By.TAG_NAME, "li")
                statuses = []
                for item in status_items:
                    # Получаем текст и удаляем часть "подробнее"
                    status_text = item.text.strip()
                    if "\nподробнее" in status_text:
                        status_text = status_text.replace("\nподробнее", "")
                    statuses.append(status_text)
                    logger.debug(f"Получен статус (запасной вариант 1): {status_text}")
                return statuses
            except NoSuchElementException:
                logger.warning("Не найден список статусов, использую второй запасной вариант")
                # Крайний случай - используем оригинальный локатор
                status_items = self.find_elements(BTPServicePageLocators.STATUS_ITEMS)
                statuses = []
                for item in status_items:
                    status_text = item.text.strip()
                    if "\nподробнее" in status_text:
                        status_text = status_text.replace("\nподробнее", "")
                    statuses.append(status_text)
                    logger.debug(f"Получен статус (запасной вариант 2): {status_text}")
                return statuses

    @allure.step("Получение списка артикулов со страницы")
    def get_articles(self):
        """Получение списка артикулов со страницы"""
        logger.info("Получение списка артикулов со страницы")

        # Используем кэш, если данные уже получены
        if 'articles' in self._cache:
            logger.debug("Используются кэшированные артикулы")
            return self._cache['articles']

        articles = []

        # Находим все элементы аккордеона с артикулами
        with allure.step("Поиск элементов аккордеона с артикулами"):
            accordion_items = self.find_elements(BTPServicePageLocators.ARTICLE_ACCORDION_ITEMS)
            logger.debug(f"Найдено {len(accordion_items)} элементов аккордеона")

        for item in accordion_items:
            try:
                # Ищем номер артикула в заголовке каждого аккордеона
                article_element = item.find_element(*BTPServicePageLocators.ARTICLE_HEADERS)
                article_number = article_element.text.strip()

                if article_number:
                    articles.append(article_number)
                    logger.debug(f"Найден артикул: {article_number}")
            except NoSuchElementException:
                logger.warning("Не удалось найти заголовок артикула в элементе аккордеона")
                continue

        logger.info(f"Всего получено {len(articles)} артикулов со страницы")

        # Сохраняем в кэше
        self._cache['articles'] = articles
        return articles

    @allure.step("Закрытие попапа")
    def close_popup(self):
        """Закрывает попап, если он открыт."""
        logger.info("Попытка закрыть попап, если он открыт")
        try:
            # Проверяем, есть ли открытый попап
            popup_elements = self.driver.find_elements(*BTPServicePageLocators.POPUP_DIALOG)
            if len(popup_elements) > 0 and popup_elements[0].is_displayed():
                logger.debug("Найден открытый попап")
                close_button = popup_elements[0].find_element(*BTPServicePageLocators.POPUP_CLOSE_BUTTON)
                close_button.click()
                logger.debug("Нажата кнопка закрытия")

                # Ждем исчезновения попапа
                wait = WebDriverWait(self.driver,TestEnvironment.BROWSER_TIMEOUT)
                wait.until(EC.invisibility_of_element_located(BTPServicePageLocators.POPUP_DIALOG))
                logger.info("Попап успешно закрыт")
                return True
        except Exception as e:
            logger.warning(f"Ошибка при закрытии попапа: {e}")
            pass

        logger.debug("Открытый попап не найден или уже закрыт")
        return False

    # Основные методы для проверки всех этапов

    @allure.step("Проверка этапов для всех артикулов")
    def verify_stages_one_by_one(self):
        """
        Сверхбыстрая проверка этапов для всех артикулов.
        Получает все содержимое всех аккордеонов за один раз без открытия,
        затем анализирует данные в памяти Python.
        """
        if not self.json_handler:
            logger.error("JSON обработчик не установлен")
            raise ValueError("JSON обработчик не установлен")

        logger.info("Начинаем сверхбыструю проверку этапов без открытия аккордеонов...")

        # 1. Получаем данные из JSON
        with allure.step("Получение данных о этапах из JSON"):
            json_data = self._get_json_stages_data()
            logger.debug(f"Собрано из JSON: {len(json_data)} артикулов")

        # 2. Получаем данные со страницы
        with allure.step("Получение HTML содержимого страницы"):
            page_html = self._get_html_content()
            logger.debug(f"Получен HTML страницы размером {len(page_html)} символов")

        # 3. Извлекаем данные из HTML
        with allure.step("Извлечение данных о этапах из HTML"):
            page_data = self._parse_html_for_stages(page_html)
            logger.info(f"Обработка HTML завершена, собраны данные для: {len(page_data)} артикулов")

        # 4. Сравниваем данные и формируем отчет
        with allure.step("Сравнение данных и формирование отчета"):
            results = self._compare_and_report_stages(json_data, page_data)

        # Определяем общий результат
        all_match = all(r['match'] for r in results)

        # Выводим общую статистику
        logger.info("=" * 80)
        logger.info("ИТОГОВАЯ СТАТИСТИКА")
        logger.info("=" * 80)

        matches = sum(1 for r in results if r['match'])
        logger.info(f"Проверено артикулов: {len(results)}")
        logger.info(f"Совпадений: {matches}")
        logger.info(f"Несовпадений: {len(results) - matches}")
        logger.info(f"Общий результат: {'✓' if all_match else '✗'}")

        return all_match, results

    def _get_json_stages_data(self):
        """Получение данных о этапах из JSON с учетом группы 'Производство'"""
        logger.debug("Получение данных о этапах из JSON")
        json_data = {}

        for item in self.json_handler.get_order_items():
            article = item.get('materialCode')
            if not article:
                continue

            article_data = {'Process': [], 'Finish': [], 'Wait': []}

            # Создаем структуру для отслеживания этапов производства по группам
            production_stages = {
                'Process': [], 'Finish': [], 'Wait': []
            }

            for step in item.get('progressSteps', []):
                status_type = step.get('status')
                if status_type not in article_data:
                    continue

                text = step.get('description', '').lower()
                if text:
                    article_data[status_type].append(text)

                # Проверяем groupName этапа
                group_name = step.get('groupName', '').lower()

                # Если это группа "Производство", запоминаем отдельно
                if group_name == 'производство':
                    production_stages[status_type].append(text)

            # Добавляем информацию о производственных этапах в данные артикула
            json_data[article] = {
                **article_data,
                'production_stages': production_stages
            }

        logger.debug(f"Собраны данные о этапах для {len(json_data)} артикулов из JSON")
        return json_data

    def _get_html_content(self):
        """Получение HTML-содержимого страницы"""
        logger.debug("Получаем содержимое всей страницы для анализа...")

        try:
            all_accordion_container = self.driver.find_element(By.CSS_SELECTOR, "div.accordion")
            page_html = all_accordion_container.get_attribute('outerHTML')
            logger.debug(f"Получен HTML аккордеона, размер: {len(page_html)} символов")
        except Exception as e:
            logger.error(f"Ошибка при получении HTML аккордеона: {e}")
            # Запасной вариант - получаем HTML всей страницы
            page_html = self.driver.find_element(By.TAG_NAME, "body").get_attribute('outerHTML')
            logger.warning(f"Используется запасной вариант - HTML всей страницы, размер: {len(page_html)} символов")

        return page_html

    def _parse_html_for_stages(self, page_html):
        """Извлечение данных о этапах из HTML"""
        global article
        logger.info("Обработка HTML страницы...")

        soup = BeautifulSoup(page_html, 'html.parser')

        # Находим все аккордеоны
        accordion_items = soup.select("div.accordion-item")
        logger.debug(f"Найдено аккордеонов в HTML: {len(accordion_items)}")

        # Словарь для результатов
        page_data = {}

        # Обрабатываем каждый аккордеон
        for item in accordion_items:
            try:
                # Получаем номер артикула
                header = item.select_one("div.fs-4.fw-bold")
                if not header:
                    continue

                article = header.get_text().strip()
                if not article:
                    continue

                logger.debug(f"Обработка артикула: {article}")

                # Инициализируем данные для артикула
                page_data[article] = {'Process': [], 'Finish': [], 'Wait': []}

                # Находим содержимое аккордеона - div с классом accordion-body
                accordion_body = self._find_accordion_body(item)

                if not accordion_body:
                    logger.warning(f"Не найдено содержимое аккордеона для {article}")
                    continue

                logger.debug(f"Найдено содержимое аккордеона для {article}")

                # Извлекаем этапы для артикула
                self._extract_stages_from_accordion(accordion_body, page_data[article])

                # Выводим информацию о собранных этапах
                logger.debug(f"Этапы для {article}: Process={len(page_data[article]['Process'])}, " +
                             f"Finish={len(page_data[article]['Finish'])}, Wait={len(page_data[article]['Wait'])}")

            except Exception as e:
                logger.error(f"Ошибка при обработке артикула {article}: {e}")

        return page_data

    def _find_accordion_body(self, accordion_item):
        """Поиск тела аккордеона в HTML"""
        logger.debug("Поиск тела аккордеона")
        accordion_body = accordion_item.select_one("div.accordion-body")
        if not accordion_body:
            # Пробуем альтернативный вариант, ищем по id
            logger.debug("Не найдено тело аккордеона по прямому селектору, пробуем альтернативный вариант")
            accordion_collapse = accordion_item.select_one("div.accordion-collapse")
            if accordion_collapse:
                accordion_body = accordion_collapse.select_one("div.accordion-body")

        return accordion_body

    def _extract_stages_from_accordion(self, accordion_body, article_data):
        """Извлечение этапов из тела аккордеона с особой обработкой производственных этапов"""
        logger.debug("Извлечение этапов из тела аккордеона")
        # Ищем элементы с этапами - они в div с классами d-flex align-items-center
        stage_containers = accordion_body.select("div.d-flex.align-items-center")
        logger.debug(f"Найдено {len(stage_containers)} контейнеров с этапами")

        for container in stage_containers:
            # Определяем статус по индикатору
            status_type = self._detect_status_type(container)

            if not status_type:
                continue

            # Ищем текст этапа - он находится в div рядом с индикатором
            stage_text_elem = container.select_one("div.fs-5") or container.select_one(
                "div.fs-6") or container.select_one("div.text-gray")

            if stage_text_elem:
                text = stage_text_elem.get_text().strip().lower()
                if text and text not in ['', '.', 'подробнее']:
                    article_data[status_type].append(text)
                    logger.debug(f"Добавлен этап типа {status_type}: {text}")

                    # Если это этап производства, сохраняем его в специальную структуру
                    if "производство" in text:
                        if 'production_stages' not in article_data:
                            article_data['production_stages'] = {'Process': [], 'Finish': [], 'Wait': []}
                        article_data['production_stages'][status_type].append(text)
                        logger.debug(f"Добавлен производственный этап типа {status_type}: {text}")

    def _detect_status_type(self, container):
        """Определение типа статуса по индикатору"""
        if container.select_one("i.service-btp_icon--blue") or container.select_one(
                "svg.text-primary") or container.select_one("[class*='blue']"):
            return 'Process'
        elif container.select_one("i.service-btp_icon--green") or container.select_one(
                "svg.text-success") or container.select_one("[class*='green']"):
            return 'Finish'
        elif container.select_one("i.service-btp_icon--gray") or container.select_one(
                "svg.text-secondary") or container.select_one("[class*='gray']"):
            return 'Wait'
        return None

    def _compare_and_report_stages(self, json_data, page_data):
    """Сравнение данных и формирование отчета с учетом группы 'Производство'"""
    logger.info("Сравнение данных из JSON и страницы")
    results = []

    # Детальный вывод всех данных
    logger.info("=" * 80)
    logger.info("ДЕТАЛЬНЫЙ ВЫВОД ВСЕХ ЭТАПОВ ДЛЯ КАЖДОГО АРТИКУЛА")
    logger.info("=" * 80)

    # Сортируем артикулы для удобства анализа
    all_articles = sorted(list(set(list(json_data.keys()) + list(page_data.keys()))))

    for article in all_articles:
        logger.info(f"\nАРТИКУЛ: {article}")
        logger.info("-" * 50)

        json_article_data = json_data.get(article, {})
        page_article_data = page_data.get(article, {})

        article_match = True
        mismatches = []

        # НОВАЯ ЛОГИКА: Специальная проверка для этапов производства
        production_mismatch = self._check_production_logic(article, json_article_data, page_article_data)
        if production_mismatch:
            article_match = False
            mismatches.append(production_mismatch)

        # УДАЛЯЕМ НЕПРАВИЛЬНУЮ ПРОВЕРКУ!
        # Старая логика была неправильной - зеленый цвет не означает что ВСЕ производство завершено,
        # а означает что показывается последний завершенный этап

        # ОРИГИНАЛЬНАЯ ЛОГИКА: Стандартная проверка для всех типов статусов
        for status_type in ['Process', 'Finish', 'Wait']:
            json_stages = json_article_data.get(status_type, [])
            page_stages = page_article_data.get(status_type, [])


            # ИСКЛЮЧАЕМ этапы "производство" из обычной проверки!
            # Они уже проверены в специальной логике производства
            filtered_page_stages = []
            for stage in page_stages:
                if "производство" not in self._normalize_stage_text(stage):
                    filtered_page_stages.append(stage)
                else:
                    logger.debug(f"Исключаем этап производства из обычной проверки: {stage}")
            
            page_stages = filtered_page_stages
            
            # Выводим данные для каждого типа статуса
            logger.info(f"\nСтатус: {status_type} (без производства)")
            logger.info(f"  В UI ({len(page_stages)}):")
            for stage in page_stages:
                logger.info(f"    - {stage}")

            logger.info(f"  В JSON ({len(json_stages)}):")
            for stage in json_stages:
                logger.info(f"    - {stage}")

            # Если нет этапов на странице, пропускаем сравнение
            if not page_stages:
                logger.info("  Результат: На странице нет этапов для сравнения")
                continue

            # Нормализуем тексты этапов для сравнения
            json_stages_norm = [self._normalize_stage_text(stage) for stage in json_stages]
            page_stages_norm = [self._normalize_stage_text(stage) for stage in page_stages]

            # Проверяем, что каждый этап из UI присутствует в JSON
            missing_stages = []

            for i, page_stage in enumerate(page_stages_norm):
                found = False
                for json_stage in json_stages_norm:
                    # Проверяем, что текст этапа из UI содержится в JSON или наоборот
                    if (page_stage in json_stage) or (json_stage in page_stage):
                        found = True
                        break

                if not found:
                    missing_stages.append(page_stages[i])

            # Выводим результат сравнения
            if missing_stages:
                logger.warning("  Результат: ✗ Несоответствие!")
                logger.warning("  Этапы из UI, не найденные в JSON:")
                for stage in missing_stages:
                    logger.warning(f"    - {stage}")

                article_match = False
                mismatches.append({
                    'status_type': status_type,
                    'json_stages': json_stages,
                    'page_stages': page_stages,
                    'missing_in_json': missing_stages
                })
            else:
                logger.info("  Результат: ✓ Все этапы из UI найдены в JSON")

        results.append({
            'article': article,
            'match': article_match,
            'mismatches': mismatches
        })

    return results
    

    def _find_production_stage_in_ui(self, page_article_data):
        """
        Находит этап производства в данных UI
        """
        for status_type in ['Process', 'Finish', 'Wait']:
            for stage_text in page_article_data.get(status_type, []):
                if "производство" in self._normalize_stage_text(stage_text):
                    return {
                        'color': status_type,
                        'text': stage_text
                    }
        return None

    def _get_expected_production_display(self, production_stages, is_outsource):
        """
        Определяет ожидаемый цвет и текст для этапа производства
        
        Логика:
        - Цвет: Process > Finish > Wait
        - Текст для isOutsource=true: просто "производство"  
        - Текст для isOutsource=false: "производство.{этап}" где этап определяется по приоритету:
          Process (первый) > Finish (последний) > Wait (первый)
        """
        # Определяем ожидаемый цвет по приоритету
        if production_stages.get('Process'):
            expected_color = 'Process'
        elif production_stages.get('Finish'):
            expected_color = 'Finish'
        elif production_stages.get('Wait'):
            expected_color = 'Wait'
        else:
            expected_color = 'Wait'  # По умолчанию

        # Определяем ожидаемый текст
        if is_outsource:
            # Для аутсорса → просто "производство"
            expected_text = "производство"
        else:
            # Для собственного производства → "производство.{конкретный_этап}"
            if production_stages.get('Process'):
                # Если есть Process этапы → показываем первый Process этап
                expected_text = f"производство.{production_stages['Process'][0]}"
            elif production_stages.get('Finish'):
                # Если нет Process, но есть Finish → показываем последний Finish этап
                expected_text = f"производство.{production_stages['Finish'][-1]}"
            elif production_stages.get('Wait'):
                # Если нет Process и Finish, но есть Wait → показываем первый Wait этап
                expected_text = f"производство.{production_stages['Wait'][0]}"
            else:
                # Если вообще нет этапов производства → просто "производство"
                expected_text = "производство"

        return expected_color, expected_text

    def _normalize_stage_text(self, text):
        """
        Нормализация текста этапа для корректного сравнения
        
        Удаляет валидные UI-дополнения: "(в работе)", переносы строк, лишние пробелы
        Заменяет знаки пунктуации на пробелы для корректного сравнения
        """
        if not text:
            return ""

        # Приводим к нижнему регистру
        text = text.lower().strip()
        
        # Удаляем валидные UI-дополнения
        text = text.replace('(в работе)', '')  # UI может добавлять статус "(в работе)"
        text = text.replace('\n', ' ')         # Убираем переносы строк
        
        # ИСПРАВЛЕНИЕ: Заменяем точки и запятые на пробелы, а не удаляем их!
        text = text.replace('.', ' ').replace(',', ' ')

        # Удаляем лишние пробелы (может появиться несколько подряд после замен)
        text = ' '.join(text.split())

        return text

    def _check_production_logic(self, article, json_article_data, page_article_data):
        """
        Проверка специальной логики для этапов производства
        
        Учитывает isOutsource и правильно определяет ожидаемый вид этапа производства в UI
        """
        logger.info(f"\n🏭 ПРОВЕРКА ЛОГИКИ ПРОИЗВОДСТВА для {article}")

        # Получаем isOutsource для артикула
        is_outsource = self.json_handler.get_is_outsource(article)
        logger.info(f"  isOutsource: {is_outsource}")

        # Получаем производственные этапы из JSON
        production_stages = json_article_data.get('production_stages', {'Process': [], 'Finish': [], 'Wait': []})
        logger.info(f"  Производственные этапы в JSON:")
        logger.info(f"    Process: {production_stages.get('Process', [])}")
        logger.info(f"    Finish: {production_stages.get('Finish', [])}")
        logger.info(f"    Wait: {production_stages.get('Wait', [])}")

        # Ищем этап "Производство" в UI
        ui_production_stage = self._find_production_stage_in_ui(page_article_data)
        if not ui_production_stage:
            logger.info("  В UI нет этапа 'Производство' - проверка пропущена")
            return None

        logger.info(f"  Этап производства в UI: {ui_production_stage}")

        # Определяем ожидаемый цвет и текст
        expected_color, expected_text = self._get_expected_production_display(production_stages, is_outsource)
        logger.info(f"  Ожидаемый цвет: {expected_color}")
        logger.info(f"  Ожидаемый текст: {expected_text}")

        # Проверяем соответствие цвета
        color_match = ui_production_stage['color'] == expected_color

        # Нормализуем тексты для сравнения
        ui_text_normalized = self._normalize_stage_text(ui_production_stage['text'])
        expected_text_normalized = self._normalize_stage_text(expected_text)
        
        # Проверяем вхождение текста (учитываем что UI может содержать дополнительную информацию)
        text_match = (expected_text_normalized in ui_text_normalized) or (ui_text_normalized == expected_text_normalized)

        logger.info(f"  Совпадение цвета: {'✓' if color_match else '✗'}")
        logger.info(f"  Совпадение текста: {'✓' if text_match else '✗'}")
        logger.info(f"  UI текст (нормализованный): '{ui_text_normalized}'")
        logger.info(f"  Ожидаемый текст (нормализованный): '{expected_text_normalized}'")

        if color_match and text_match:
            logger.info("  Результат: ✓ Логика производства соблюдена")
            return None
        else:
            logger.warning("  Результат: ✗ Логика производства нарушена")
            return {
                'status_type': 'Production',
                'message': 'Нарушена логика отображения производства',
                'expected_color': expected_color,
                'actual_color': ui_production_stage['color'],
                'expected_text': expected_text,
                'actual_text': ui_production_stage['text'],
                'is_outsource': is_outsource,
                'production_stages': production_stages
            }

    @allure.step("Проверка номеров допоставки")
    @allure.step("Проверка попапов доставки")
    def verify_delivery_popups_fast(self):
        """
        Быстрая проверка попапов с информацией о доставке.
        Сначала проверяет наличие данных в JSON, затем быстро проверяет UI.
        """
        logger.info("Выполняется быстрая проверка попапов доставки")
        # 1. Получаем информацию из JSON (без ожидания)
        with allure.step("Получение информации о доставке из JSON"):
            json_delivery_info = self._get_delivery_info_from_json()
            json_delivery_count = len(json_delivery_info) if isinstance(json_delivery_info, list) else 0
            logger.debug(f"Количество записей о доставке в JSON: {json_delivery_count}")

        # 2. Если в JSON нет данных, быстро проверяем UI
        if json_delivery_count == 0:
            with allure.step("Проверка наличия ссылок на попапы в UI"):
                try:
                    # Ищем ссылки на попапы с минимальным таймаутом
                    delivery_links = self.find_elements(BTPServicePageLocators.DELIVERY_POPUP_LINKS, sec=1)
                    logger.debug(f"Найдено ссылок на попапы в UI: {len(delivery_links)}")

                    if not delivery_links:
                        logger.info("Нет элементов доставки в JSON и UI - тест пропущен")
                        return {
                            "success": True,
                            "skip_test": True,
                            "skip_reason": "Нет элементов доставки в JSON и UI"
                        }
                except Exception as e:
                    logger.warning(f"Ошибка при проверке ссылок на попапы: {e}")
                    logger.info("Нет элементов доставки в JSON и UI - тест пропущен")
                    return {
                        "success": True,
                        "skip_test": True,
                        "skip_reason": "Нет элементов доставки в JSON и UI"
                    }

        # 3. Получаем количество ссылок на попапы в UI
        with allure.step("Подсчет количества ссылок на попапы в UI"):
            timeout = 5 if json_delivery_count > 0 else 2
            logger.debug(f"Таймаут для поиска ссылок: {timeout} секунд")

            try:
                delivery_links = self.find_elements(BTPServicePageLocators.DELIVERY_POPUP_LINKS, sec=timeout)
                ui_delivery_count = len(delivery_links)
                logger.debug(f"Найдено ссылок на попапы в UI: {ui_delivery_count}")
            except Exception as e:
                logger.warning(f"Ошибка при поиске ссылок на попапы: {e}")
                ui_delivery_count = 0

        # 4. Проверяем соответствие количества
        count_match = json_delivery_count == ui_delivery_count
        logger.info(f"Совпадение количества записей о доставке: {count_match}")

        # 5. Если количество не совпадает, возвращаем результат
        if not count_match:
            logger.warning(
                f"Количество элементов доставки не совпадает: в JSON {json_delivery_count}, на странице {ui_delivery_count}")
            return {
                "success": False,
                "skip_test": False,
                "json_delivery_count": json_delivery_count,
                "ui_delivery_count": ui_delivery_count,
                "count_match": False,
                "message": (f"Количество элементов доставки не совпадает: " +
                            f"в JSON {json_delivery_count}, на странице {ui_delivery_count}")
            }

        # 6. Если нет элементов для проверки, возвращаем успешный результат
        if ui_delivery_count == 0:
            logger.info("Нет элементов доставки в JSON и UI - тест пропущен")
            return {
                "success": True,
                "skip_test": True,
                "skip_reason": "Нет элементов доставки в JSON и UI",
                "count_match": True
            }

        # 7. Проверяем попапы, только если есть данные для проверки
        with allure.step("Проверка попапов доставки"):
            processed_count = 0

            # 8. Для каждой ссылки на попап
            for i in range(min(ui_delivery_count, 3)):  # Проверяем не более 3 попапов
                try:
                    # Находим все ссылки заново (они могли измениться после открытия/закрытия попапа)
                    delivery_links = self.find_elements(BTPServicePageLocators.DELIVERY_POPUP_LINKS, sec=2)
                    logger.debug(f"Найдено ссылок на попапы: {len(delivery_links)}")

                    if i >= len(delivery_links):
                        logger.warning(f"Не найдено достаточно ссылок на попапы, пропуск попапа #{i + 1}")
                        break

                    # Получаем ID целевого попапа
                    popup_target = delivery_links[i].get_attribute("data-bs-target")
                    popup_id = popup_target.replace("#", "")
                    logger.debug(f"ID попапа #{i + 1}: {popup_id}")

                    # Открываем попап
                    logger.debug(f"Нажатие на ссылку попапа #{i + 1}")
                    delivery_links[i].click()

                    # Ждем открытия попапа с коротким таймаутом
                    logger.debug(f"Ожидание открытия попапа #{i + 1}...")
                    wait = WebDriverWait(self.driver, 3)
                    wait.until(
                        EC.visibility_of_element_located((By.ID, popup_id))
                    )
                    logger.info(f"Попап #{i + 1} успешно открыт")

                    # Закрываем попап
                    logger.debug(f"Закрытие попапа #{i + 1}")
                    close_button = self.driver.find_element(By.CSS_SELECTOR, f"#{popup_id} button.btn-close")
                    close_button.click()

                    # Ждем закрытия попапа
                    logger.debug(f"Ожидание закрытия попапа #{i + 1}...")
                    wait.until(
                        EC.invisibility_of_element_located((By.ID, popup_id))
                    )
                    logger.info(f"Попап #{i + 1} успешно закрыт")

                    processed_count += 1

                except Exception as e:
                    logger.error(f"Ошибка при проверке попапа #{i + 1}: {e}")

            logger.info(f"Проверено попапов: {processed_count} из {ui_delivery_count}")

        # 9. Результат
        result = {
            "success": processed_count > 0,
            "json_delivery_count": json_delivery_count,
            "ui_delivery_count": ui_delivery_count,
            "processed_count": processed_count,
            "count_match": count_match,
            "all_popups_processed": processed_count == ui_delivery_count,
            "skip_test": False
        }

        logger.info(f"Общий результат проверки попапов доставки: {'✓' if result['success'] else '✗'}")
        return result

    def _get_page_delivery_numbers(self, timeout=3):
        """
        Оптимизированное получение номеров допоставки со страницы
        Сохраняет оригинальный текст с префиксом "(в работе)"
        Принимает параметр timeout для быстрых проверок
        """
        logger.debug(f"Получение номеров допоставки со страницы (таймаут: {timeout})")
        page_delivery_numbers = {}

        try:
            # Находим все элементы артикулов с коротким таймаутом
            article_elements = self.find_elements(
                BTPServicePageLocators.ARTICLE_ACCORDION_ITEMS,
                timeout
            )
            logger.debug(f"Найдено {len(article_elements)} элементов артикулов")

            for element in article_elements:
                try:
                    # Ищем номер артикула
                    article_element = element.find_element(*BTPServicePageLocators.ARTICLE_HEADERS)
                    article = article_element.text.strip()
                    if not article:
                        continue

                    # Ищем элементы с номером допоставки
                    delivery_elements = element.find_elements(*BTPServicePageLocators.DELIVERY_NUMBER)

                    delivery_number = None
                    # Обрабатываем найденные элементы
                    for delivery_elem in delivery_elements:
                        text = delivery_elem.text.strip()
                        if "№" in text:
                            parts = text.split("№", 1)
                            if len(parts) > 1:
                                delivery_number = parts[1].strip()
                                logger.debug(f"Для артикула {article} найден номер допоставки: {delivery_number}")
                                break

                    # Добавляем в словарь
                    page_delivery_numbers[article] = delivery_number

                except Exception as e:
                    logger.warning(f"Ошибка при обработке артикула для номера допоставки: {e}")
                    continue

        except Exception as e:
            logger.error(f"Ошибка при получении номеров допоставки: {e}")
            # В случае ошибки (например, истек таймаут) возвращаем пустой словарь
            return {}

        return page_delivery_numbers

    @allure.step("Проверка номера заказа")
    def verify_order_number(self):
        """Проверка совпадения номера заказа на странице с введенным при авторизации"""
        logger.info("Проверка номера заказа")
        if not self.order_number:
            logger.error("Номер заказа не установлен")
            raise ValueError("Номер заказа не установлен")

        with allure.step("Получение номера заказа со страницы"):
            page_order_number = self.get_order_number()
            logger.info(f"Номер заказа на странице: {page_order_number}")
            logger.info(f"Ожидаемый номер заказа: {self.order_number}")

        with allure.step("Сравнение номеров заказа"):
            match = page_order_number == self.order_number
            logger.info(f"Номера заказов совпадают: {match}")

        return match, {
            'page': page_order_number,
            'expected': self.order_number
        }

    @allure.step("Проверка статуса заказа")
    def verify_order_status(self):
        """Проверка статуса заказа на странице и в JSON"""
        logger.info("Проверка статуса заказа")
        if not self.json_handler:
            logger.error("JSON обработчик не установлен")
            raise ValueError("JSON обработчик не установлен")

        with allure.step("Получение статусов заказа со страницы"):
            page_statuses = self.get_order_status()
            logger.info(f"Статусы на странице: {page_statuses}")

        with allure.step("Получение статусов заказа из JSON"):
            json_statuses = self.json_handler.get_order_statuses()
            logger.info(f"Статусы в JSON: {json_statuses}")

        # Сравниваем статусы
        with allure.step("Сравнение статусов"):
            status_match = set(page_statuses) == set(json_statuses)
            logger.info(f"Статусы совпадают: {status_match}")

        return status_match, {
            'page': page_statuses,
            'json': json_statuses
        }

    @allure.step("Проверка артикулов")
    def verify_articles(self):
        """Проверка артикулов на странице и в JSON"""
        logger.info("Проверка артикулов")
        if not self.json_handler:
            logger.error("JSON обработчик не установлен")
            raise ValueError("JSON обработчик не установлен")

        with allure.step("Получение артикулов со страницы"):
            page_articles = self.get_articles()
            logger.info(f"Артикулы на странице: {page_articles}")

        with allure.step("Получение артикулов из JSON"):
            json_articles = self.json_handler.get_articles()
            logger.info(f"Артикулы в JSON: {json_articles}")

        # Сравниваем артикулы
        with allure.step("Сравнение артикулов"):
            articles_match = set(page_articles) == set(json_articles)
            logger.info(f"Артикулы совпадают: {articles_match}")

        return articles_match, {
            'page': page_articles,
            'json': json_articles
        }

    @allure.step("Проверка номеров материалов")
    def verify_material_numbers(self):
        """
        Простой и быстрый тест проверки номеров материалов допоставки.
        """
        logger.info("Проверка номеров материалов допоставки")

        # Шаг 1: Безопасная проверка наличия кнопки подробнее и материалов в JSON
        with allure.step("Проверка кнопки 'подробнее' и материалов в JSON"):
            try:
                # Устанавливаем минимальное ожидание для быстрой проверки
                original_implicit_wait = self.driver.timeouts.implicit_wait
                self.driver.implicitly_wait(1)

                # Проверяем наличие кнопки "подробнее"
                try:
                    details_buttons = self.driver.find_elements(By.XPATH,
                                                                "//span[contains(@class, 'cursor-pointer') and contains(@class, 'text-danger') and contains(text(), 'подробнее')]")
                    has_button = len(details_buttons) > 0
                    logger.debug(f"Найдено кнопок 'подробнее': {len(details_buttons)}")
                except Exception as e:
                    logger.warning(f"Ошибка при поиске кнопок 'подробнее': {e}")
                    has_button = False
                    details_buttons = []

                # Восстанавливаем исходное значение ожидания
                self.driver.implicitly_wait(original_implicit_wait)

            except Exception as e:
                logger.error(f"Ошибка при проверке кнопки 'подробнее': {e}")
                return False, {"error": f"Ошибка при проверке кнопки 'подробнее': {str(e)}"}

            # Получаем материалы из JSON
            try:
                json_materials = self._get_materials_from_json()
                has_json_materials = any(materials for materials in json_materials.values())
                logger.debug(f"Артикулов с материалами в JSON: {len(json_materials)}")
            except Exception as e:
                logger.error(f"Ошибка при получении материалов из JSON: {e}")
                return False, {"error": f"Ошибка при получении материалов из JSON: {str(e)}"}

            # Принимаем решение на основе наличия кнопки и материалов
            if not has_button and not has_json_materials:
                logger.info("Ни кнопки, ни материалов в JSON не найдено - тест успешен")
                return True, {"message": "Нет кнопки 'подробнее' и нет материалов в JSON"}

            if not has_button and has_json_materials:
                logger.warning("Ошибка: нет кнопки 'подробнее', но есть материалы в JSON")
                return False, {"message": "Нет кнопки 'подробнее', но есть материалы в JSON"}

            if has_button and not has_json_materials:
                logger.warning("Ошибка: есть кнопка 'подробнее', но нет материалов в JSON")
                return False, {"message": "Есть кнопка 'подробнее', но нет материалов в JSON"}

        # Шаг 2: Открытие попапа с материалами
        with allure.step("Открытие попапа с материалами"):
            popup = self._open_details_popup(details_buttons)
            if not popup:
                logger.error("Не удалось открыть попап с материалами")
                return False, {"error": "Не удалось открыть попап с материалами"}

        # Шаг 3: Сбор данных из аккордеонов в попапе
        with allure.step("Сбор кодов материалов из попапа"):
            try:
                ui_materials = self._collect_material_codes_from_popup(popup)
                if not ui_materials:
                    logger.warning("Не удалось собрать материалы из попапа")
                    # Продолжаем выполнение, это может быть нормальной ситуацией
            except Exception as e:
                logger.error(f"Ошибка при сборе материалов из попапа: {e}")
                # Пытаемся закрыть попап перед возвратом ошибки
                self._close_popup()
                return False, {"error": f"Ошибка при сборе материалов из попапа: {str(e)}"}

        # Шаг 4: Закрытие попапа
        with allure.step("Закрытие попапа"):
            if not self._close_popup():
                logger.warning("Не удалось закрыть попап, продолжаем выполнение")
                # Продолжаем выполнение, это не критическая ошибка

        # Шаг 5: Сравнение данных из UI и JSON
        with allure.step("Сравнение материалов из UI и JSON"):
            try:
                results = self._compare_materials(json_materials, ui_materials)
            except Exception as e:
                logger.error(f"Ошибка при сравнении материалов: {e}")
                return False, {"error": f"Ошибка при сравнении материалов: {str(e)}"}

        # Общий результат
        all_match = all(r["match"] for r in results)
        logger.info(f"Общий результат проверки номеров материалов: {'✓' if all_match else '✗'}")

        return all_match, results

    def _check_details_button_and_json(self):
        """
        Шаг 1: Проверка наличия кнопки "подробнее" и материалов в JSON.
        """
        logger.info("Шаг 1: Проверка наличия кнопки 'подробнее' и материалов в JSON")

        # Временно отключаем имплицитное ожидание
        original_implicit_wait = self.driver.timeouts.implicit_wait
        self.driver.implicitly_wait(1)  # Используем минимальное ожидание

        try:
            # Ищем кнопку "подробнее"
            details_buttons = self.find_elements((By.XPATH,
                                                "//span[contains(@class, 'cursor-pointer') and contains(@class, 'text-danger') and contains(text(), 'подробнее')]"),
                                               sec=1)
            has_button = len(details_buttons) > 0
            logger.debug(f"Найдено кнопок 'подробнее': {len(details_buttons)}")
        finally:
            # Восстанавливаем имплицитное ожидание
            self.driver.implicitly_wait(original_implicit_wait)

        # Получаем материалы из JSON
        json_materials = self._get_materials_from_json()
        has_json_materials = any(materials for materials in json_materials.values())
        logger.debug(f"Артикулов с материалами в JSON: {len(json_materials)}")

        # Принимаем решение
        if not has_button and not has_json_materials:
            logger.info("Ни кнопки, ни материалов в JSON не найдено - тест успешен")
            return True, {"message": "Нет кнопки 'подробнее' и нет материалов в JSON"}

        if not has_button and has_json_materials:
            logger.warning("Ошибка: нет кнопки 'подробнее', но есть материалы в JSON")
            return False, {"message": "Нет кнопки 'подробнее', но есть материалы в JSON"}

        if has_button and not has_json_materials:
            logger.warning("Ошибка: есть кнопка 'подробнее', но нет материалов в JSON")
            return False, {"message": "Есть кнопка 'подробнее', но нет материалов в JSON"}

        return True, {"details_buttons": details_buttons, "json_materials": json_materials}

    def _get_materials_from_json(self):
        """
        Получает номера материалов из JSON для всех артикулов.
        """
        logger.debug("Получение номеров материалов из JSON")
        materials_by_article = {}

        for item in self.json_handler.get_order_items():
            article = item.get('materialCode')
            if not article:
                continue

            materials_by_article[article] = []

            internal_order = item.get('internalOrder')
            if not internal_order:
                continue

            for material in internal_order.get('items', []):
                material_code = material.get('materialCode')
                if material_code:
                    materials_by_article[article].append(material_code)
                    logger.debug(f"Для артикула {article} найден материал: {material_code}")

        return materials_by_article

    def _open_details_popup(self, details_buttons=None):
        """
        Шаг 2: Открытие попапа с материалами.
        """
        logger.info("Шаг 2: Открытие попапа с материалами")

        try:
            # Если кнопки не переданы, ищем их с увеличенным таймаутом
            if details_buttons is None or len(details_buttons) == 0:
                details_buttons = self.find_elements(BTPServicePageLocators.DETAILS_POPUP_BUTTON, sec=20)

            if not details_buttons or len(details_buttons) == 0:
                logger.error("Ошибка: кнопка 'подробнее' не найдена")
                return None

            # # Скроллим к кнопке и делаем паузу после скролла
            # self.scroll_to(details_buttons[0])
            # time.sleep(1)  # Даем время странице стабилизироваться после скролла

            # Ждем кликабельности с увеличенным таймаутом (30 секунд)
            logger.debug("Ожидание кликабельности кнопки (до 30 секунд)...")
            self.expecting_clickability(BTPServicePageLocators.DETAILS_POPUP_BUTTON, sec=30)

            # # Повторный скролл для гарантии видимости после ожидания
            # self.scroll_to(details_buttons[0])
            # time.sleep(0.5)

            # Клик
            logger.debug("Выполнение клика на кнопку")
            details_buttons[0].click()

            # Ждем открытия попапа - достаточно долго (40 секунд)
            logger.debug("Ожидание открытия попапа (до 40 секунд)...")
            self.waiting_element_is_visibility_on_the_page(BTPServicePageLocators.MODAL_DIALOG, sec=40)

            # Короткая пауза для полной загрузки попапа
            time.sleep(1)

            # Получаем попап
            popup = self.find_element(BTPServicePageLocators.MODAL_DIALOG)
            logger.info("Попап успешно открыт")

            return popup

        except Exception as e:
            logger.error(f"Ошибка при открытии попапа: {e}")
            return None

    def _collect_material_codes_from_popup(self, popup):
        """
        Шаг 3: Сбор кодов материалов из попапа.
        """
        import re
        logger.info("Шаг 3: Сбор кодов материалов из попапа")

        ui_materials = {}

        try:
            # Находим контейнер с аккордеонами в попапе по ID
            try:
                accordion_container = popup.find_element(By.ID, "service-btp-items-detail")
                logger.debug("Найден контейнер аккордеонов по ID")
            except:
                # Запасной вариант - поиск по классу
                accordion_container = popup.find_element(By.CSS_SELECTOR, "div.accordion.mt-4")
                logger.debug("Найден контейнер аккордеонов по классу")

            # Находим все аккордеоны внутри контейнера
            accordion_items = accordion_container.find_elements(By.CSS_SELECTOR, "div.accordion-item")
            logger.debug(f"Найдено аккордеонов в попапе: {len(accordion_items)}")

            # Проверяем, есть ли открытый аккордеон изначально
            open_accordion = popup.find_elements(By.CSS_SELECTOR, "div.accordion-collapse.show")
            initially_open = len(open_accordion) > 0
            logger.debug(f"Изначально открыт аккордеон: {initially_open}")

            # Если нет открытого аккордеона, открываем первый
            if not initially_open and accordion_items:
                first_button = accordion_items[0].find_element(By.CSS_SELECTOR, "div.accordion-button")
                logger.debug("Открываем первый аккордеон")
                self.scroll_to(first_button)
                time.sleep(0.5)  # Пауза перед кликом
                first_button.click()
                time.sleep(1)  # Пауза после клика

            # Обрабатываем каждый аккордеон
            for i, item in enumerate(accordion_items):
                try:
                    # Получаем артикул
                    article_header = item.find_element(By.CSS_SELECTOR, "div.fs-4.fw-bold")
                    article = article_header.text.strip()

                    if not article:
                        logger.warning(f"Аккордеон {i + 1}: артикул не найден, пропускаем")
                        continue

                    logger.debug(f"Обработка аккордеона {i + 1}: {article}")

                    # Находим кнопку аккордеона
                    accordion_button = item.find_element(By.CSS_SELECTOR, "div.accordion-button")

                    # Проверяем, открыт ли аккордеон
                    is_expanded = accordion_button.get_attribute("aria-expanded") == "true"
                    logger.debug(f"Аккордеон {article} открыт: {is_expanded}")

                    # Если не открыт - открываем
                    if not is_expanded:
                        # Скроллируем к кнопке
                        self.scroll_to(accordion_button)
                        time.sleep(0.5)  # Пауза перед кликом

                        # Клик
                        logger.debug(f"Открываем аккордеон {article}")
                        accordion_button.click()

                        # Ждем открытия аккордеона
                        logger.debug("Ожидание открытия аккордеона...")
                        wait = WebDriverWait(self.driver, 10)
                        wait.until(
                            EC.presence_of_element_located((By.CSS_SELECTOR, "div.accordion-collapse.show"))
                        )

                        # Небольшая пауза для стабильности
                        time.sleep(1)

                    # Находим открытый раздел аккордеона
                    accordion_body = None
                    try:
                        # Сначала ищем аккордеон по ID
                        accordion_bodies = popup.find_elements(By.CSS_SELECTOR, "div.accordion-collapse.show")
                        if accordion_bodies:
                            accordion_body = accordion_bodies[0]
                            logger.debug(f"Найдено содержимое открытого аккордеона")
                        else:
                            logger.warning(f"Ошибка: не найдено открытое содержимое аккордеона")
                            continue
                    except Exception as e:
                        logger.error(f"Ошибка при поиске содержимого аккордеона: {e}")
                        continue

                    # Находим элементы с текстом материалов
                    material_elements = accordion_body.find_elements(By.CSS_SELECTOR, "div.text-gray")
                    logger.debug(f"Найдено элементов с материалами: {len(material_elements)}")

                    # Выводим текст для отладки
                    for j, elem in enumerate(material_elements):
                        text = elem.text.strip()
                        logger.debug(f"Материал {j + 1}: '{text}'")

                    # Извлекаем коды материалов
                    material_codes = []
                    for elem in material_elements:
                        text = elem.text.strip()
                        if text:
                            # Извлекаем код материала между номером и вертикальной чертой
                            match = re.search(r'\d+\.\s+([\w-]+)\s*\|', text)
                            if match:
                                material_code = match.group(1).strip()  # Убираем пробелы
                                material_codes.append(material_code)
                                logger.debug(f"Извлечен код: {material_code}")

                    ui_materials[article] = material_codes
                    logger.debug(f"Собрано кодов материалов: {len(material_codes)}")

                except Exception as e:
                    logger.error(f"Ошибка при обработке аккордеона {i + 1}: {e}")

        except Exception as e:
            logger.error(f"Общая ошибка при сборе материалов: {e}")

        return ui_materials

    def _close_popup(self):
        """
        Шаг 4: Закрытие попапа.
        """
        logger.info("Шаг 4: Закрытие попапа")

        try:
            # Находим кнопку закрытия
            close_button = self.find_element((By.CSS_SELECTOR, "button.btn-close"))
            logger.debug("Нажатие на кнопку закрытия попапа")
            close_button.click()

            # Ждем закрытия попапа
            wait = WebDriverWait(self.driver, 10)
            wait.until(
                EC.invisibility_of_element_located((By.CSS_SELECTOR, "div.modal-dialog.modal-dialog-centered"))
            )
            logger.info("Попап успешно закрыт")
            return True

        except Exception as e:
            logger.error(f"Ошибка при закрытии попапа кнопкой: {e}")

            # Пробуем закрыть клавишей ESC
            try:
                logger.debug("Попытка закрыть попап клавишей ESC")
                body = self.find_element((By.TAG_NAME, "body"))
                body.send_keys(Keys.ESCAPE)

                wait = WebDriverWait(self.driver, 10)
                wait.until(
                    EC.invisibility_of_element_located((By.CSS_SELECTOR, "div.modal-dialog.modal-dialog-centered"))
                )
                logger.info("Попап успешно закрыт клавишей ESC")
                return True

            except Exception as e2:
                logger.error(f"Ошибка при закрытии попапа клавишей ESC: {e2}")
                return False

    def _compare_materials(self, json_materials, ui_materials):
        """
        Шаг 5: Сравнение материалов из JSON и UI.
        """
        logger.info("Шаг 5: Сравнение материалов из JSON и UI")

        results = []

        # Все уникальные артикулы
        all_articles = set(list(json_materials.keys()) + list(ui_materials.keys()))

        for article in all_articles:
            json_codes = sorted(json_materials.get(article, []))
            ui_codes = sorted(ui_materials.get(article, []))

            # Определяем совпадение
            match = json_codes == ui_codes

            # Формируем результат
            result = {
                "article": article,
                "match": match,
                "json_materials": json_codes,
                "ui_materials": ui_codes
            }

            # Если есть различия, добавляем подробности
            if not match:
                only_in_json = set(json_codes) - set(ui_codes)
                only_in_ui = set(ui_codes) - set(json_codes)

                if only_in_json:
                    result["only_in_json"] = list(only_in_json)

                if only_in_ui:
                    result["only_in_ui"] = list(only_in_ui)

            results.append(result)
            logger.debug(f"Артикул {article}: совпадение = {match}")

        return results

    @allure.step("Проверка актуальных статусов артикулов")
    def verify_statuses_simplest(self):
        """
        Быстрый тест проверки статусов артикулов с использованием коллекций.
        Собирает коллекцию артикулов с их статусами и индикаторами одним запросом,
        затем обрабатывает и сравнивает с данными из JSON.
        """
        logger.info("Быстрая проверка статусов артикулов")

        # 1. Собираем коллекцию артикулов и их статусов из UI
        with allure.step("Сбор статусов артикулов из UI"):
            ui_statuses = self._collect_ui_statuses()
            logger.debug(f"Собрано {len(ui_statuses)} статусов из UI")

        # 2. Получаем данные из JSON
        with allure.step("Получение статусов артикулов из JSON"):
            json_statuses = self._collect_json_statuses()
            logger.debug(f"Собрано {len(json_statuses)} статусов из JSON")

        # 3. Сравниваем данные и формируем результаты
        with allure.step("Сравнение статусов из UI и JSON"):
            results = self._compare_statuses(ui_statuses, json_statuses)

        # 4. Определяем общий результат
        all_match = all(r["match"] for r in results)
        logger.info(f"Общий результат проверки статусов: {'✓' if all_match else '✗'}")

        return all_match, results

    def _collect_ui_statuses(self):
    """
    Собирает коллекцию статусов артикулов из UI.
    Возвращает словарь: {артикул: {"indicator": класс_индикатора, "text": текст_статуса}}
    """
    logger.debug("Сбор статусов артикулов из UI")
    result = {}

    try:
        # Получаем все артикулы с их статусами одним запросом
        elements = self.find_elements((By.CSS_SELECTOR, "div.accordion-item"))
        logger.debug(f"Найдено {len(elements)} элементов аккордеона")

        for element in elements:
            try:
                # Получаем номер артикула
                article_element = element.find_element(By.CSS_SELECTOR, "div.fs-4.fw-bold")
                article = article_element.text.strip()

                # Ищем индикатор статуса
                indicator = None
                status_text = None

                # Поиск индикатора статуса в заголовке аккордеона
                indicators = element.find_elements(By.CSS_SELECTOR,
                                                   "div.accordion-header i.service-btp_icon--blue, " +
                                                   "div.accordion-header i.service-btp_icon--green, " +
                                                   "div.accordion-header i.service-btp_icon--gray, " +
                                                   "div.accordion-header i[class*='blue'], " +
                                                   "div.accordion-header i[class*='green'], " +
                                                   "div.accordion-header i[class*='gray']")

                if indicators:
                    # Берем первый найденный индикатор
                    indicator_element = indicators[0]
                    indicator_class = indicator_element.get_attribute("class")
                    logger.debug(f"Для артикула {article} найден индикатор: {indicator_class}")

                    # Находим текст статуса (следующий элемент div после индикатора)
                    parent = indicator_element.find_element(By.XPATH, "./..")
                    text_elements = parent.find_elements(By.CSS_SELECTOR, "div.fs-5, div.fw-bold")

                    if text_elements:
                        status_text = text_elements[0].text.strip()
                        logger.debug(f"Для артикула {article} найден текст статуса: {status_text}")

                # Добавляем в результат
                if article:
                    result[article] = {
                        "indicator": indicator_class,
                        "text": status_text
                    }

            except Exception as e:
                logger.warning(f"Ошибка при обработке артикула: {e}")
                continue

    except Exception as e:
        logger.error(f"Ошибка при сборе статусов из UI: {e}")

    return result

    def _collect_json_statuses(self):
    """
    Собирает коллекцию статусов артикулов из JSON.
    Логика согласно новым требованиям UI:
    - Если есть internalOrder → показываем "Допоставка №{номер}"
    - Если есть Process → берем ПЕРВЫЙ Process
    - Если нет Process → берем ПОСЛЕДНИЙ Finish
    Возвращает словарь: {артикул: {"status": тип_статуса, "text": текст_статуса}}
    """
    logger.debug("Сбор статусов артикулов из JSON")
    result = {}

    # Получаем все элементы заказа
    items = self.json_handler.get_order_items()
    logger.debug(f"Получено {len(items)} элементов заказа из JSON")

    for item in items:
        article = item.get("materialCode")
        if not article:
            continue

        # Сначала проверяем наличие internalOrder
        internal_order = item.get("internalOrder")
        if internal_order and internal_order.get("internalRequestOrderNumber"):
            # Если есть номер допоставки, используем его
            delivery_number = internal_order.get("internalRequestOrderNumber")
            result[article] = {
                "status": "Process",  # Допоставка всегда в статусе Process
                "text": f"Допоставка №{delivery_number}"
            }
            logger.debug(f"Для артикула {article} найден номер допоставки: {delivery_number}")
            continue

        # Если нет допоставки, используем стандартную логику
        # Собираем все статусы Process и Finish
        process_statuses = []
        finish_statuses = []

        for step in item.get("progressSteps", []):
            status = step.get("status")
            description = step.get("description", "")

            if status == "Process":
                process_statuses.append({"status": "Process", "text": description})
                logger.debug(f"Для артикула {article} найден статус Process: {description}")
            elif status == "Finish":
                finish_statuses.append({"status": "Finish", "text": description})
                logger.debug(f"Для артикула {article} найден статус Finish: {description}")

        # Применяем логику выбора статуса
        if process_statuses:
            # Если есть Process - берем ПЕРВЫЙ
            result[article] = process_statuses[0]
            logger.debug(f"Для артикула {article} выбран первый Process: {process_statuses[0]['text']}")
        elif finish_statuses:
            # Если нет Process - берем ПОСЛЕДНИЙ Finish
            result[article] = finish_statuses[-1]
            logger.debug(f"Для артикула {article} выбран последний Finish: {finish_statuses[-1]['text']}")
        else:
            result[article] = {"status": None, "text": None}
            logger.debug(f"Для артикула {article} не найдено активных статусов")

    return result

   def _compare_statuses(self, ui_statuses, json_statuses):
    """
    Сравнивает статусы артикулов из UI и JSON.
    Конвертирует классы индикаторов в типы статусов для сравнения.
    """
    logger.info("Сравнение статусов артикулов из UI и JSON")
    results = []

    # Все уникальные артикулы
    all_articles = set(list(ui_statuses.keys()) + list(json_statuses.keys()))
    logger.debug(f"Всего артикулов для сравнения: {len(all_articles)}")

    for article in all_articles:
        ui_info = ui_statuses.get(article, {"indicator": None, "text": None})
        json_info = json_statuses.get(article, {"status": None, "text": None})

        # Конвертируем класс индикатора в тип статуса
        ui_status = self._convert_indicator_to_status(ui_info.get("indicator"))

        # Проверяем совпадение типа статуса
        status_match = ui_status == json_info.get("status")

        # Проверяем совпадение текста
        text_match = True
        ui_text = ui_info.get("text")
        json_text = json_info.get("text")

        if ui_text and json_text:
            # Нормализация текстов для сравнения
            ui_text_normalized = ui_text.lower()
            json_text_normalized = json_text.lower()
            
            # Убираем "(в работе)" из UI текста
            ui_text_normalized = ui_text_normalized.replace("(в работе)", "").strip()
            
            # Специальная обработка для допоставки
            if "допоставка №" in ui_text_normalized and "допоставка №" in json_text_normalized:
                # Для допоставки просто сравниваем номера
                text_match = ui_text_normalized == json_text_normalized
            else:
                # Обрабатываем случай с префиксом "производство."
                if ui_text_normalized.startswith("производство."):
                    # Извлекаем часть после "производство."
                    ui_text_normalized = ui_text_normalized.replace("производство.", "").strip()
                
                # Сравниваем нормализованные тексты
                text_match = (ui_text_normalized == json_text_normalized) or \
                           (ui_text_normalized in json_text_normalized) or \
                           (json_text_normalized in ui_text_normalized)
                       
            if not text_match:
                logger.warning(f"Несовпадение текстов статуса для артикула {article}:")
                logger.warning(f"  В UI (нормализованный): '{ui_text_normalized}'")
                logger.warning(f"  В JSON (нормализованный): '{json_text_normalized}'")

        # Если нет статусов ни в UI, ни в JSON - это совпадение
        if not ui_status and not json_info.get("status"):
            status_match = True
            text_match = True

        # Формируем результат
        match = status_match and text_match
        results.append({
            "article": article,
            "match": match,
            "page_color": ui_status or "Отсутствует",
            "page_text": ui_text,
            "json_status": json_info.get("status"),
            "json_text": json_info.get("text"),
            "status_type_match": status_match,
            "text_match": text_match
        })

        logger.debug(f"Артикул {article}: совпадение = {match}")

    return results

       
    def _convert_indicator_to_status(self, indicator_class):
        """
        Конвертирует класс индикатора в тип статуса.
        """
        if not indicator_class:
            return None

        indicator_class = indicator_class.lower()

        if "blue" in indicator_class:
            return "Process"
        elif "green" in indicator_class:
            return "Finish"
        elif "gray" in indicator_class:
            return "Wait"

        return None

    @allure.step("Проверка кнопок фото")
    def verify_photo_buttons_simple(self):
        """
        Простой и быстрый метод проверки кнопок фото.
        Собирает два списка и сравнивает их.
        Использует небольшое ожидание для стабильности.
        """
        logger.info("Выполняется быстрая проверка кнопок фото")
        # Сохраняем текущее значение
        old_timeout = self.driver.timeouts.implicit_wait

        try:
            # Устанавливаем небольшое ожидание (1 секунды) для стабильности
            self.driver.implicitly_wait(1)
            logger.debug("Установлено минимальное неявное ожидание: 1 секунда")

            # 1. Собираем данные из UI
            with allure.step("Сбор артикулов с кнопками фото из UI"):
                ui_articles_with_photo = []

                # Ищем все артикулы и проверяем наличие кнопок фото
                article_elements = self.find_elements((By.CSS_SELECTOR, "div.accordion.mt-4 div.fs-4.fw-bold"), sec=1)
                logger.debug(f"Найдено {len(article_elements)} элементов артикулов")

                for article_elem in article_elements:
                    article = article_elem.text.strip()
                    if not article:
                        continue

                    # Ищем кнопку фото для этого артикула
                    try:
                        parent = article_elem.find_element(By.XPATH,
                                                           "./ancestor::div[contains(@class, 'accordion-item')]")
                        photo_buttons = parent.find_elements(By.XPATH, ".//button[contains(text(), 'Фото')]")

                        if photo_buttons:
                            ui_articles_with_photo.append(article)
                            logger.debug(f"Для артикула {article} найдена кнопка фото")
                    except Exception as e:
                        logger.warning(f"Ошибка при поиске кнопки фото для артикула {article}: {e}")
                        # Если не удалось найти родительский элемент, считаем что кнопки нет
                        pass

                logger.info(f"Всего артикулов с кнопками фото в UI: {len(ui_articles_with_photo)}")

            # 2. Собираем данные из JSON
            with allure.step("Получение артикулов с фото из JSON"):
                json_articles_with_photo = []

                if self.json_handler and self.json_handler.json_data:
                    items = self.json_handler.json_data.get('objects', [{}])[0].get('items', [])
                    logger.debug(f"Получено {len(items)} элементов заказа из JSON")

                    for item in items:
                        article = item.get('materialCode')
                        if not article:
                            continue

                        # Проверяем наличие фото
                        if 'images' in item and item['images']:
                            for image in item['images']:
                                if image.get('preview', {}).get('absoluteUrl'):
                                    json_articles_with_photo.append(article)
                                    logger.debug(f"Для артикула {article} найдено фото в JSON")
                                    break

                logger.info(f"Всего артикулов с фото в JSON: {len(json_articles_with_photo)}")

            # 3. Проверяем соответствие списков
            with allure.step("Сравнение списков артикулов с фото"):
                match = set(ui_articles_with_photo) == set(json_articles_with_photo)
                logger.info(f"Совпадение списков артикулов с фото: {match}")

                # Дополнительная информация о различиях
                only_in_ui = set(ui_articles_with_photo) - set(json_articles_with_photo)
                only_in_json = set(json_articles_with_photo) - set(ui_articles_with_photo)

                if only_in_ui:
                    logger.warning(f"Артикулы с кнопками фото только в UI: {only_in_ui}")

                if only_in_json:
                    logger.warning(f"Артикулы с фото только в JSON: {only_in_json}")

            # Готовим результат для отчета
            result = {
                'match': match,
                'ui_articles': ui_articles_with_photo,
                'json_articles': json_articles_with_photo
            }

            return match, result

        finally:
            # Восстанавливаем исходное значение ожидания
            self.driver.implicitly_wait(old_timeout)
            logger.debug(f"Восстановлено исходное неявное ожидание: {old_timeout} секунд")

    def get_photos_from_json(self):
        """
        Получает информацию о наличии фото из JSON данных.
        Возвращает словарь {артикул: имеет_фото (True/False)}
        """
        logger.debug("Получение информации о наличии фото из JSON")
        if not self.json_handler:
            logger.warning("JSON обработчик не установлен")
            return {}

        # Делегируем запрос к json_handler
        result = self.json_handler.get_articles_with_photos()
        logger.debug(f"Получено {len(result)} артикулов с информацией о фото")
        return result

    @allure.step("Проверка номеров допоставки")
    def verify_delivery_numbers_fast(self):
        """
        Сверхбыстрая проверка номеров допоставки без длительного ожидания.
        """
        logger.info("Выполняется быстрая проверка номеров допоставки")
        if not self.json_handler:
            logger.error("JSON обработчик не установлен")
            raise ValueError("JSON обработчик не установлен")

        # Сохраняем текущее значение implicit wait
        current_implicit_wait = self.driver.timeouts.implicit_wait

        try:
            # Устанавливаем минимальное время неявного ожидания
            self.driver.implicitly_wait(1)
            logger.debug("Установлено минимальное неявное ожидание: 1 секунда")

            # 1. Сначала проверяем JSON (это быстрая операция)
            with allure.step("Получение номеров допоставки из JSON"):
                json_delivery_numbers = self.json_handler.get_delivery_numbers()
                has_json_deliveries = any(num is not None for num in json_delivery_numbers.values())
                logger.debug(
                    f"Найдено номеров допоставки в JSON: {sum(1 for num in json_delivery_numbers.values() if num is not None)}")

            # 2. Безопасная проверка наличия элементов допоставки на странице
            with allure.step("Проверка наличия элементов допоставки на странице"):
                try:
                    # Используем прямое обращение к driver для надежности
                    delivery_elements = self.driver.find_elements(*BTPServicePageLocators.DELIVERY_NUMBER_ELEMENT)
                    has_ui_deliveries = len(delivery_elements) > 0
                    logger.debug(f"Найдено элементов допоставки на странице: {len(delivery_elements)}")
                except Exception as e:
                    logger.warning(f"Ошибка при поиске элементов допоставки: {e}")
                    has_ui_deliveries = False

            # 3. Если нет допоставок ни в JSON, ни на странице - тест успешен
            if not has_json_deliveries and not has_ui_deliveries:
                logger.info("Нет номеров допоставки в JSON и на странице - тест успешен")
                return True, {"message": "Нет номеров допоставки в JSON и на странице"}

            # 4. Если данные только в одном месте - несоответствие
            if has_json_deliveries and not has_ui_deliveries:
                logger.warning("Несоответствие: есть номера допоставки в JSON, но нет на странице")
                return False, {"message": "Есть номера допоставки в JSON, но нет на странице"}

            if not has_json_deliveries and has_ui_deliveries:
                logger.warning("Несоответствие: есть элементы допоставки на странице, но нет в JSON")
                return False, {"message": "Есть элементы допоставки на странице, но нет в JSON"}

            # 5. Если дошли сюда, выполняем нормальную проверку
            with allure.step("Сбор номеров допоставки со страницы"):
                page_deliveries = self._get_page_delivery_numbers(timeout=3)

            # 6. Сравниваем результаты
            with allure.step("Сравнение номеров допоставки из JSON и страницы"):
                results = []
                all_articles = set(list(json_delivery_numbers.keys()) + list(page_deliveries.keys()))
                logger.debug(f"Всего артикулов для сравнения: {len(all_articles)}")

                for article in all_articles:
                    json_delivery = json_delivery_numbers.get(article)
                    page_delivery_raw = page_deliveries.get(article)

                    # Очищаем номер от "(в работе)"
                    page_delivery_clean = None
                    if page_delivery_raw:
                        page_delivery_clean = page_delivery_raw.replace("(в работе)", "").strip()
                        if not page_delivery_clean:
                            page_delivery_clean = None

                    # Определяем совпадение
                    match = (json_delivery == page_delivery_clean)

                    # Формируем результат
                    result = {
                        'article': article,
                        'match': match,
                        'json_delivery': json_delivery,
                        'page_delivery_raw': page_delivery_raw,
                        'page_delivery_clean': page_delivery_clean
                    }

                    # Добавляем пояснительное сообщение для более понятного вывода
                    if json_delivery is None and page_delivery_clean is None:
                        result['message'] = "Номер допоставки отсутствует в JSON и на странице"
                    elif json_delivery is None:
                        result['message'] = "Номер допоставки есть на странице, но отсутствует в JSON"
                    elif page_delivery_clean is None:
                        result['message'] = "Номер допоставки есть в JSON, но отсутствует на странице"
                    elif json_delivery != page_delivery_clean:
                        result[
                            'message'] = f"Несовпадение номеров: в JSON '{json_delivery}', на странице '{page_delivery_clean}'"

                    results.append(result)
                    logger.debug(f"Артикул {article}: совпадение = {match}")

                # Общий результат
                all_match = all(r['match'] for r in results)
                logger.info(f"Общий результат проверки номеров допоставки: {'✓' if all_match else '✗'}")
                return all_match, results

        finally:
            # Возвращаем исходное значение implicit wait
            self.driver.implicitly_wait(current_implicit_wait)
            logger.debug(f"Восстановлено исходное неявное ожидание: {current_implicit_wait} секунд")

    def _get_delivery_info_from_json(self):
        """Получение информации о доставке из JSON"""
        logger.debug("Получение информации о доставке из JSON")
        if not self.json_handler or not self.json_handler.json_data:
            logger.warning("JSON обработчик не установлен или данные не загружены")
            return []

        try:
            order_object = self.json_handler.get_order_object()
            if not order_object:
                logger.warning("Объект заказа не найден в JSON")
                return []

            # Проверяем, существует ли ключ 'deliveryInfo'
            delivery_info = order_object.get('deliveryInfo')
            if delivery_info is None:
                logger.warning("Ключ 'deliveryInfo' не найден в объекте заказа")
                return []

            logger.debug(f"Получено {len(delivery_info)} записей о доставке из JSON")
            return delivery_info
        except Exception as e:
            logger.error(f"Ошибка при получении данных о доставке из JSON: {e}")
            return []
