import time
from pathlib import Path

import allure

from base_page.base_page import BasePage
from base_page.base_page_locators import BaseOpenLocators
from base_page.raise_exceptions import MyTimeoutException

from open_pages.confirmation_page.confirmation_page_locators import ConfirmationPageLocators
from open_pages.design_condition_page.design_condition_locators import DesignConditionLocators


@allure.feature('Страница Проектное условие')
@allure.feature('Страница Проектное условие в Опене')
class DesignConditionPage(BasePage):
    """Страница Проектное условие"""

    def payment_condition_must_be_advance_payment(self):
        """Условие оплаты должно быть - Предоплата"""
        with allure.step('Проверка что условия оплаты стоит Предоплата'):
            true_payment_terms = 'Предоплата'
            payment_terms_on_page = self.find_element(DesignConditionLocators.LOCATOR_PAYMENT_TERMS).text
            assert true_payment_terms == payment_terms_on_page, \
                f'Условия оплаты на странице - ({payment_terms_on_page}) не равны ожидаемым условиям оплаты - ' \
                f'({true_payment_terms})'

    def store_all_discounts_on_the_design_condition_page(self) -> list:
        """Сохранение всех скидок"""
        with allure.step('Сохранение всех скидок в список'):
            discounts_list_web_element = self.driver.find_elements(*DesignConditionLocators.LOCATOR_ALL_DISCOUNTS)
            list_all_discounts = []
            for el in discounts_list_web_element:
                el = el.text
                el = float(el.replace('%', ''))
                list_all_discounts.append(el)
            return list_all_discounts

    def saving_the_final_cost_rub_on_the_design_condition_page(self) -> float:
        """Сохранение итоговой стоимости на странице Проектное условие"""
        with allure.step('Сохранение итоговой стоимости на странице Проектное условие в рублях'):
            total_cost = self.find_element(DesignConditionLocators.LOCATOR_TOTAL_AMOUNT).text
            total_cost = ''.join(total_cost.split())
            total_cost = float(total_cost.replace('₽', ''))
            return total_cost

    def saving_the_final_cost_cu_on_the_design_condition_page(self) -> float:
        """Сохранение итоговой стоимости на странице Проектное условие"""
        with allure.step('Сохранение итоговой стоимости на странице Проектное условие у.е.'):
            total_cost = self.find_element(DesignConditionLocators.LOCATOR_TOTAL_AMOUNT).text
            total_cost = ''.join(total_cost.split())
            total_cost = float(total_cost.replace('у.е.', ''))
            return total_cost

    def save_price_list_by_article(self, article: str):
        """Сохранение прайс-листа по артикулу"""
        with allure.step('Сохранение прайс-листа по артикулу'):
            price_list = self.find_element(DesignConditionLocators.locator_price_list_by_article(article)
                                           ).get_attribute('innerText').split('\n')[0]
            price_list = float(price_list.replace(' ', ''))
            return price_list

    def check_icon_promo_course_by_article(self, article: str):
        """Проверка отображения иконки промо курса у артикула"""
        with allure.step(f'Проверка отображения иконки промо курса у артикула {article}'):
            self.waiting_element_is_visibility_on_the_page(DesignConditionLocators.LOCATOR_HEADER, sec=5)
            len_icon_promo_course_by_article = len(self.driver.find_elements(
                *DesignConditionLocators.locator_icon_promo_course_by_article(article)))
            assert len_icon_promo_course_by_article != 0, \
                f'На странице КП нет иконки промо курса артикула {article}. {len_icon_promo_course_by_article}'

    def check_text_in_tooltip_promo_course_by_article(self, article: str):
        """Проверка текста в тултипе промо курса по артикулу"""
        with allure.step(f'Проверка текста в тултипе промо курса по артикулу {article}'):
            expected_text_in_tooltip_promo = 'Специальное правило расчёта. Применён курс 115 руб., при расчёте стоимости по прайсу.'
            with allure.step('Ожидание видимости иконки промо курса на странице'):
                self.waiting_element_is_visibility_on_the_page(
                    DesignConditionLocators.locator_icon_promo_course_by_article(article), sec=5)
            with allure.step('Клик по иконке промо курса и ожидание отображения на странице тултипа промо курса'):
                icon_promo_course = self.find_element(
                    DesignConditionLocators.locator_icon_promo_course_by_article(article))
                self.scroll_to_elem_perform(icon_promo_course)
                icon_promo_course.click()
                self.waiting_element_is_visibility_on_the_page(
                    DesignConditionLocators.locator_text_in_tooltip_promo_course_by_article(article), sec=5)

            text_in_tooltip_promo = self.find_element(
                DesignConditionLocators.locator_text_in_tooltip_promo_course_by_article(article)).text

            assert text_in_tooltip_promo == expected_text_in_tooltip_promo, \
                f'Текст в тултипе промо курса артикула {article} - ({text_in_tooltip_promo}) не соответствует ' \
                f'ожидаемому - ({expected_text_in_tooltip_promo})'

    def saving_of_allowances_on_all_lines_of_articles(self) -> list:
        """Сохранение надбавок на всех линиях артикулов"""
        with allure.step('Сохранение надбавок на всех линиях артикулов'):
            surcharges_on_all_article_lines = self.find_elements(
                DesignConditionLocators.LOCATOR_SURCHARGES_ON_ALL_ARTICLE_LINES)
            surcharges_on_all_article_lines = [
                int(surcharges.text.replace('%', '')) for surcharges in surcharges_on_all_article_lines
            ]
            return surcharges_on_all_article_lines

    def availability_display_check(self):
        """Проверка отображения наличия"""
        with allure.step('Проверка отображения наличия оборудования'):
            button_check_availability = self.find_element(DesignConditionLocators.LOCATOR_BUTTON_CHECK_AVAILABILITY)
            self.scroll_to(button_check_availability)
            self.driver.execute_script("arguments[0].click()", button_check_availability)
            time.sleep(1)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_element_is_visibility_on_the_page(DesignConditionLocators.LOCATOR_NUMBER_OF_ARTICLE_LINES,
                                                           sec=5)
            article_lines = self.driver.find_elements(*DesignConditionLocators.LOCATOR_NUMBER_OF_ARTICLE_LINES
                                                      )  # Количество линий артикулов
            count_line_article = len(article_lines)
            stock_indicator = self.driver.find_elements(*DesignConditionLocators.LOCATOR_STOCK_INDICATOR)
            count_stock_indicator = len(stock_indicator)
            assert count_stock_indicator == count_line_article, \
                f'Количество индикаторов наличия товара ({count_stock_indicator}) не равно ' \
                f'количеству линий товара ({count_line_article})'

    def click_button_order(self):
        """Клик по кнопке Заказать"""
        with allure.step('Клик по кнопке Заказать'):
            button_order = self.find_element(DesignConditionLocators.LOCATOR_BUTTON_ORDER)
            self.driver.execute_script("arguments[0].click()", button_order)
            time.sleep(1)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            time.sleep(2)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_element_is_visibility_on_the_page(ConfirmationPageLocators.LOCATOR_BUTTON_PROJECT_ORDER)

    def click_on_order_button_with_expected_error(self):
        """Клик по кнопке заказать с ожидаемой ошибкой"""
        with allure.step('Клик по кнопке заказать с ожидаемой ошибкой'):
            button_order = self.find_element(DesignConditionLocators.LOCATOR_BUTTON_ORDER)
            self.driver.execute_script("arguments[0].click()", button_order)
            time.sleep(1)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_element_is_visibility_on_the_page(ConfirmationPageLocators.LOCATOR_MODAL_SHOW, sec=5)

    def should_be_free_shipping_to_the_specified_address(self):
        """Должна быть бесплатная доставка на указанный адрес"""
        with allure.step('Проверка что должна быть бесплатная доставка на указанный адрес'):
            true_delivery_condition = 'Бесплатная доставка на указанный адрес'
            delivery_condition = self.find_element(DesignConditionLocators.LOCATOR_DELIVERY_METHOD).text.strip()
            assert delivery_condition == true_delivery_condition, \
                f'Способ доставки на странице - ({delivery_condition}) не соответствует ожидаемому способу доставки - ' \
                f'({true_delivery_condition})'

    def there_must_be_a_complete_terms_of_purchase(self):
        """Должно быть полное условие закупки"""
        with allure.step('Проверка полное условие закупки'):
            true_terms_of_purchase = 'Полная закупка'
            terms_of_purchase = self.find_element(DesignConditionLocators.LOCATOR_PURCHASE_TERMS).text.strip()
            assert terms_of_purchase == true_terms_of_purchase, \
                f'Условие закупки на странице - ({terms_of_purchase}) не соответствует ожидаемому условию закупки - ' \
                f'({true_terms_of_purchase})'

    def waiting_to_create_invoices(self):
        """Ожидание создания счетов"""
        with allure.step('Ожидание создания счетов'):
            status_is_being_logged = self.driver.find_elements(*DesignConditionLocators.LOCATOR_STATUS_IS_BEING_LOGGED)

            maximum_account_creation_time = 300  # максимальное время создания счета в секундах (5 минут)
            pause = 15  # пауза в секундах
            # while len(status_is_being_logged) != 0 or maximum_account_creation_time != 0:
            current_time = maximum_account_creation_time
            while len(status_is_being_logged) != 0:
                time.sleep(pause)
                self.driver.refresh()
                time.sleep(1)
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
                self.waiting_element_is_visibility_on_the_page(DesignConditionLocators.LOCATOR_HEADER)
                time.sleep(1)
                status_is_being_logged = self.driver.find_elements(
                    *DesignConditionLocators.LOCATOR_STATUS_IS_BEING_LOGGED)
                print(len(status_is_being_logged), '- количество заказов в статусе Регистрация')
                current_time -= pause
                if current_time == 0:
                    raise MyTimeoutException(
                        f'Не создается счет. Время ожидания - {maximum_account_creation_time / 60} мин.')

    def go_to_order(self, num_link):
        """Переход в заказ, num_link- номер ссылки"""
        with allure.step('Переход на страницу созданного заказа'):
            num_link = num_link - 1
            list_links = self.driver.find_elements(*DesignConditionLocators.LOCATOR_LINK_TO_ORDER)
            self.driver.execute_script("arguments[0].click()", list_links[num_link])
            self.switching_window(-1)
            time.sleep(1)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)

    def saving_the_amount_in_created_orders(self):
        """Сохранение сумм в созданных заказах и сложение их в общую сумму"""
        with allure.step('Сохранение сумм в созданных заказах и их суммирование'):
            list_amount_in_created_orders = self.driver.find_elements(
                *DesignConditionLocators.LOCATOR_AMOUNT_IN_CREATED_ORDERS)
            list_amount_in_created_orders = [
                float(el.text.replace(' ', '').replace('₽', '')) for el in list_amount_in_created_orders
            ]
            amount_in_created_orders = sum(list_amount_in_created_orders)
            return round(amount_in_created_orders, 2)

    def tooltip_check_btp_total_weight(self):
        """Проверка тултипа Общий вес на КП с БТП"""
        with allure.step('Проверка тултила Общего веса на КП с БТП'):
            tooltip = self.find_element(DesignConditionLocators.LOCATOR_TOOLTIP_TOTAL_WEIGHT_BTP)
            self.driver.execute_script("arguments[0].click()", tooltip)
            self.waiting_element_is_visibility_on_the_page(
                DesignConditionLocators.LOCATOR_TOOLTIP_TOTAL_WEIGHT_BTP_TEXT)

    def store_created_num_pq(self) -> str:
        """Сохранение созданного номера PQ"""
        with allure.step('Сохранение созданного номера КП'):
            created_num_pq = self.find_element(DesignConditionLocators.LOCATOR_HEADER).text.split(' ')[2]
            return created_num_pq

    def click_printing_forms(self):
        """Клик по кнопке Печатные формы"""
        with allure.step('Клик по кнопке Печатные формы'):
            self.expecting_clickability(DesignConditionLocators.LOCATOR_PRINTING_FORMS)
            button_printing_forms = self.find_element(DesignConditionLocators.LOCATOR_PRINTING_FORMS)
            self.driver.execute_script("arguments[0].click()", button_printing_forms)
            time.sleep(1)
            self.waiting_element_is_visibility_located_dom(DesignConditionLocators.LOCATOR_MENU_PRINTING_FORMS)

    def checking_export_to_excel_download(self, num_pq: str):
        """Проверка скачивания Выгрузки в Excel,
        num_pq- номер созданного PQ"""
        with allure.step('Проверка что скачивается файл Excel'):
            name_file = f'Проектное условие {num_pq}.xlsx'

            self.expecting_clickability(DesignConditionLocators.LOCATOR_EXPORT_TO_EXCEL)
            button_export_to_excel = self.find_element(DesignConditionLocators.LOCATOR_EXPORT_TO_EXCEL)
            self.driver.execute_script("arguments[0].click()", button_export_to_excel)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.checking_the_download_document_in_the_download_folder(name_file)

    def checking_commercial_offer_ridan_download(self):
        """Проверка скачивания Коммерческое предложение Ридан"""
        # cur_date = datetime.now().date()
        with allure.step('Проверка что скачивается файл PDF (Коммерческое предложение)'):
            name_file = f'Коммерческое предложение Ридан'
            downloads_path = str(Path.home() / "Downloads")  # Получение абсолютного пути к папке Загрузки

            self.expecting_clickability(DesignConditionLocators.LOCATOR_COMMERCIAL_OFFER_RIDAN)
            button_commercial_offer_ridan = self.find_element(DesignConditionLocators.LOCATOR_COMMERCIAL_OFFER_RIDAN)
            self.driver.execute_script("arguments[0].click()", button_commercial_offer_ridan)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            last_downloaded_file = self.search_for_the_last_downloaded_file_in_a_folder(downloads_path)
            assert name_file in last_downloaded_file, \
                f'Имя последнего скачанного файла - ({last_downloaded_file}) в папке {downloads_path}  не соответствует ' \
                f'ожидаемому - ({name_file}) - частичное название файла без милисекунд'

    def save_payment_terms(self) -> str:
        """Сохранение условия оплаты"""
        with allure.step('Сохранение условий оплаты'):
            payment_terms = self.find_element(DesignConditionLocators.LOCATOR_PAYMENT_TERMS).text
            return payment_terms

    def delivery_method_must_be_pick_up(self):
        """Способ доставки должен быть самовывоз"""
        with allure.step('Проверка что сопособ доставки Самовывоз'):
            true_delivery_method = 'Самовывоз'
            delivery_method_on_page = self.find_element(DesignConditionLocators.LOCATOR_DELIVERY_METHOD).text
            assert true_delivery_method == delivery_method_on_page, \
                f'Способ доставки на странице - ({delivery_method_on_page}) не соответствует - ({true_delivery_method})'

    def delivery_method_must_be_paid_delivery(self):
        """Способ доставки должен быть Платная доставка на указанный адрес"""
        with allure.step('Проверка что способ доставки должен быть Платная доставка на указанный адрес'):
            true_delivery_method = ['Платная доставка на указанный адрес', 'Доставка на указанный адрес']
            delivery_method_on_page = self.find_element(DesignConditionLocators.LOCATOR_DELIVERY_METHOD).text
            assert delivery_method_on_page in true_delivery_method, \
                f'Способ доставки на странице Проектное условие - ({delivery_method_on_page}) не соответствует ' \
                f'ожидаемому способу доставки - ({true_delivery_method})'

    def save_object_num(self) -> str:
        """Сохранение номера объекта"""
        with allure.step('Сохранение номера объекта'):
            self.waiting_element_is_visibility_on_the_page(DesignConditionLocators.LOCATOR_OBJECT_NAME, sec=5)
            num_object = self.find_element(DesignConditionLocators.LOCATOR_OBJECT_NAME).text.split(' ')[-1]
            return num_object

    def save_list_articles_in_cart(self) -> list:
        """Сохранение списка артикулов в Проектном условии"""
        with allure.step('Сохранение номера объекта'):
            self.waiting_element_is_visibility_on_the_page(DesignConditionLocators.LOCATOR_ALL_CODE_IN_LIST, sec=10)

            name_codes_link_in_cart = self.driver.find_elements(*DesignConditionLocators.LOCATOR_ALL_CODE_IN_LIST)
            name_codes_link_in_cart = [codes.text for codes in name_codes_link_in_cart]

            return name_codes_link_in_cart

    def entering_quantity_by_article(self, article: str, count: str):
        """Ввод количества по артикулу"""
        with allure.step('Ввод количества по артиклу'):
            self.waiting_element_is_visibility_located_dom(
                DesignConditionLocators.locator_input_count_by_article(article), sec=5)
            with allure.step('Очистка поля'):
                input_count = self.find_element(DesignConditionLocators.locator_input_count_by_article(article))
                input_count.clear()
                with allure.step('Ввод количества'):
                    input_count.send_keys(count)
                    entered_count = input_count.get_attribute('value')
                    assert entered_count == count, \
                        f'Введенное количество - ({entered_count}) не соответствует ожидаемому - ({count})'

    def deselect_code(self, article: str):
        """Отмена выбора кода"""
        with allure.step('Клик отмена выбора кода'):
            self.waiting_element_is_visibility_located_dom(
                DesignConditionLocators.locator_checkbox_item_selection(article), sec=5)
            check_box_deselect_code = self.find_element(
                DesignConditionLocators.locator_checkbox_item_selection(article))
            self.click_js(check_box_deselect_code)
            res_check_box_deselect_code = check_box_deselect_code.is_selected()
            assert res_check_box_deselect_code is False, \
                f'Код {article} выбран для заказа. Значение input - {res_check_box_deselect_code}'
