import time
import re

import allure
from selenium.common import StaleElementReferenceException, TimeoutException
from selenium.webdriver.common.by import By
from base_page.base_page import BasePage
from base_page.base_page_locators import BaseOpenLocators
from base_page.raise_exceptions import MyTimeoutException
from open_pages.cart_page.cart_locators import CartLocators, CartRolLocators, ModalSellersChoiceLocators
from selenium.webdriver.common.action_chains import ActionChains
from open_pages.draft_page.draft_locators import DraftLocators


@allure.feature('Страница Корзина')
class CartPage(BasePage):
    """Страница Корзина"""

    def choice_of_client_number(self, number_client='RT25-7705238125-HE'):
        """Выбор клиентского номера"""
        with allure.step('Выбор клиентского номера'):
            with allure.step('Клик по кнопке клиентский номер для активаии выпадающего списка клиентских номеров'):
                try:
                    self.expecting_clickability(CartLocators.LOCATOR_CLIENT_NUMBER, sec=7)
                    client_number = self.find_element(CartLocators.LOCATOR_CLIENT_NUMBER)
                    self.click_js(client_number)
                except StaleElementReferenceException:
                    self.expecting_clickability(CartLocators.LOCATOR_CLIENT_NUMBER, sec=7)
                    client_number = self.find_element(CartLocators.LOCATOR_CLIENT_NUMBER)
                    client_number.click()
            with allure.step('Ожидание отображения на странице выпадающего списка клиентских номеров'):
                self.waiting_element_is_visibility_located_dom(CartLocators.LOCATOR_UL_CLIENT_NUMBERS)
            with allure.step(f'Выбор нужного ({number_client}) клиентского номера '):
                self.waiting_element_is_visibility_located_dom(CartLocators.locator_required_client_num(number_client),
                                                               sec=7)
                required_client_num = self.find_element(CartLocators.locator_required_client_num(number_client))
                self.driver.execute_script("arguments[0].click()", required_client_num)
            time.sleep(1)
            with allure.step('Ожидание отработки лоадера после выбора клиентского номера'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)

    def type_product_in_input(self, article):
        """Ввод артикула в поле внесения"""
        with allure.step(f'Ввод артикула {article} в поле ввода корзины'):
            product_input = self.find_element(CartLocators.LOCATOR_PRODUCT_INPUT)
            product_input.clear()
            product_input.send_keys(article)

    def click_add_button(self):
        """Клик по кнопке Добавить"""
        with allure.step('Клик по кнопке Добавить в корзине'):
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_ADD_BUTTON, sec=10)
            add_button = self.find_element(CartLocators.LOCATOR_ADD_BUTTON)
            add_button.click()
            with allure.step('Ожидание отработки лоадера в корзине после клика по кнопке Добавить'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_TEXT, sec=90)
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT, sec=90)

    def checking_adding_items_to_cart(self, article_list_expected: list):
        """
        Проверка добавления кодов в корзину
        :param article_list_expected: Список ожидаемых артикулов
        """
        with allure.step('Проверка добавления кодов в корзину'):
            article_list_on_page = self.save_list_articles_in_cart()

            # Смотрим есть ли автозамена в корзине. Если есть, то заменяем артикулы в ожидаемом списке
            for idx, article in enumerate(article_list_expected):
                autocorrect_code_list = self.check_if_there_is_code_autocorrect(article)
                article_list_expected[idx] = autocorrect_code_list[1] if len(autocorrect_code_list) != 0 else article

            assert article_list_on_page == article_list_expected, \
                (f'Список артикулов на странице после добавления в корзину - ({article_list_on_page}) не соответствует '
                 f'списку добавляемых артикулов - ({article_list_expected})')

    def enter_the_number_of_pieces_in_the_quantity_input_field(self, amount):
        """Ввод количество штук в поле ввода Количество штук"""
        with allure.step('Ввод количество штук в поле ввода Количество штук'):
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_INPUT_AMOUNT)
            input_amount = self.find_element(CartLocators.LOCATOR_INPUT_AMOUNT)
            input_amount.clear()
            input_amount.send_keys(amount)

    def save_amount_product_by_article(self, article: str) -> int:
        """Сохранение количества штук по артикулу"""
        with allure.step('Сохранение количества штук по артикулу'):
            amount_product = self.find_element(CartLocators.locator_input_amount_by_article(article)).get_attribute(
                'value')
            return int(amount_product)

    def save_product_information_message_by_article(self, article: str) -> str:
        """Сохранение информационного сообщения о продукте"""
        with allure.step('Сохранение информационного сообщения о продукте'):
            info_message = self.find_element(CartLocators.locator_product_information_message_by_article(article)).text
            return info_message

    def checking_product_delivery_completion_message(self, article: str):
        """Проверка сообщения о завершении поставок продукта"""
        with allure.step(f'Проверка сообщения о завершении поставок продукта по артикулу - ({article})'):
            expected_message = 'Уточните возможность поставки аналогичного продукта у сотрудников технической поддержки'
            message_info = self.find_element(CartLocators.locator_product_delivery_completion_message(article)).text
            assert message_info == expected_message, \
                f'Текст о завершении поставок - ({message_info}) у артикула - ({article}) не соответствует ожидаемому - ' \
                f'({expected_message})'

    def click_button_update_cart(self):
        """Клик по кнопке обновить корзину"""
        with allure.step('Клик по кнопке обновить корзину'):
            self.expecting_clickability(CartLocators.LOCATOR_BUTTON_UPDATE_CART)
            button_update_cart = self.find_element(CartLocators.LOCATOR_BUTTON_UPDATE_CART)
            button_update_cart.click()
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_TEXT, sec=120)

    def click_btn_edit(self):
        """Клик по кнопке Редактировать у артикула"""
        with allure.step('Клик по кнопке Редактировать у артикула'):
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_BTN_EDIT_ARTICLE, sec=5)
            btn_edit = self.find_element(CartLocators.LOCATOR_BTN_EDIT_ARTICLE)
            btn_edit.click()
            with allure.step('Проверка отображения кнопки Сохранить'):
                self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_BUTTON_SAVE_WHEN_EDITING, sec=5)

    def entering_an_article_when_editing(self, article: str):
        """Ввод артикула при редактировании артикула"""
        with allure.step(f'Ввод артикула ({article}) при редактировании артикула'):
            input_edit = self.find_element(CartLocators.LOCATOR_INPUT_ARTICLE_WHEN_EDITING)
            input_edit.clear()
            input_edit.send_keys(article)

    def entering_an_amount_when_editing(self, amount: int):
        """Ввод количество при редактировании артикула"""
        with allure.step('Ввод количество при редактировании артикула'):
            input_edit = self.find_element(CartLocators.LOCATOR_INPUT_AMOUNT_WHEN_EDITING)
            input_edit.clear()
            input_edit.send_keys(amount)

    def save_article_edit(self, article_for_edit: str):
        """Сохранение редактирования артикула
        article_for_edit - код для редактирования (который должен отображаться в корзине)
        """
        with allure.step('Сохранение и проверка редактирования артикула'):
            btn_save = self.find_element(CartLocators.LOCATOR_BUTTON_SAVE_WHEN_EDITING)
            btn_save.click()
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_BTN_EDIT_ARTICLE, sec=5)
            self.click_button_update_cart()
            article_in_cart = self.save_list_articles_in_cart()

            autocorrect_code = self.check_if_there_is_code_autocorrect(article_for_edit)
            autocorrect_code = autocorrect_code[1] if len(autocorrect_code) != 0 else ''
            article_for_edit = autocorrect_code if len(autocorrect_code) != 0 else article_for_edit
            assert article_for_edit in article_in_cart, \
                f'Код для редактирования - ({article_for_edit}) не отображается в корзине после редактирования. ' \
                f'Список кодов в корзине - ({article_in_cart})'

    def save_list_articles_in_cart(self) -> list:
        """Сохранение списка артикулов в корзине"""
        with allure.step('Сохранение списка артикулов в корзине'):
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_CODE_NAME, sec=10)

            name_codes_link_in_cart = self.driver.find_elements(*CartLocators.LOCATOR_CODE_NAME)
            name_codes_link_in_cart = [codes.text for codes in name_codes_link_in_cart]

            return name_codes_link_in_cart

    def click_toolip_article(self):
        """Клик по тултипу у артикула"""
        with allure.step('Клик по тултипу у артикула в корзине'):
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_TOOLTIP_ARTICLE, sec=5)
            tooltip_article = self.find_element(CartLocators.LOCATOR_TOOLTIP_ARTICLE)
            tooltip_article.click()
            with allure.step('Проверка появления заголовка в тултипе Состав комплекта'):
                self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_HEADER_COMPOSITION_OF_SET, sec=5)

    def save_name_article_in_tooltip_composition_of_set(self) -> list:
        """Сохранение наименования артикулов в тултипе Состав комплекта"""
        with allure.step('Сохранение наименования артикулов в тултипе Состав комплекта'):
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_HEADER_COMPOSITION_OF_SET, sec=5)
            name_articles = self.find_elements(CartLocators.LOCATOR_NAME_ARTICLE_IN_TOOLIP_COMPOSITION_OF_SET)
            name_articles = [article.text for article in name_articles]
            return name_articles

    def store_price(self):
        """Сохранение суммы корзины"""
        with allure.step('Сохранение итоговой суммы (Итого с НДС) корзины (Итого находится под строками добавленных '
                         'товаров)'):
            total_price_cart = self.find_element(CartLocators.LOCATOR_PRICE_TOTAL_CART).text
            total_price_cart = re.sub(r'[^0-9.]+', r'', total_price_cart)
            return float(total_price_cart)

    def store_price_list_item_product(self) -> str:
        """Сохранение Прайс-листа одного продукта"""
        with allure.step('Сохранение Прайс-листа одного продукта'):
            price_list = self.driver.find_elements(*CartLocators.LOCATOR_PRICE_LIST)
            header_text = self.driver.find_elements(*CartLocators.LOCATOR_RESPONSE_BOX_INFO)
            if len(price_list) != 0:
                price_list = price_list[0].text
            elif len(header_text) != 0:
                price_list = self.driver.find_elements(*CartLocators.LOCATOR_RESPONSE_BOX_INFO)
                price_list = price_list[0].text
            else:
                price_list = self.driver.find_elements(*CartLocators.LOCATOR_H2)
                price_list = price_list[0].text
            return price_list

    def save_price_list_all_product(self) -> list:
        """Сохранение прайс-ласта всех продуктов"""
        with allure.step('Сохранение прайс-ласта всех продуктов'):
            price_list = self.driver.find_elements(*CartLocators.LOCATOR_PRICE_LIST)
            price_list = [float(price.text.replace(' ', '')) for price in price_list]
            return price_list

    def save_price_list_by_article(self, article: str) -> float:
        """Сохранение прайс-листа по артикулу"""
        with allure.step(f'Сохранение прайс-листа по артикулу ({article})'):
            self.waiting_element_is_visibility_on_the_page(CartLocators.locator_price_list_by_article(article), sec=5)
            price_list = self.find_element(CartLocators.locator_price_list_by_article(article)).text.replace(' ', '')
            return float(price_list)

    def click_empty_trash(self):
        """Клик по кнопке Очистить корзину"""
        with allure.step('Ожидание появления на странице корзины заголовка'):
            self.waiting_for_loader_processing_in_dom(CartLocators.LOCATOR_H2_UPDATE_YOUR_CART, sec=15)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_H1_BASKET)
        with allure.step('Клик по кнопке Очистить корзину'):
            empty_basket = self.driver.find_elements(*CartLocators.LOCATOR_H2_CART_IS_EMPTY)
            if len(empty_basket) == 0:
                self.expecting_clickability(CartLocators.LOCATOR_BUTTON_EMPTY_TRASH)
                button_empty_trash = self.find_element(CartLocators.LOCATOR_BUTTON_EMPTY_TRASH)
                self.driver.execute_script("arguments[0].click()", button_empty_trash)
            with allure.step('Ожидание отработки лоадера после клика по кнопке Очистить корзину'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT, sec=90)

    def click_continue_button(self):
        """Клик по кнопке Продолжить"""
        with allure.step('Клик по кнопке Продолжить в корзине'):
            self.expecting_clickability(CartLocators.LOCATOR_CONTINUE_BUTTON)
            continue_button = self.find_element(CartLocators.LOCATOR_CONTINUE_BUTTON)
            self.scroll_to_elem_perform(continue_button)
            continue_button.click()
            time.sleep(1)
            with allure.step('Ожидание отработки лоадера на странице Подтверждение после клика в корзине по '
                             'кнопке Продолжить'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)

    def store_quantity_in_stock(self, article: str) -> int:
        """Сохранение количества на складе одного артикула"""
        with allure.step(f'Сохранение количества на складе по артикулу ({article})'):
            quantity_in_stock = self.driver.find_elements(*CartLocators.locator_in_stock(article))
            if len(quantity_in_stock) != 0:
                quantity_in_stock = quantity_in_stock[0].text
                return int(quantity_in_stock)
            else:
                return 0

    def saving_quantity_and_delivery_date(self, article: str):
        """Сохранение количества и даты поставки"""
        with allure.step(f'Сохранение количества и даты поставки по артикулу ({article})'):
            locator_supply_quantity = (
                By.XPATH,
                f"//span[text()='{article}']/ancestor::div[contains(@class, 'row')][last()]//span[@class='fw-bold text-warning']"
            )  # Локатор количества поставки
            locator_supply_date_v_1 = (
                By.XPATH,
                f"//span[text()='{article}']/ancestor::div[contains(@class, 'row')][last()]/following-sibling::div//div[@class='text-warning py-2']"
            )  # Локатор даты поставки версия 1
            locator_supply_date_v_2 = (
                By.XPATH,
                f"//span[text()='{article}']/ancestor::div[contains(@class, 'row')][last()]//div[@class='text-warning pe-2 d-flex align-items-end']"
            )  # Локатор даты поставки версия 2
            supply_quantity = self.driver.find_elements(*locator_supply_quantity)
            supply_date = ''
            if len(supply_quantity) > 0:
                supply_quantity = supply_quantity[0].text
                supply_date_v_1 = self.driver.find_elements(*locator_supply_date_v_1)
                supply_date_v_2 = self.driver.find_elements(*locator_supply_date_v_2)

                supply_date = supply_date_v_1[0].text if len(supply_date_v_1) != 0 else supply_date_v_2[0].text
            else:
                supply_quantity = 0
            return supply_quantity, supply_date

    def keeping_the_quantity_on_order(self, article: str):
        """Сохранение количество под заказ"""
        with allure.step(f'Сохранение количество под заказ по артикулу ({article})'):
            locator_quantity_on_order = (By.XPATH,
                                         f"//span[text()='{article}']/ancestor::div[contains(@class, 'row')][last()]"
                                         f"//span[@class='fw-bold text-danger']")

            quantity_on_order = self.driver.find_elements(*locator_quantity_on_order)
            if len(quantity_on_order) > 0:
                quantity_on_order = quantity_on_order[0].text
            else:
                quantity_on_order = 0
            return quantity_on_order

    def checking_the_blocking_of_material_for_sales(self, article: str):
        """Проверка блокировки материала для сбыта"""
        with allure.step(f'Проверка блокировки материала для сбыта по артикулу ({article})'):
            locator_block_material = (
                By.XPATH, f"//span[text()='{article}']/ancestor::div[contains(@class, 'row')][last()]"
                          f"//span[@class='response-box' or @class='fs-5 fw-bold']")

            text_blocking = self.driver.find_elements(*locator_block_material)
            if len(text_blocking) > 0:
                text_blocking = text_blocking[0].text
            else:
                text_blocking = ''
            return text_blocking

    def check_if_there_is_code_autocorrect(self, article: str) -> list:
        """
        Проверка есть ли автозамена
        :param article: Артикул, у которого проверяем автозамену
        :return: Список артикулов. [old_article, new_article]; old_article - старый код, который заменили;
        new_article- новый код, на который заменили. В случае, если нет автозамены, возвращаем пустой список
        """
        with allure.step(f'Проверка есть ли автозамена по артикулу {article}'):
            old_new_codes = []
            self.waiting_element_is_visibility_on_the_page(CartLocators.locator_all_items_with_article_number(article))
            autocorrect = self.driver.find_elements(*CartLocators.locator_autocorrect_code(article))
            if len(autocorrect) > 0:
                old_code = self.find_element(CartLocators.LOCATOR_AUTOCORRECT_OLD_CODE).text
                old_new_codes.append(old_code)
                new_code = self.find_element(CartLocators.LOCATOR_AUTOCORRECT_NEW_CODE).text
                old_new_codes.append(new_code)
            return old_new_codes

    def save_text_from_info_modal_and_close(self):
        """Сохранение текста из информационной модалки и закрытие"""
        with allure.step('Сохранение текста из информационной модалки и закрытие'):
            modal_info = self.driver.find_elements(*CartLocators.LOCATOR_MODAL_INFO)
            # print(len(modal_info), 'Количество модалок')
            text_in_modal_info = ''
            if len(modal_info) > 0:
                text_in_modal_info = self.find_element(CartLocators.LOCATOR_TEXT_IN_MODAL_INFO).text
                button_close = self.find_element(CartLocators.LOCATOR_BUTTON_CLOSE_MODAL_INFO)
                action = ActionChains(self.driver)
                self.expecting_clickability(CartLocators.LOCATOR_BUTTON_CLOSE_MODAL_INFO)
                action.click(button_close).perform()
            return text_in_modal_info

    def add_zip(self):
        """Добавление ЗИП кодов в заказ"""
        with allure.step('Добавление ЗИП кодов в заказ'):
            with allure.step('Клик по кнопке + ЗИП и изоляция'):
                add_zip_button = self.find_element(CartLocators.LOCATOR_PLUS_ZIP)
                self.driver.execute_script("arguments[0].click()", add_zip_button)
                with allure.step('Ожидание отработки лоадера'):
                    self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
                with allure.step('Проверка появления Чек-бокс ЗИП'):
                    self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_CHECKBOX_ZIP)
            checkbox = self.find_element(CartLocators.LOCATOR_CHECKBOX_ZIP)
            self.driver.execute_script("arguments[0].click()", checkbox)
            is_selected_checkbox = checkbox.is_selected()
            assert is_selected_checkbox is True, \
                f'Чек-бокс ЗИП не выбран; ({is_selected_checkbox} - is_selected_checkbox)'
            with allure.step('Клик по кнопке Добавить в корзину'):
                add_basket = self.find_element(CartLocators.LOCATOR_BUTTON_ADD_BASKET)
                self.driver.execute_script("arguments[0].click()", add_basket)
                with allure.step('Ожидание отработки лоадера'):
                    self.waiting_for_loader_processing_on_page(CartLocators.LOCATOR_LOADER_IN_MODAL_FOR_ADDING_ZIP)

    @staticmethod
    def checking_for_upward_price_changes(price_cart_zip: str, price_cart_first: str):
        """проверка изменения цены в большую сторону
        price_cart_zip - цена корзины с ЗИПом
        price_cart_first - цена корзины без ЗИПа
        """
        with allure.step('Проверка изменения итоговой цены в корзину в большую сторону'):
            assert price_cart_first < price_cart_zip, f'Цена в корзине не изменилась, было - ({price_cart_first}), ' \
                                                      f'стало - ({price_cart_zip}) '

    def save_allowances(self) -> list:
        """Сохранение надбавок"""
        with allure.step('Сохранение всех надбавок в корзине'):
            allowances_cart = self.find_elements(CartLocators.LOCATOR_ALLOWANCES_CART)
            allowances_cart_list = [float(allowance.text.replace('%', '')) for allowance in allowances_cart]
            return allowances_cart_list

    def upload_button(self):
        """Нажать на кнопку 'Выгрузить'"""
        with allure.step('Клик по кнопке Выгрузить в корзине'):
            upload_button = self.find_element(CartLocators.LOCATOR_UNLOAD)
            self.driver.execute_script("arguments[0].click()", upload_button)
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_UNLOAD_EXCEL)

    def save_excel(self):
        """Нажать на кнопку Выгрузить в Excel"""
        with allure.step('Клик по кнопке Выгрузить в Excel в коризне'):
            button_unload_excel = self.find_element(CartLocators.LOCATOR_UNLOAD_EXCEL)
            self.driver.execute_script("arguments[0].click()", button_unload_excel)
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_TEXT, sec=120)

            name_file = f'cart_0014403847.xlsx'
            with allure.step(f'Удаление файла ({name_file}) из папки Загрузки, если он есть в данной папке'):
                self.delete_file_by_name_in_download_folder(name_file)
            with allure.step(f'Проверка скачивания файла ({name_file}) в папку Загрузки'):
                self.checking_the_download_document_in_the_download_folder(name_file)
            with allure.step(f'Удаление файла ({name_file}) из папки Загрузки, если он есть в данной папке'):
                self.delete_file_by_name_in_download_folder(name_file)

    def save_excel_end_user(self):
        """Нажать на кнопку Выгрузить в Excel у конечного клиента"""
        with allure.step('Клик по кнопке Выгрузить в Excel у конечного клиента'):
            button_unload_excel = self.find_element(CartLocators.LOCATOR_UNLOAD_EXCEL)
            self.driver.execute_script("arguments[0].click()", button_unload_excel)
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_TEXT, sec=120)

            name_file = 'cart_rol.xlsx'
            with allure.step(f'Удаление файла ({name_file}) из папки Загрузки, если он есть в данной папке'):
                self.delete_file_by_name_in_download_folder(name_file)
            with allure.step(f'Проверка скачивания файла ({name_file}) в папку Загрузки'):
                self.checking_the_download_document_in_the_download_folder(name_file)
            with allure.step(f'Удаление файла ({name_file}) из папки Загрузки, если он есть в данной папке'):
                self.delete_file_by_name_in_download_folder(name_file)

    def cost_calculation_pdf(self):
        """Нажать на кнопку "Расчет стоимости" (PDF)"""
        with allure.step('Клик по кнопке Расчет стоимости (PDF)'):
            button_unload_pdf = self.find_element(CartLocators.LOCATOR_COST_CALCULATION)
            self.driver.execute_script("arguments[0].click()", button_unload_pdf)

    def filling_out_the_fields_pdf(self, name_object, object_address, customer_name, customer_phone):
        """Заполнение полей в форме Выгрузить - Расчет стоимости"""
        with allure.step('Заполнение полей в форме Выгрузить - Расчет стоимости'):
            with allure.step('Заполнение поля Объект'):
                field_object_name = self.find_element(CartLocators.LOCATOR_UNLOAD_OBJECT_NAME)
                self.driver.execute_script("arguments[0].click()", field_object_name)
                time.sleep(1)
                field_object_name.send_keys(name_object)
            with allure.step('Заполнение поля Адрес объекта'):
                field_object_address = self.find_element(CartLocators.LOCATOR_UNLOAD_OBJECT_ADDRESS)
                self.driver.execute_script("arguments[0].click()", field_object_address)
                field_object_address.send_keys(object_address)
            with allure.step('Заполнение поля Имя заказчика'):
                field_customer_name = self.find_element(CartLocators.LOCATOR_UNLOAD_CUSTOMER_NAME)
                self.driver.execute_script("arguments[0].click()", field_customer_name)
                field_customer_name.send_keys(customer_name)
            with allure.step('Заполнение поля Телефон'):
                field_customer_phone = self.find_element(CartLocators.LOCATOR_UNLOAD_CUSTOMER_PHONE)
                self.driver.execute_script("arguments[0].click()", field_customer_phone)
                field_customer_phone.send_keys(customer_phone)

    def download_pdf(self):
        """"Нажать на кнопку скачать"""
        with allure.step('Скачивание pdf'):
            with allure.step('Клик по кнопке Скачать (pdf)'):
                button_download_pdf = self.find_element(CartLocators.LOCATOR_UNLOAD_BUTTON_DOWNLOAD)
                self.driver.execute_script("arguments[0].click()", button_download_pdf)
                with allure.step('Ожидание отработки лоадера'):
                    self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_TEXT, sec=120)

            name_file = f'Расчет стоимости.pdf'
            with allure.step(f'Удаление файла ({name_file}) из папки Загрузки, если он есть в данной папке'):
                self.delete_file_by_name_in_download_folder(name_file)
            with allure.step(f'Проверка скачивания файла ({name_file}) в папку Загрузки'):
                self.checking_the_download_document_in_the_download_folder(name_file)
            with allure.step(f'Удаление файла ({name_file}) из папки Загрузки, если он есть в данной папке'):
                self.delete_file_by_name_in_download_folder(name_file)

    def sent_to_email(self):
        """Отправить файл по e-mail"""
        with allure.step('Клик по кнопке Отправить файл по e-mail'):
            button_sent_to_email = self.find_element(CartLocators.LOCATOR_SENT_TO_EMAIL)
            self.driver.execute_script("arguments[0].click()", button_sent_to_email)
            time.sleep(1)
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT, sec=90)

    def save_as_draft(self):
        """Кнопка Сохранить как Черновик"""
        with allure.step('Клик по кнопке Кнопка Сохранить как Черновик в корзине'):
            button_save_as_draft = self.find_element(CartLocators.LOCATOR_SAVE_AS_DRAFT)
            self.driver.execute_script("arguments[0].click()", button_save_as_draft)
            with allure.step('Проверка отображения заголовка на странице Черновик'):
                self.waiting_element_is_visibility_on_the_page(DraftLocators.LOCATOR_H1_DRAFT)

    def click_btn_add_sales_page_shared_card(self):
        """Кнопка Добавить в корзину на странице С вами поделились Корзиной"""
        with allure.step('Клик по кнопке Добавить в корзину на странице С вами поделились Корзиной'):
            click_btn_add_sales_page_shared_card = self.find_element(CartLocators.LOCATOR_BTN_ADD_SALES)
            self.scroll_to_elem_perform(click_btn_add_sales_page_shared_card)
            self.driver.execute_script("arguments[0].click()", click_btn_add_sales_page_shared_card)
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)

    def click_icon_promo_curse_by_article(self, article: str):
        """Клик по иконке промо-курс у артикула (для отображения тултипа на странице)"""
        with allure.step(f'Клик по иконке промо-курс у артикула {article} (для отображения тултипа на странице)'):
            try:
                icon_promo_curse = self.find_element(CartLocators.locator_icon_promo_curse_by_article(article))
                self.scroll_to_elem_perform(icon_promo_curse)
                self.waiting_element_is_visibility_on_the_page(
                    CartLocators.locator_icon_promo_curse_by_article(article), sec=2)
            except TimeoutException:
                raise MyTimeoutException(f'У артикула {article} в корзине не отображается иконка с промо курсом')
            icon_promo_curse.click()
            assert self.is_element_present(*CartLocators.locator_text_in_tooltip_promo_curse_by_article(article)), \
                f'Тултип у артикула {article} с текстом промо курсе на появился на странице'

    def there_must_be_a_prom_curse_for_article(self, article: str):
        """Должен быть промо курс у артикула"""
        with allure.step(f'Проверка отображения иконки промо курса у артикула {article}'):
            expected_text_in_tooltip_promo_curse = 'Специальное правило расчёта. Применён курс 115 руб., при расчёте стоимости по прайсу.'
            self.click_icon_promo_curse_by_article(article)
            text_in_tooltip_promo_curse = self.find_element(
                CartLocators.locator_text_in_tooltip_promo_curse_by_article(article)).text
            assert text_in_tooltip_promo_curse == expected_text_in_tooltip_promo_curse, \
                f'У артикула {article} текст в тултипе промо курса - ({text_in_tooltip_promo_curse}) не соответствует ожидаемому - ' \
                f'({expected_text_in_tooltip_promo_curse})'

    def checking_whether_payment_is_being_made_at_promotional_rate(self, article: str, price_list_article_rub: float):
        """Проверка идет ли расчет с рублей в УЕ по промо курсу
        price_list_article_rub - прайс-лист артикула в рублях
        """
        with allure.step(f'Проверка идет ли расчет с рублей в уе по промо курсу артикула {article}'):
            promo_curse = 115

            expected_price_list_by_promo_curse_ue = price_list_article_rub / promo_curse  # прайс-лист в уе, рассчитанный по промо курсу (ожидаемый)

            price_list_on_page = str(self.save_price_list_by_article(article))  # Прайс-лист в уе на странице
            price_list_on_page = float(price_list_on_page.replace(' ', ''))

            assert expected_price_list_by_promo_curse_ue == price_list_on_page, \
                f'Прайс лист на странице - ({price_list_on_page}) у кода {article} не соответствует ожидаемому ' \
                f'прайс листу по промо курсу - ({expected_price_list_by_promo_curse_ue})'

    def click_icon_internal_curse_by_article(self, article: str):
        """Клик по иконке Внутренний курс (для отображения тултипа на странице с информацией о курсе)"""
        with allure.step(f'Клик по иконке Внутренний курс у артикула {article} (для отображения тултипа на странице)'):
            try:
                icon_internal_curse = self.find_element(CartLocators.locator_icon_no_promo_curse_by_article(article))
                self.scroll_to_elem_perform(icon_internal_curse)
                self.waiting_element_is_visibility_on_the_page(
                    CartLocators.locator_icon_no_promo_curse_by_article(article), sec=2)
            except TimeoutException:
                raise MyTimeoutException(f'У артикула {article} в корзине не отображается иконка с внутренним курсом')
            icon_internal_curse.click()
            assert self.is_element_present(*CartLocators.locator_text_in_tooltip_no_promo_curse_by_article(article)), \
                f'Тултип у артикула {article} с текстом внутреннего курса на появился на странице'

    def there_must_be_a_internal_curse_by_article(self, article: str):
        """Должен быть внутренний курс у артикула"""
        with allure.step(f'Проверка отображения иконки внутреннего курса у артикула {article}'):
            expected_text = 'Рассчитано по курсу: у.е.'  # В конце есть значение курса, проверяем без него
            self.click_icon_internal_curse_by_article(article)
            text_in_tooltip_internal_curse = self.find_element(
                CartLocators.locator_text_in_tooltip_no_promo_curse_by_article(article)).text.split(' ')[:-1]
            text_in_tooltip_internal_curse = ' '.join(text_in_tooltip_internal_curse)
            assert text_in_tooltip_internal_curse == expected_text, \
                f'У артикула {article} текст в тултипе внутреннего курса - ({text_in_tooltip_internal_curse}) ' \
                f'не соответствует ожидаемому - ({expected_text})'

    def check_special_price_info_in_list_article(self, article_list: list):
        """Проверка, что у кодов в списке артикулов есть информация о спец цене (в виде тултипа)"""
        with allure.step('Проверка, что у кодов в списке артикулов есть информация о спец цене (в виде тултипа)'):
            expected_text_in_tooltip_special_price = 'Специальная цена'  # Ожидаемый текст в тултипе спец цены
            for article in article_list:
                self.waiting_element_is_visibility_on_the_page(
                    CartLocators.locator_btn_active_tooltip_special_price_by_article(article), sec=5)
                tooltip_special_price = self.find_element(
                    CartLocators.locator_btn_active_tooltip_special_price_by_article(article))
                tooltip_special_price.click()
                self.waiting_element_is_visibility_on_the_page(
                    CartLocators.locator_message_tooltip_special_price_by_article(article), sec=5)
                info_message_in_tooltip = self.find_element(
                    CartLocators.locator_message_tooltip_special_price_by_article(article)).text
                assert info_message_in_tooltip == expected_text_in_tooltip_special_price, \
                    f'Текст инфо сообщения в тултипе спец цены на странице - ({info_message_in_tooltip}) не соответствует ' \
                    f'ожидаемому - ({expected_text_in_tooltip_special_price})'

    def store_discounts_all_articles(self) -> list:
        """Сохранение скидок у всех артикулов"""
        with allure.step('Сохранение скидок у всех артикулов'):
            self.waiting_element_is_visibility_located_dom(CartLocators.LOCATOR_DISCOUNT_ARTICLE, sec=5)
            discounts_all_articles = self.find_elements(CartLocators.LOCATOR_DISCOUNT_ARTICLE)
            discounts_all_articles = [float(el.text.replace(' %', '')) for el in discounts_all_articles]
            return discounts_all_articles

    def click_button_switch_to_ue(self):
        """Клик по кнопке Переключить курс на уе"""
        with allure.step('Переключение курса на УЕ'):
            expected_contains_class_active_btn_ue = 'btn-danger'  # Ожидаемое частичное значение класса активной кнопки переключения на уе
            self.expecting_clickability(CartLocators.LOCATOR_BTN_SWITCH_TO_UE_CURSE, sec=3)
            btn_switch_to_ue = self.find_element(CartLocators.LOCATOR_BTN_SWITCH_TO_UE_CURSE)
            btn_switch_to_ue.click()
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            class_active_btn_ue = btn_switch_to_ue.get_attribute('class').split(' ')[-1]
            assert class_active_btn_ue == expected_contains_class_active_btn_ue, \
                f'Кнопка Переключение на УЕ не активна. contains class active btn on page - ({class_active_btn_ue}). ' \
                f'Expected contains class - ({expected_contains_class_active_btn_ue})'


@allure.feature('Корзина РОЛ, под непрямым клиентом')
class CartRol(BasePage):
    """Корзина РОЛ, под непрямым клиентом"""

    def should_be_clickable_radio_btn_for_selecting_a_recommended_seller(self):
        """Радио батон выбора рекомендуемого продавца должен быть кликабелен"""
        with allure.step('Проверка кликабельности Радио батон выбора рекомендуемого продавца'):
            radio_btn_seller_choice_list = self.find_elements(CartRolLocators.LOCATOR_RADIO_BTN_SELLER_CHOICE)
            for el in radio_btn_seller_choice_list:
                self.click_js(el)
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
                is_click_radio_btn_seller_choice = el.is_selected()
                assert is_click_radio_btn_seller_choice is True, \
                    f'Один из radio button "Выбор рекомендуемого продавца" не выбран на странице после клика на него'

    def save_recommended_sellers_list(self) -> list:
        """Сохранение списка рекомендуемых продавцов"""
        with allure.step('Сохранение списка рекомендуемых продавцов'):
            self.waiting_element_is_visibility_located_dom(CartRolLocators.LOCATOR_RECOMMENDED_SELLERS)
            recommended_sellers_list = self.find_elements(CartRolLocators.LOCATOR_RECOMMENDED_SELLERS)
            recommended_sellers_list = [seller.text for seller in recommended_sellers_list]
            return recommended_sellers_list

    def click_btn_choose_a_distributor_yourself(self):
        """Клик по кнопке Выбрать дистрибьютора самостоятельно"""
        with allure.step('Клик по кнопке Выбрать дистрибьютора самостоятельно в корзине'):
            self.waiting_element_is_visibility_located_dom(CartRolLocators.LOCATOR_BTN_CHOOSE_A_DISTRIBUTOR_YOURSELF)
            btn_choose_a_distributor_yourself = self.find_element(
                CartRolLocators.LOCATOR_BTN_CHOOSE_A_DISTRIBUTOR_YOURSELF)
            self.click_js(btn_choose_a_distributor_yourself)
            with allure.step('Проверка отображения заголовка'):
                self.waiting_element_is_visibility_on_the_page(ModalSellersChoiceLocators.LOCATOR_HEADER, sec=10)


@allure.feature('Модалка выбора организации')
class ModalSellersChoice(BasePage):
    """Модалка выбора организации"""

    def save_name_organization_to_select(self) -> list:
        """Сохранение названий организаций для выбора"""
        with allure.step('Сохранение названий организаций для выбора'):
            list_name_organization_to_select = self.find_elements(
                ModalSellersChoiceLocators.LOCATOR_NAME_ORGANIZATION_TO_SELECT)
            list_name_organization_to_select = [
                organization.text.split('. ')[1] for organization in list_name_organization_to_select]
            return list_name_organization_to_select

    def seller_selection(self, name_organization: str):
        """Выбор продавца"""
        with allure.step('Выбор продавца'):
            with allure.step('Клик по радио-батону выбора продавца'):
                radio_btn_seller_selection = self.find_element(
                    ModalSellersChoiceLocators.locator_radio_btn_seller_selection_by_name_organization(
                        name_organization))
                self.click_js(radio_btn_seller_selection)
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            is_click_radio_btn_seller_selection = radio_btn_seller_selection.is_selected()
            assert is_click_radio_btn_seller_selection is True, \
                f'Радио батон организации {name_organization} не выбран'

    def checking_display_of_selected_organization_on_map(self, name_organization: str):
        """Проверка отображения выбранной организации на карте"""
        with allure.step('Проверка отображения выбранной организации на карте'):
            selected_organization_on_map = self.find_element(
                ModalSellersChoiceLocators.LOCATOR_OF_SELECTED_ORGANIZATION_ON_MAP).text
            assert selected_organization_on_map == name_organization, \
                f'Организация, отображаемая на карте - {selected_organization_on_map}, не соответствует ' \
                f'ожидаемой - {name_organization}'
