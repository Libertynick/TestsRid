import allure
from base_page.base_page import BasePage
import time
import re
import os

from base_page.base_page_locators import BaseOpenLocators
from base_page.raise_exceptions import MyTimeoutException
from crm_pages.pq_page.pq_page_locators import PqPageLocators
from open_pages.cart_page.cart_locators import CartLocators
from open_pages.order_details_page.order_details_page_locators import OrderDetailsLocators, \
    ModalWindowCancelOrderLocators
from open_pages.standart_order_page.standart_order_locators import OrderSuccessPageLocators
import json


@allure.feature('Страница Детали заказа')
class OrderDetails(BasePage):
    """Страница Детали заказа"""

    def waiting_for_account_creation(self):
        """Ожидание создания счета заказа"""
        with allure.step('Ожидание создания счета заказа'):
            maximum_account_creation_time = 300  # максимальное время создания счета в секундах (5 минут)
            time_wait = maximum_account_creation_time
            pause = 10  # пауза в секундах
            count_order_is_placed = self.driver.find_elements(*OrderDetailsLocators.LOCATOR_H1_ORDER_IS_PLACED)
            while len(count_order_is_placed) > 0:
                time.sleep(pause)
                self.driver.refresh()
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
                count_order_is_placed = self.driver.find_elements(*OrderDetailsLocators.LOCATOR_H1_ORDER_IS_PLACED)
                time_wait -= pause
                with allure.step(f'Проверка на максимальное время ожидания - {maximum_account_creation_time / 60} мин'):
                    if time_wait == 0:
                        raise MyTimeoutException(
                            f'Не создается счет. Время ожидания - {maximum_account_creation_time / 60} мин.')

    def should_be_free_shipping_to_the_specified_address(self):
        """Способ доставки должен быть бесплатная доставка на указанный адрес"""
        with allure.step('Способ доставки должен быть бесплатная доставка на указанный адрес'):
            true_delivery_condition = 'Бесплатная доставка на указанный адрес'
            delivery_condition = self.find_element(OrderDetailsLocators.LOCATOR_DELIVERY_METHOD).text.strip()
            assert delivery_condition == true_delivery_condition, \
                f'Способ доставки на странице - ({delivery_condition}) не соответствует ожидаемому способу доставки - ' \
                f'({true_delivery_condition})'

    def shipping_cost_should_be_free(self):
        """Стоимость доставки должна быть Бесплатно"""
        with allure.step('Стоимость доставки должна быть Бесплатно'):
            true_cost_of_delivery = ['бесплатно', '0.00 ₽']
            cost_of_delivery_on_page = self.find_element(
                OrderDetailsLocators.LOCATOR_COST_OF_DELIVERY).text.strip().lower()
            assert cost_of_delivery_on_page in true_cost_of_delivery, \
                f'Стоимость доставки на странице - ({cost_of_delivery_on_page}) не соответствует ожидаемой стоимости ' \
                f'доставки - ({true_cost_of_delivery})'

    def delivery_method_must_be_pick_up(self):
        """Способ доставки должен быть Самовывоз"""
        with allure.step('Способ доставки должен быть Самовывоз'):
            true_delivery_method = 'Самовывоз'
            delivery_method_on_page = self.find_element(OrderDetailsLocators.LOCATOR_DELIVERY_METHOD).text
            assert true_delivery_method == delivery_method_on_page, \
                f'Способ доставки на странице - ({delivery_method_on_page}) не соответствует ожидаемому способу доставки ' \
                f'- ({true_delivery_method})'

    def should_be_number_contract(self):
        """Должен отображаться номер договора"""
        with allure.step('Проверка отображения номера договора на странице заказа'):
            self.waiting_element_is_visibility_on_the_page(OrderDetailsLocators.LOCATOR_CONTRACT_NUMBER, sec=5)
            num_order = self.find_element(OrderDetailsLocators.LOCATOR_CONTRACT_NUMBER).text
            assert num_order != '', f'Строка с номером договора на странице заказа пустая - ({num_order})'

    def should_be_distributor(self):
        """Должен быть дистрибьютор на странице"""
        with allure.step('Проверка отображения названия дистрибьютора на странице заказа'):
            distr = self.find_element(OrderDetailsLocators.LOCATOR_DISTRIBUTOR).text
            assert distr != '', f'Строка с именем дистра пустая - ({distr})'

    def should_be_prepayment_terms(self):
        """Должны отображаться условия оплаты"""
        with allure.step('Проверка отображения условий оплаты на странице заказа'):
            prepayment_terms = self.find_element(OrderDetailsLocators.LOCATOR_PREPAYMENT_TERMS).text
            assert prepayment_terms != '', f'Строка с условиями оплаты пустая - ({prepayment_terms})'

    def should_be_currency(self):
        """Проверка отображения Валюты на странице"""
        with allure.step('Проверка отображения валюты на странице заказа'):
            currency = self.find_element(OrderDetailsLocators.LOCATOR_CURRENCY).text
            assert currency != '', f'Строка с валютой пустая - ({currency})'

    # def should_be_course_ue(self):
    #     """Проверка отображения курса уе на странице"""
    #     with allure.step('Проверка отображения курса на странице заказа'):
    #         course_ue = self.find_element(OrderDetailsLocators.LOCATOR_COURSE_UE).text
    #         assert course_ue != '', f'Строка с курсом УЕ пустая - ({course_ue})'
    #####
    def should_be_delivery_method(self):
        """Проверка отображения Способа доставки на странице"""
        with allure.step('Проверка отображения способа доставки на странице заказа'):
            delivery_method = self.find_element(OrderDetailsLocators.LOCATOR_DELIVERY_METHOD).text
            assert delivery_method != '', f'Строка со способом доставки пустая - ({delivery_method})'

    def should_be_author_order(self):
        """Проверка отображения на странице Автора заказа"""
        with allure.step('Проверка отображения автора заказа на странице заказа'):
            author_order = self.find_element(OrderDetailsLocators.LOCATOR_AUTHOR_ORDER).text
            assert author_order != '', f'Строка с автором заказа пустая - ({author_order})'

    def should_be_total_amount(self):
        """Проверка отображения общей суммы на странице"""
        with allure.step('Проверка отображения общей суммы на странице заказа'):
            total_amount = self.find_element(OrderDetailsLocators.LOCATOR_TOTAL_AMOUNT).text
            assert total_amount != '', f'Строка с общей суммой пустая - ({total_amount})'

    def should_be_total_weight(self):
        """Проверка отображения на странице Общего веса"""
        with allure.step('Проверка отображения общего веса на странице заказа'):
            total_weight = self.find_element(OrderDetailsLocators.LOCATOR_TOTAL_WEIGHT).text
            assert total_weight != '', f'Строка с общим весом пустая - ({total_weight})'

    def should_be_reference_number(self):
        """Проверка отображения ссылочного номера на странице"""
        with allure.step('Проверка отображения ссылочного номера на странице заказа'):
            reference_number = self.find_element(OrderDetailsLocators.LOCATOR_REFERENCE_NUMBER).text
            assert reference_number != '', f'Строка с ссылочным номером пустая - ({reference_number})'

    def should_be_delivery_address(self):
        """Проверка отображения адреса доставки"""
        with allure.step('Проверка отображения Адреса доставки на странице заказа'):
            delivery_address = self.find_element(OrderDetailsLocators.LOCATOR_DELIVERY_ADDRESS).text
            assert delivery_address != '', f'Строка с Адресом доставки пустая - ({delivery_address})'

    def should_be_object_deal(self):
        """Проверка отображения Объекта/Сделки на странице"""
        with allure.step('Проверка отображения Объект/Сделки на странице заказа'):
            object_deal = self.find_element(OrderDetailsLocators.LOCATOR_OBJECT_DEAL).text
            assert object_deal != '', f'Строка с Объект/Сделки пустая - ({object_deal})'

    def data_display_check(self):
        """Метод для объединения проверок отображения информации о заказе на странице"""
        with allure.step('Проверка отображения информации о заказе на странице заказа'):
            self.should_be_number_contract()
            self.should_be_distributor()
            self.should_be_prepayment_terms()
            self.should_be_currency()
            # self.should_be_course_ue()
            self.should_be_delivery_method()
            self.should_be_author_order()
            self.should_be_total_amount()
            self.should_be_total_weight()
            self.should_be_reference_number()
            self.should_be_delivery_address()
            self.should_be_object_deal()

    def saving_surcharges_in_the_order(self) -> list:
        """Сохранение надбавок в заказе"""
        with allure.step('Сохранение надбавок в заказе'):
            all_allowances_list = self.find_elements(
                OrderDetailsLocators.LOCATOR_SURCHARGES_ON_ALL_ARTICLE_LINES_IN_ORDER)
            all_allowances = [
                float(allowances.text.replace('%', '')) for allowances in all_allowances_list
            ]
            return all_allowances

    def payment_condition_must_be_advance_payment(self):
        """Условие оплаты должно быть - Предоплата"""
        with allure.step('Проверка условий оплата на странице детали заказа. Ожидаемые - предоплата'):
            true_payment_terms = 'Предоплата'
            payment_terms_on_page = self.find_element(OrderDetailsLocators.LOCATOR_PREPAYMENT_TERMS).text
            assert true_payment_terms == payment_terms_on_page, \
                f'Услвия оплаты на странице - ({payment_terms_on_page}) не соответствуют ожидаемым услвоиям оплаты - ' \
                f'({true_payment_terms})'

    def save_terms_of_payment_in_order_page(self) -> str:
        """Сохранение условий оплаты на странице Заказа"""
        with allure.step('Сохранение условий оплаты на странице Заказа'):
            terms_of_payment = self.find_element(OrderDetailsLocators.LOCATOR_TERMS_OF_PAYMENT_IN_ORDER).text
            return terms_of_payment

    def store_price_order(self) -> str:
        """Сохранение стоимости заказа"""
        with allure.step('Сохранение стоимости заказа'):
            price_order = self.find_element(OrderDetailsLocators.LOCATOR_PRICE_ORDER).text
            price_order = re.sub(r'[^0-9.]+', r'', price_order)
            return price_order

    def save_price_list_by_article(self, article: str) -> float:
        """Сохранение прайс-листа по артикулу"""
        with allure.step('Сохранение прайс-листа по артикулу'):
            price_list = self.find_element(OrderDetailsLocators.locator_price_list_by_article(article)).get_attribute(
                'innerText').split('\n')[0]
            price_list = float(price_list.replace(' ', ''))
            return price_list

    def store_num_order(self) -> str:
        """Сохранение номера заказа"""
        with allure.step('Сохранение номера заказа'):
            num_order = self.find_element(OrderDetailsLocators.LOCATOR_H1_ORDER).text
            num_order = num_order.split(' ')[1]
            return num_order

    def store_num_order_pq(self):
        """Сохранение номера PQ при создании Проектного условия"""
        with allure.step('Сохранение номера PQ при создании Проектного условия'):
            num_order = self.find_element(OrderDetailsLocators.LOCATOR_H1_ORDER_PQ).text
            num_order = num_order.split(' ')[2]
            return num_order

    def store_delivery_cost(self) -> float:
        """Сохранение стоимости доставки"""
        with allure.step('Сохранение стоимости доставки'):
            delivery_cost = self.find_element(OrderDetailsLocators.LOCATOR_COST_OF_DELIVERY).text
            flag = False

            for el in delivery_cost:
                if el.isdigit():
                    flag = True
            if flag:
                delivery_cost = float(delivery_cost.replace(' ', '').replace('₽', ''))
                return delivery_cost
            else:
                return 0.0

    def check_delivery_method(self, delivery_method: str):
        """Проверка способа доставки
        delivery_method - способ доставки
        """
        with allure.step('Проверка способа доставки'):
            delivery_method_on_page = self.find_element(OrderDetailsLocators.LOCATOR_DELIVERY_METHOD).text
            assert delivery_method_on_page == delivery_method, \
                f'Способ доставки на странице - ({delivery_method_on_page}) не соответствует ожидаемому - ' \
                f'({delivery_method})'

    def check_address_delivery(self, expected_address_delivery: str, num_order: str):
        """
        Проверка адреса доставки
        :param expected_address_delivery: Ожидаемый адрес доставки
        :param num_order: Номер заказа
        :return: None
        """
        with allure.step('Проверка адреса доставки'):
            self.waiting_element_is_visibility_located_dom(OrderDetailsLocators.LOCATOR_DELIVERY_ADDRESS, sec=3)
            delivery_address_on_page = self.find_element(OrderDetailsLocators.LOCATOR_DELIVERY_ADDRESS).text
            assert expected_address_delivery == delivery_address_on_page, \
                (f'Адрес доставки в заказе {num_order} - ({delivery_address_on_page}) не соответствует ожидаемому - '
                 f'({expected_address_delivery})')

    def save_name_article_on_all_lines(self) -> list:
        """Сохранение наименования всех артикулов на всех линиях заказа"""
        with allure.step('Сохранение наименования всех артикулов на всех линиях заказа'):
            self.waiting_element_is_visibility_located_dom(OrderDetailsLocators.LOCATOR_NAME_ARTICLE, sec=5)
            name_article_list = self.find_elements(OrderDetailsLocators.LOCATOR_NAME_ARTICLE)
            name_article_list = [article.text for article in name_article_list]
            return name_article_list

    def click_order_cancellation(self):
        """Открытие модалки Отмена заказа"""
        with allure.step('Открытие модалки Отмена заказа'):
            with allure.step('Клик по кнопке Отправить запрос на странице заказа'):
                self.expecting_clickability(OrderDetailsLocators.LOCATOR_BUTTON_SEND_REQUEST)
                button_send_request = self.find_element(OrderDetailsLocators.LOCATOR_BUTTON_SEND_REQUEST)
                self.click_js(button_send_request)
                self.expecting_clickability(OrderDetailsLocators.LOCATOR_BUTTON_ORDER_CANCELLATION)
            with allure.step('Клик по кнопке Отмена заказа'):
                button_order_cancellation = self.find_element(OrderDetailsLocators.LOCATOR_BUTTON_ORDER_CANCELLATION)
                self.click_js(button_order_cancellation)
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            with allure.step('Проверка отображения заголовка Отмена заказа в модалке отмены заказа'):
                self.waiting_element_is_visibility_on_the_page(ModalWindowCancelOrderLocators.LOCATOR_H3, sec=5)

    def click_printing_forms(self):
        """Клик по кнопке Печатные формы"""
        with allure.step('Раскрытие выпадающего списка Печатные формы'):
            self.waiting_element_is_visibility_located_dom(OrderDetailsLocators.LOCATOR_PRINTING_FORMS)
            button_printing_forms = self.find_element(OrderDetailsLocators.LOCATOR_PRINTING_FORMS)
            self.expecting_clickability(OrderDetailsLocators.LOCATOR_PRINTING_FORMS)
            button_printing_forms.click()
            time.sleep(1)
            drop_menu = self.driver.find_elements(*OrderDetailsLocators.LOCATOR_MENU_PRINTING_FORMS)
            if len(drop_menu) == 0:
                self.expecting_clickability(OrderDetailsLocators.LOCATOR_PRINTING_FORMS)
                button_printing_forms = self.find_element(OrderDetailsLocators.LOCATOR_PRINTING_FORMS)
                button_printing_forms.click()
                time.sleep(1)
                with allure.step('Ожидание видимости выпадающего списка Печатные формы на странице заказа'):
                    self.waiting_element_is_visibility_located_dom(OrderDetailsLocators.LOCATOR_MENU_PRINTING_FORMS,
                                                                   sec=10)

    def checking_export_to_excel_download(self, num_order: str):
        """Проверка скачивания Выгрузки в Excel
        num_order- номер созданного заказа
        """
        with allure.step(f'Проверка скачивания Выгрузки в Excel со страницы заказа {num_order}'):
            name_file = f'Детали заказа №{num_order}.xlsx'
            with allure.step(f'Удаление файла {name_file} в папке Зарузки, если он есть в папке'):
                self.delete_file_by_name_in_download_folder(name_file)
            with allure.step('Клик по кнопке Выгрузка в Excel в выпадающем списке Печатные формы'):
                self.expecting_clickability(OrderDetailsLocators.LOCATOR_EXPORT_TO_EXCEL)
                button_export_to_excel = self.find_element(OrderDetailsLocators.LOCATOR_EXPORT_TO_EXCEL)
                self.click_js(button_export_to_excel)
                # time.sleep(1)
                with allure.step('Ожидание отработки лоадера'):
                    self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
                with allure.step(f'Поиск скачанного файла {name_file} в папке Загрузки'):
                    self.checking_the_download_document_in_the_download_folder(name_file)
                with allure.step(f'Удаление файла {name_file} в папке Загрузки, если он есть в папке'):
                    self.delete_file_by_name_in_download_folder(name_file)

    def checking_commercial_offer_ridan_download(self, num_order: str):
        """Проверка скачивания Коммерческое предложение Ридан"""
        with allure.step('Проверка скачивания файла Коммерческое предложение Ридан со страницы заказа'):
            # with allure.step('Формирование названия ожидаемого файла'):
            # Получение текущей даты и времени
            # now = datetime.now()
            # Формирование строки в формате ISO 8601
            # iso_datetime = now.isoformat(timespec='milliseconds')
            # name_file = rf'Коммерческое предложение Ридан - {iso_datetime}.pdf'
            name_file = f'Коммерческое предложение Ридан {num_order}.pdf'

            with allure.step(f'Удаление файла {name_file} в папке Загрузки, если он есть в папке'):
                self.delete_file_by_name_in_download_folder(name_file)

            with allure.step('Клик по кнопке Коммерческое предложение Ридан в выпадающем списке Печатные формы'):
                self.expecting_clickability(OrderDetailsLocators.LOCATOR_COMMERCIAL_OFFER_RIDAN)
                button_commercial_offer_ridan = self.find_element(OrderDetailsLocators.LOCATOR_COMMERCIAL_OFFER_RIDAN)
                self.click_js(button_commercial_offer_ridan)

                with allure.step('Ожидание отработки лоадера'):
                    self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)

                with allure.step(f'Поиск скачанного файла {name_file} в папке Загрузки'):
                    self.checking_the_download_document_in_the_download_folder(name_file)
                with allure.step(f'Удаление файла {name_file} в папке Загрузки, если он есть в папке'):
                    self.delete_file_by_name_in_download_folder(name_file)

    def checking_download_check(self, num_order: str):
        """Проверка скачивания Счета"""
        with allure.step('Проверка скачивания счета'):
            name_file = f'Счет {num_order}.pdf'
            with allure.step(f'Удаление файла {name_file} в папке Зарузки, если он есть в папке'):
                self.delete_file_by_name_in_download_folder(name_file)
            with allure.step('Клик по кнопке Счет в выпадающем списке Печатные формы'):
                self.expecting_clickability(OrderDetailsLocators.LOCATOR_CHECK)
                button_check = self.find_element(OrderDetailsLocators.LOCATOR_CHECK)
                self.click_js(button_check)

            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            with allure.step(f'Поиск скачанного счета {name_file} в папке Загрузки'):
                self.checking_the_download_document_in_the_download_folder(name_file)
            with allure.step(f'Удаление файла {name_file} в папке Загрузки, если он есть в папке'):
                self.delete_file_by_name_in_download_folder(name_file)

    def checking_confirmation_download(self, num_order: str):
        """Проверка скачивания формы Подтверждение"""
        with allure.step('Проверка скачивания формы Подтверждение'):
            name_file = f'Подтверждение {num_order}.pdf'
            with allure.step(f'Удаление файла {name_file} в папке Загрузки, если он есть в папке'):
                self.delete_file_by_name_in_download_folder(name_file)
            with allure.step('Клик по кнопке Подтверждение в выпадающем списке Печатные формы'):
                self.expecting_clickability(OrderDetailsLocators.LOCATOR_CONFIRMATION)
                button_confirmation = self.find_element(OrderDetailsLocators.LOCATOR_CONFIRMATION)
                self.click_js(button_confirmation)

            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            with allure.step(f'Поиск скачанного файла {name_file} в папке Загрузки'):
                self.checking_the_download_document_in_the_download_folder(name_file)
            with allure.step(f'Удаление файла {name_file} в папке Загрузки, если он есть в папке'):
                self.delete_file_by_name_in_download_folder(name_file)

    @staticmethod
    def verify_check_host(num_order: str):
        """Проверка скачанного счета в папке Загрузки"""
        with allure.step('Проверка скачанного счета в папке Загрузки'):
            for address, dirs, files in os.walk('Downloads\\'):
                for file in files:
                    if file == f'Счет {num_order}.pdf':
                        print(file, os.path.join(address, file))
                        return True
            assert True, f'Счет {num_order}.pdf не найден'

    def checking_printing_forms_download(self, num_order: str):
        """Метод для объединения скачивания всех печатных форм
        num_order - номер заказа
        """
        with allure.step(f'Проверка скачивания всех печатных форм на странице заказа {num_order}'):
            self.click_printing_forms()
            self.checking_export_to_excel_download(num_order)

            self.click_printing_forms()
            self.checking_commercial_offer_ridan_download(num_order)

            self.click_printing_forms()
            self.checking_download_check(num_order)

            self.click_printing_forms()
            self.checking_confirmation_download(num_order)

    def waiting_open_page_reference_number(self):
        """Ожидание открытия страницы со ссылочными номерами заказа (При размещении дву заказов из Корзины)"""
        with allure.step('Ожидание открытия страницы со ссылочными номерами заказа (При размещении двух заказов из '
                         'Корзины)'):
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            time.sleep(1)
            self.waiting_element_is_visibility_located_dom(OrderSuccessPageLocators.LOCATOR_ORDER_PLACED)
            time.sleep(1)

    def delivery_location_check_pto(self):
        """Проверка стоимости доставки в зависимости от кода"""
        with allure.step('Проверка стоимости доставки в зависимости от кода'):
            pto_on_page = self.is_element_present(*PqPageLocators.LOCATOR_TEXT_MATERIAL_PTO)
            delivery_adress = self.find_element(OrderDetailsLocators.LOCATOR_DELIVERY_ADDRESS).text
            isPickup = 'Самовывоз'
            for isPickup in delivery_adress:
                if pto_on_page:
                    assert not isPickup, "Должна быть доставка по адресу"
                else:
                    assert isPickup, "Должен быть самовывоз"

    def sve_all_discounts(self) -> list:
        """Сохранение всех скидок на всех линиях"""
        with allure.step('Сохранение всех скидок на всех линиях'):
            discounts = self.find_elements(OrderDetailsLocators.LOCATOR_ALL_DISCOUNTS)
            discounts_list = [float(discount.text.replace('%', '')) for discount in discounts]
            return discounts_list

    def click_btn_show_request_history(self):
        """Клик по кнопке Показать историю запросов"""
        with allure.step('Клик по кнопке Показать историю запросов'):
            self.waiting_element_is_visibility_on_the_page(OrderDetailsLocators.LOCATOR_BTN_SHOW_REQUEST_HISTORY, sec=5)
            btn_show_request_history = self.find_element(OrderDetailsLocators.LOCATOR_BTN_SHOW_REQUEST_HISTORY)
            btn_show_request_history.click()
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            with allure.step('Ожидание отображения кнопки Список запросов'):
                self.waiting_element_is_visibility_on_the_page(OrderDetailsLocators.LOCATOR_BTN_LIST_REQUEST, sec=5)

    def click_btn_copy_kp(self):
        """Клик по кнопке Копировать КП"""
        with allure.step('Клик по кнопке Копировать КП'):
            btn_copy_kp = self.find_element(OrderDetailsLocators.LOCATOR_BTN_COPY_KP)
            btn_copy_kp.click()
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_H2_UPDATE_YOUR_CART)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_TEXT)
            self.waiting_element_is_visibility_on_the_page(CartLocators.LOCATOR_CODE_NAME)

    def click_btn_list_request(self):
        """Клик по кнопке Список запросов"""
        with allure.step('Клик по кнопке Список запросов'):
            btn_list_request = self.find_element(OrderDetailsLocators.LOCATOR_BTN_LIST_REQUEST)
            scroll_to_elem = self.find_element(OrderDetailsLocators.LOCATOR_BUTTON_SEND_REQUEST)
            self.scroll_to(scroll_to_elem)
            self.expecting_clickability(OrderDetailsLocators.LOCATOR_BTN_LIST_REQUEST)
            btn_list_request.click()
            with allure.step('Проверка отображения заголовка в модалке Список запросов'):
                self.waiting_element_is_visibility_on_the_page(
                    OrderDetailsLocators.LOCATOR_HEADER_IN_MODAL_LIST_REQUESTS, sec=5)

    def save_num_request_in_modal_list_requests(self) -> str:
        """Сохранение номера запроса в модалке Список запросов"""
        with allure.step('Сохранение номера запроса в модалке Список запросов'):
            self.waiting_element_is_visibility_on_the_page(
                OrderDetailsLocators.LOCATOR_NUM_REQUEST_IN_MODAL_LIST_REQUESTS, sec=5)
            num_requests = self.find_element(OrderDetailsLocators.LOCATOR_NUM_REQUEST_IN_MODAL_LIST_REQUESTS).text
            return num_requests

    def click_button_position_history(self):
        """Клик по кнопке История позиции"""
        with allure.step('Клик по кнопке История позиции'):
            scroll_to_elem = self.find_element(OrderDetailsLocators.LOCATOR_BUTTON_SEND_REQUEST)
            self.scroll_to(scroll_to_elem)
            self.expecting_clickability(OrderDetailsLocators.LOCATOR_BUTTON_POSITION_HISTORY)
            btn_position_history = self.find_element(OrderDetailsLocators.LOCATOR_BUTTON_POSITION_HISTORY)
            btn_position_history.click()
            with allure.step('Ожидание отработки лоадера'):
                self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)
            with allure.step('Проверка отображения заголовка в модалке История позиций'):
                self.waiting_element_is_visibility_on_the_page(
                    OrderDetailsLocators.LOCATOR_HEADER_IN_MODAL_POSITION_HISTORY, sec=10)

    def saving_date_in_position_history_modal(self) -> str:
        """Сохранение даты в модалке история позиций"""
        with allure.step('Сохранение даты в модалке История позиций'):
            self.waiting_element_is_visibility_on_the_page(OrderDetailsLocators.LOCATOR_DATE_IN_MODAL_POSITION_HISTORY,
                                                           sec=5)
            date = self.find_element(OrderDetailsLocators.LOCATOR_DATE_IN_MODAL_POSITION_HISTORY).text
            return date

    def saving_status_in_position_history_modal(self) -> str:
        """Сохранение статуса в модалке История позиций"""
        with allure.step('Сохранение статуса в модалке История позиций'):
            self.waiting_element_is_visibility_on_the_page(
                OrderDetailsLocators.LOCATOR_STATUS_IN_MODAL_POSITION_HISTORY,
                sec=5)
            status = self.find_element(OrderDetailsLocators.LOCATOR_STATUS_IN_MODAL_POSITION_HISTORY).text
            return status

    def close_modal_position_history(self):
        """Закрытие модалки История позиций"""
        with allure.step('Закрытие модалки История позиций'):
            self.expecting_clickability(OrderDetailsLocators.LOCATOR_BTN_CLOSE_IN_MODAL_POSITION_HISTORY)
            btn_close = self.find_element(OrderDetailsLocators.LOCATOR_BTN_CLOSE_IN_MODAL_POSITION_HISTORY)
            btn_close.click()
            with allure.step('Проверка, что модалка закрылась (на странице не отображается заголовок История позиций '
                             'в модалке)'):
                self.waiting_element_invisibility(OrderDetailsLocators.LOCATOR_HEADER_IN_MODAL_POSITION_HISTORY, sec=5)

    def click_btn_tooltip_article(self):
        """Клик по кнопке тултипа у артикула"""
        with allure.step('Клик по кнопке тултипа у артикула'):
            scroll_to_btn = self.find_element(OrderDetailsLocators.LOCATOR_BUTTON_SEND_REQUEST)
            self.scroll_to(scroll_to_btn)
            self.waiting_element_is_visibility_on_the_page(OrderDetailsLocators.LOCATOR_BTN_TOOLTIP_ARTICLE)
            btn_tooltip = self.find_element(OrderDetailsLocators.LOCATOR_BTN_TOOLTIP_ARTICLE)
            btn_tooltip.click()
            self.waiting_element_is_visibility_on_the_page(
                OrderDetailsLocators.LOCATOR_HEADER_IN_TOOLTIP_COMPOSITION_OF_SET, sec=5)


@allure.feature('Модалка Отмена заказа')
class ModalWindowCancelOrder(BasePage):
    """Модалка Отмена заказа"""

    def should_be_title_cancel_order(self):
        """Должен быть заголовок Отмена заказа"""
        with allure.step('Проверка отображения заголовка в модалке отмены заказа'):
            self.waiting_element_is_visibility_on_the_page(ModalWindowCancelOrderLocators.LOCATOR_H3)

    def click_send_request_in_modal_cancel_order(self):
        """Клик по кнопке Отправить запрос в модалке Отмена заказа"""
        with allure.step('Клик по кнопке Отправить запрос в модалке Отмена заказа'):
            button_send_request = self.find_element(ModalWindowCancelOrderLocators.LOCATOR_BUTTON_IN_MODAL_SEND_REQUEST)
            self.driver.execute_script("arguments[0].click()", button_send_request)

    def there_should_be_a_message_about_the_need_to_choose_a_reason(self):
        """Должно быть сообщение о необходимости выбора причины"""
        with allure.step('Проверка отображения сообщения о необходимости выбора причины'):
            self.waiting_element_is_visibility_on_the_page(
                ModalWindowCancelOrderLocators.LOCATOR_MESSAGE_ABOUT_THE_NEED_TO_CHOOSE_A_REASON)
            message_info = self.find_element(
                ModalWindowCancelOrderLocators.LOCATOR_MESSAGE_ABOUT_THE_NEED_TO_CHOOSE_A_REASON)
            message_info_text = message_info.text
            assert message_info_text == 'Выберите причину отмены!', \
                f'Текст сообщения в модалке ({message_info_text}) не соответствует тексту (Выберите причину отмены!)'

    def save_price_in_modal_cancel_order(self) -> float:
        """Сохранение стоимости в модалке Отмена заказа"""
        with allure.step('Сохранение стоимости в модалке Отмена заказа'):
            self.waiting_element_is_visibility_located_dom(
                ModalWindowCancelOrderLocators.LOCATOR_PRICE_IN_MODAL_CANCEL_ORDER, sec=5)
            price = self.find_element(ModalWindowCancelOrderLocators.LOCATOR_PRICE_IN_MODAL_CANCEL_ORDER
                                      ).text.split(':')[1].replace(' ', '').replace('₽', '')
            return float(price)

    def click_on_the_drop_down_list_of_reasons(self):
        """Клик по выпадающему списку Причина"""
        with allure.step('Клик по выпадающему списку Причина'):
            ul_menu_cause = self.find_element(ModalWindowCancelOrderLocators.LOCATOR_CAUSE_LIST_SHOW)
            self.driver.execute_script("arguments[0].click()", ul_menu_cause)
            with allure.step('Проверка отображения выпадающего списка Причина'):
                self.waiting_element_is_visibility_on_the_page(ModalWindowCancelOrderLocators.LOCATOR_UL_ACTIVE_CAUSE)

    def choice_of_reason_placement_error(self):
        """Выбор причины Ошибка при размещении"""
        with allure.step('Выбор причины "Ошибка при размещении"'):
            cause_item = self.find_element(ModalWindowCancelOrderLocators.LOCATOR_ITEM_CAUSE_PLACEMENT_ERROR)
            time.sleep(1)
            cause_item_text = cause_item.get_attribute("textContent")
            self.driver.execute_script("arguments[0].click()", cause_item)
            input_reason_selected = self.find_element(
                ModalWindowCancelOrderLocators.LOCATOR_INPUT_REASON)  # Выбранная причина
            input_reason_text = input_reason_selected.get_attribute("value")
            with allure.step('Проверка соответствия текста выбранной причины'):
                assert cause_item_text == input_reason_text, \
                    f'Текст выбранной причины ({input_reason_text}) не соответствует тексту, который выбирали ' \
                    f'({cause_item_text})'

    def entering_a_comment(self):
        """Ввод комментария"""
        with allure.step('Ввод комментария в модалке Отмена заказа'):
            comment = 'Тестирование!!! Selenium web.' \
                      'Просьба при приходе этого письма написать Обжериной Валерии и Кирюшину Антону, что тикет поступил'
            input_comment = self.find_element(ModalWindowCancelOrderLocators.LOCATOR_INPUT_COMMENT)
            input_comment.send_keys(comment)

    def there_should_be_a_success_message(self):
        """Должно быть сообщение в модалке об успешном создании запроса"""
        with allure.step('Проверка отображения сообщения в модалке об успешном создании запроса'):
            self.waiting_element_is_visibility_on_the_page(
                ModalWindowCancelOrderLocators.LOCATOR_HEADER_SUCCESSFUL_REQUEST_CREATION, sec=90)

    def close_modal_result_request(self):
        """Закрытие модалки с результатом запроса"""
        button_close = self.find_element(ModalWindowCancelOrderLocators.LOCATOR_BUTTON_CLOSE_MODAL_REQUEST_RESULT)
        button_close.click()
        time.sleep(2)
        self.waiting_for_loader_processing_on_page(BaseOpenLocators.LOCATOR_SPINNER_NO_TEXT)

    def click_btn_close_in_modal_cancel_order(self, num_order: str):
        """Клик по кнопке Закрыть в модалке Отмена заказа"""
        with allure.step('Клик по кнопке Закрыть в модалке Отмена заказа'):
            btn_close = self.find_element(ModalWindowCancelOrderLocators.LOCATOR_BTN_CLOSE_IN_MODAL_CANCEL_ORDER)
            self.scroll_to(btn_close)
            self.expecting_clickability(ModalWindowCancelOrderLocators.LOCATOR_BTN_CLOSE_IN_MODAL_CANCEL_ORDER)
            btn_close.click()
            with allure.step('Проверка отображения заголовка с номером заказа на странице заказа'):
                self.waiting_element_is_visibility_on_the_page(OrderDetailsLocators.locator_header_order(num_order))

    def back_page(self):
        """Вернуться на страницу с созданными заказми из Корзины"""
        with allure.step('Вернуться на страницу с созданными заказми из Корзины'):
            self.driver.back()
            self.waiting_element_is_visibility_on_the_page(OrderSuccessPageLocators.LOCATOR_ORDER_PLACED, sec=15)

    def status_must_be_registered_in_json(self):
        """Должен быть статус Зарегестрировано в json(тестовый режим) при отмене заказа"""
        with allure.step('Проверка отображения статуса Зарегестрировано в json(тестовый режим) при отмене заказа'):
            true_status_response = 'Зарегистрировано'
            time.sleep(1)
            self.waiting_element_is_visibility_located_dom(ModalWindowCancelOrderLocators.LOCATOR_RESPONSE_JSON_TST,
                                                           sec=90)
            json_response = self.find_element(ModalWindowCancelOrderLocators.LOCATOR_RESPONSE_JSON_TST).text
            json_response = json_response.replace('\n', '').replace('\t', '')
            json_response_dict = json.loads(json_response)  # словарь с полным ответом
            # response_data = json_response_dict.get('responseData')
            # objects = response_data.get('Objects')
            objects = json_response_dict.get('objects')  # БЕЗ response_data тк его просто нет в ответе джейсон
            objects_dict = objects[0]
            status_response = objects_dict.get('status')  # поменял на действующий ключ
            with allure.step('Сверка текста в статусе (поле Status в ответе)'):
                assert true_status_response == status_response, \
                    f'Статус ответа заявки на странице - ({status_response}) не соответствует ожидаемому - ' \
                    f'({true_status_response})'

    def saving_request_number_in_json(self) -> str:
        """Сохранение номера запроса на отмену заказа в json - ответе (в тестовом режиме)"""
        with allure.step('Сохранение номера запроса на отмену заказа в json - ответе (в тестовом режиме)'):
            self.waiting_element_is_visibility_located_dom(ModalWindowCancelOrderLocators.LOCATOR_RESPONSE_JSON_TST,
                                                           sec=30)
            json_response = self.find_element(ModalWindowCancelOrderLocators.LOCATOR_RESPONSE_JSON_TST).text
            json_response = json_response.replace('\n', '').replace('\t', '')
            json_response_dict = json.loads(json_response)  # словарь с полным ответом
            # response_data = json_response_dict.get('responseData')
            # objects = response_data.get('Objects')
            objects = json_response_dict.get('objects')  # БЕЗ response_data тк его просто нет в ответе джейсон
            objects_dict = objects[0]
            num_request = objects_dict.get('code')
            return str(num_request)
