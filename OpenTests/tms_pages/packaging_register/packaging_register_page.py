import time

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import Select
from base_page.base_page import BasePage
from tms_pages.packaging_register.packaging_register_locators import PackagingRegisterLocators


class PackagingRegisterPage(BasePage):
    """Странице Реестр упаковок"""

    def should_be_the_heading_register_of_packages(self):
        """Должен быть заголовок Реестр упаковок"""
        self.waiting_element_is_visibility_on_the_page(PackagingRegisterLocators.LOCATOR_HEADER_PACKAGING_REGISTER,
                                                       sec=20)

    def switch_to_frame_main(self):
        """Переключение во фрэйм MainFrame"""
        self.switch_to_frame(PackagingRegisterLocators.LOCATOR_IFRAME_MAIN)

    def switch_to_frame_request(self):
        """Переключение во фрэйм Request"""
        self.switch_to_frame(PackagingRegisterLocators.LOCATOR_IFRAME_REQUEST)

    def switch_to_frame_iframe_ticket(self):
        """Переключение во фрэйм iframeTicket"""
        self.switch_to_frame(PackagingRegisterLocators.LOCATOR_IFRAME_TICKET)

    def switch_to_frame_iframe_21_1247(self):
        """Переключение во фрэйм frame_21_1247"""
        self.switch_to_frame(PackagingRegisterLocators.LOCATOR_FRAME_21_1247)

    def search_for_packaging(self, num_application: str):
        """Поиск заявки на упаковку,
        num_application- номер заявки"""
        input_search = self.find_element(PackagingRegisterLocators.LOCATOR_INPUT_SEARCH_APPLICATION)
        button_open_by_number = self.find_element(PackagingRegisterLocators.LOCATOR_BUTTON_OPEN_BY_NUMBER)
        locator_header_num_application = (
            By.XPATH, f"//tr[@id='files']//b[text()='{num_application}']")  # Заголовок с номером заявки

        input_search.send_keys(num_application)
        button_open_by_number.click()
        self.driver.switch_to.default_content()
        self.waiting_element_is_visibility_located_dom(PackagingRegisterLocators.LOCATOR_IFRAME_REQUEST)
        self.switch_to_frame_request()
        self.switch_to_frame_iframe_ticket()
        self.waiting_element_is_visibility_on_the_page(locator_header_num_application)

    def choice_of_who_packed(self):
        """Выбор кто упаковал"""

        self.expecting_clickability(PackagingRegisterLocators.LOCATOR_INPUT_WHO_PACKED)
        input_who_packed = self.find_element(PackagingRegisterLocators.LOCATOR_INPUT_WHO_PACKED)
        input_who_packed.click()

        self.waiting_element_is_visibility_on_the_page(PackagingRegisterLocators.LOCATOR_TABLE_WHO_PACKED)
        packers = self.find_elements(PackagingRegisterLocators.LOCATOR_PACKERS)
        packer = packers[0]
        packer.click()

    def loading_area_selection(self):
        """Выбор зоны погрузки"""
        self.expecting_clickability(PackagingRegisterLocators.LOCATOR_INPUT_LOADING_AREA)
        input_loading_area = self.find_element(PackagingRegisterLocators.LOCATOR_INPUT_LOADING_AREA)
        input_loading_area.click()

        self.waiting_element_is_visibility_on_the_page(PackagingRegisterLocators.LOCATOR_LIST_OF_LOADING_ZONES)
        list_of_loading_zones = self.find_elements(PackagingRegisterLocators.LOCATOR_LIST_OF_LOADING_ZONES)
        loading_zone = list_of_loading_zones[0]
        loading_zone.click()

    def choice_of_type_of_packaging(self, value: str, type_packaging: str):
        """Выбор вида упаковки, value - value типа упаковки, type_packaging- тип упаковки"""
        select_type_packaging = self.find_element(PackagingRegisterLocators.LOCATOR_SELECT_TYPE_PACKAGING)
        select = Select(select_type_packaging)
        select_type_packaging.click()
        select.select_by_visible_text(type_packaging)
        selected_option = self.find_element(PackagingRegisterLocators.LOCATOR_SELECTED_OPTION_TYPE_PACKAGING)
        text_selected_option = selected_option.text
        assert text_selected_option == type_packaging, \
            f'Выбранный тип упаковки ({text_selected_option}) не равен искомому типу упаковки ({type_packaging})'

    def input_of_packing_height(self, height: str):
        """Ввод высоты упаковки, height - высота упаковки"""
        input_height = self.find_element(PackagingRegisterLocators.LOCATOR_INPUT_HEIGHT_PACKAGE)
        input_height.clear()
        input_height.send_keys(height)
        text_input_height = input_height.get_attribute("value")
        assert text_input_height == height, \
            f'В поле ввода высоты не отображается высота, которую вводили. ' \
            f'\В поле ввода - ({text_input_height}); вводили - ({height}) '

    def input_of_packaging_weight(self, weight: str):
        """Ввод веса упаковки, weight - вес упаковки"""
        input_weight = self.find_element(PackagingRegisterLocators.LOCATOR_INPUT_WEIGHT_PACKAGE)
        input_weight.clear()
        input_weight.send_keys(weight)
        text_input_weight = input_weight.get_attribute("value")
        assert text_input_weight == weight, \
            f'В поле ввода веса не отображается введенный вес. ' \
            f'В поле ввода - ({text_input_weight}); вводимый вес - ({weight})'

    def save_packaging_info(self):
        """Сохранение информации об упаковке"""
        button_save = self.find_element(PackagingRegisterLocators.LOCATOR_BUTTON_SAVE_PACKAGING_INFO)
        button_save.click()
        time.sleep(5)

    def click_button_application_packed(self):
        """Клик по кнопке Заявка упакована"""
        button_packed = self.find_element(PackagingRegisterLocators.LOCATOR_BUTTON_APPLICATION_PACKED)
        button_packed.click()
        self.waiting_element_is_visibility_on_the_page(PackagingRegisterLocators.LOCATOR_APPLICATION_STATUS_PACKED,
                                                       sec=60)

    def save_info_input(self, locator):
        """Сохранение текста с поля инпут"""
        input = self.find_element(locator)
        input_value = input.get_attribute("value")
        return input_value

    def save_packing_info(self):
        """Сохранение информации об упаковке"""
        packing_info = {}

        type_of_packaging = self.find_element(PackagingRegisterLocators.LOCATOR_SELECTED_OPTION_TYPE_PACKAGING).text

        length = self.save_info_input(PackagingRegisterLocators.LOCATOR_INPUT_LENGTH)
        width = self.save_info_input(PackagingRegisterLocators.LOCATOR_INPUT_WIDTH)
        height = self.save_info_input(PackagingRegisterLocators.LOCATOR_INPUT_HEIGHT_PACKAGE)
        count = self.save_info_input(PackagingRegisterLocators.LOCATOR_INPUT_COUNT)
        weight = self.save_info_input(PackagingRegisterLocators.LOCATOR_INPUT_WEIGHT_PACKAGE)

        packing_info.update({
            'type_of_packaging': type_of_packaging,
            'length': length,
            'width': width,
            'height': height,
            'count': count,
            'weight': weight
        })
        return packing_info

    def comparison_of_the_type_of_packaging_before_and_after_sending_for_packaging(
            self, packing_info: dict):
        """Сравнение вида упаковки до и после отправки на упаковку,
        type_of_packaging_before_sending_for_packaging - вид упаковки до отправки на упаковку"""
        type_packaging_after = self.find_element(
            PackagingRegisterLocators.LOCATOR_TYPE_OF_PACKAGING_AFTER_SENDING_FOR_PACKING).text
        type_packaging_before = packing_info['type_of_packaging']
        assert type_packaging_after == type_packaging_before, \
            f'Вид упаковки до отправки на упаковку - ({type_packaging_before}) ' \
            f'не равен виду упаковки после отправки на упаковку - ({type_packaging_after})'

    def comparison_of_package_dimensions_before_and_after_shipment_for_packaging(self, packing_info_before: dict):
        """Сравнение габаритов до и после отправки на упакоку"""
        package_dimensions_after = self.find_element(
            PackagingRegisterLocators.LOCATOR_PACKAGING_DIMENSIONS_AFTER_SENDING_FOR_PACKAGING).text
        package_dimensions_after_list = [el for el in package_dimensions_after.split(' ') if el.isdigit()]

        package_dimensions_after_dict = {}  # габариты после предачи на упаоквку
        package_dimensions_after_dict.update({
            'count': package_dimensions_after_list[0],
            'length': package_dimensions_after_list[1],
            'width': package_dimensions_after_list[2],
            'height': package_dimensions_after_list[3]
        })

        for key_before in packing_info_before:
            for key_after in package_dimensions_after_dict:
                if key_before == key_after:
                    assert packing_info_before[key_before] == package_dimensions_after_dict[key_after], \
                        f'Габарит ({key_before}) - ({packing_info_before[key_before]}) до передачи в упаковку ' \
                        f'не равен габариту ({key_after}) - ({package_dimensions_after_dict[key_after]}) после передачи в упаковку'
