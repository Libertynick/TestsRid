import sys
import os.path

import allure
import psutil
import pytest
from selenium import webdriver
from selenium.webdriver.chrome.options import Options

from datetime import datetime

from base_page.base_page import BasePage
from config import Options as optionConfig
from PIL import Image
import io

from config import TestEnvironment
from crm_pages.athorization_page.authorization_page import AuthorizationPage
from crm_pages.header_page.header_page import HeaderPage
from crm_pages.pq_page.pq_page import PqPage
from crm_pages.pq_page.pq_page_locators import PqPageLocators
from tools import helper

sys.stdout.reconfigure(encoding='utf-8')


@pytest.hookimpl(tryfirst=True, hookwrapper=True)
def pytest_runtest_makereport(item, call):
    """Делаем скрины только при падении тестов"""
    outcome = yield
    rep = outcome.get_result()
    if rep.when == 'call' and rep.failed:
        test_name = os.environ.get('PYTEST_CURRENT_TEST'
                                   ).split('/')[-1].split('::')[0]  # получение имени запускаемого теста
        if optionConfig.PATH_TO_SCREENSHOT is not None:
            if os.path.exists(optionConfig.PATH_TO_SCREENSHOT):
                now = datetime.now()
                now_data = now.strftime("%d.%m.%y.%H.%M.%S")
                name_screenshot = f'{now_data}_{test_name}.png'
                try:
                    if 'browser' in item.fixturenames:  # Получаем экземпляр драйвера
                        web_driver = item.funcargs['browser']
                    else:
                        print('Fail to take screen-shot')
                        return

                    # Для скрина в отчете allure
                    attach = web_driver.get_screenshot_as_png()
                    allure.attach(attach, name_screenshot, attachment_type=allure.attachment_type.PNG)

                    path = optionConfig.PATH_TO_SCREENSHOT + name_screenshot
                    screen(web_driver, path)
                except Exception as e:
                    print("error on write screenshot")
                    print(optionConfig.PATH_TO_SCREENSHOT + name_screenshot)
                    print(e, '- ошибка')


def screen(browser, path):
    """Скриншот экрана не только видимой части экрана (со скролом страницы)"""

    total_height = browser.execute_script("return document.body.scrollHeight")
    size = browser.get_window_size()
    screenshot = Image.new('RGB', (size['width'], total_height))

    offset = 0
    while offset < total_height:
        browser.execute_script("window.scrollTo(0, %s);" % offset)
        screenshot.paste(Image.open(io.BytesIO(browser.get_screenshot_as_png())), (0, offset))
        # offset += 1080 # Вы можете изменить эту величину в зависимости от вашего экрана
        offset += size['height']  # Вы можете изменить эту величину в зависимости от вашего экрана
    screenshot.save(path, format='png')


def pytest_addoption(parser):
    parser.addoption('--browser_name', action='store', default='chrome',
                     help="Choose driver: chrome or firefox")


def get_cpu_usage():
    # Получаем загрузку ЦП в процентах
    cpu_usage = psutil.cpu_percent(interval=1)  # Интервал в секундах
    print(f"Загруженность ЦП: {cpu_usage}%")


def get_memory_usage():
    # Получаем информацию о памяти
    memory = psutil.virtual_memory()
    memory_total = memory.total / (1024 ** 3)  # Перевод в гигабайты
    memory_used = memory.used / (1024 ** 3)  # Перевод в гигабайты
    memory_percent = memory.percent  # Процент использования

    print(f"Общая память: {memory_total:.2f} ГБ")
    print(f"Используемая память: {memory_used:.2f} ГБ")
    print(f"Загрузка памяти: {memory_percent}%")


@pytest.fixture
def agreement_on_all_conditions_extru(browser, auth_extru_crm_from_authorized_page):
    """Согласование всех условий на внешнем сайте extru"""

    def _agreement_all():
        with allure.step('Согласование всех условий на внешнем сайте extru'):
            link_pq = browser.current_url
            page_base = BasePage(browser, link_pq)

            page_base.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_CONSOLIDATION_CHECKBOX, sec=30)
            count_consolidation_checkbox = browser.find_elements(
                *PqPageLocators.LOCATOR_CONSOLIDATION_CHECKBOX)  # количество согласований
            while len(count_consolidation_checkbox) != 0:

                pq_page = PqPage(browser, url=link_pq)

                count_warning = browser.find_elements(*PqPageLocators.LOCATOR_ORANGE_AGREEMENT_FLAGS
                                                      )  # Согласователи с оранжевой меткой
                if len(count_warning) != 0:
                    conciliator_list = pq_page.agreement_with_orange_mark()

                else:
                    conciliator_list = pq_page.agreement_with_blue_mark()

                print(conciliator_list)

                auth_extru_crm_from_authorized_page(link_pq, conciliator_list[0])
                pq_page.reconciliation_of_outdated_costs()
                with allure.step('Клик по галочке согласование напротив согласователя'):
                    page_base.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_AGREEMENT_TRUE, sec=15)
                    agreement_true = page_base.find_element(PqPageLocators.LOCATOR_AGREEMENT_TRUE)
                    page_base.scroll_to(agreement_true)
                    page_base.expecting_clickability(PqPageLocators.LOCATOR_AGREEMENT_TRUE, sec=10)

                    agreement_true = page_base.find_element(PqPageLocators.LOCATOR_AGREEMENT_TRUE)
                    agreement_true.click()
                    page_base.waiting_element_is_visibility_located_dom(PqPageLocators.LOCATOR_H4_AGREEMENT, sec=90)

                pq_page.agreement_kp_for_client()
                pq_page.entering_a_comment_for_approval()
                pq_page.click_on_the_agree_button()

                count_consolidation_checkbox = browser.find_elements(
                    *PqPageLocators.LOCATOR_CONSOLIDATION_CHECKBOX)  # количество согласований

    return _agreement_all


@pytest.fixture
def auth_extru_crm_from_authorized_page(browser):
    """Авторизация в экстру срм с уже авторизованной страницы"""

    def _auth_extru(url_page: str, name_user='RUCO1681'):
        """
        Авторизация в экстру срм с уже авторизованной страницы
        :param url_page:  url страницы, с которой будет авторизация
        :param name_user: Имя пользователя. Для дальнейшего определения ruco
        :return: Функция, которая проходит авторизацию в срм со страницы срм
        """
        with allure.step(
                f'Авторизация в экстру срм с уже авторизованной страницы {url_page}. Пользователь - {name_user}'):
            page_pq = PqPage(browser, url=url_page)
            page_header = HeaderPage(browser, url_page)
            page_auth = AuthorizationPage(browser, TestEnvironment.LINK_CRM_TST_AUTHORIZATION)

            cookie_session = page_pq.get_cookie_session()
            ruco = helper.get_ruco_user_crm_by_name(cookie=cookie_session, name_user=name_user)
            print(ruco)
            helper.release_all_substitutions_crm(cookie_session)
            page_header.activate_profile_menu()
            page_header.logout_user()

            page_auth.open()
            page_auth.authorization_extru(login=ruco)

            page_pq.open()

    return _auth_extru


@pytest.fixture
def auth_crm_extru_start(browser):
    def _auth_start(ruco='RUCO1681', password='1234'):
        """
            Авторизация в срм при старте теста.
            По умолчанию используется пользователь:
            - ruco: RUCO1681 (Оганесян Левон)
            - Пароль: 1234
            :param ruco: ruco пользователя (логин)
            :param password: Пароль
            :return: _auth_start - функция, выполняющая авторизацию в срм
        """
        with allure.step(f'Авторизация в срм. Логин - {ruco}, пароль - {password}'):
            link_auth = TestEnvironment.LINK_CRM_TST_AUTHORIZATION
            page_auth = AuthorizationPage(browser, link_auth)

            page_auth.open()
            page_auth.authorization_extru(login=ruco, password=password)

    return _auth_start


@pytest.fixture
def emergence_of_different_types_of_agreements_in_kp(browser):
    def _emergence_of_different_types_of_agreements(
            id_pq: str,
            num_pq: str,
            type_of_agreement_visible_after_save: list,
            type_of_agreement_visible_after_save_after_change_condition: list,
            delivery_type: str,
            expected_status_agreement: dict
    ):
        """
        Действия по проверке возникновения согласований в разных видах КП.
        С бесплатной доставкой на адрес, условия оплаты - согласование условий оплаты
        :param id_pq: id КП
        :param num_pq: номер КП
        :param type_of_agreement_visible_after_save: Ожидаемые типы согласований после сохранения
        :param type_of_agreement_visible_after_save_after_change_condition:  Ожидаемые типы согласований после изменений условий в КП
        :param delivery_type: Вид доставки (Доставка на указанный адрес, стандартные договорные условия)
        :param expected_status_agreement: Ожидаемые статусы у согласований
        :return: Функция, в которой действия по проверке возникновения типов согласований в разных видах КП
        """

        link_pq = TestEnvironment.LINK_PQ_IN_CRM
        link_pq_total = link_pq + id_pq
        page_pq = PqPage(browser, link_pq_total)
        # Открываем КП в срм
        page_pq.open()
        page_pq.click_btn_save_pq()
        page_pq.check_visible_type_of_agreement(type_of_agreement_visible_after_save, num_pq)
        page_pq.switching_currency_to_a_fixed_rate()
        page_pq.selection_of_delivery_conditions(delivery_type)
        page_pq.choice_of_free_payment_mode()
        page_pq.expanding_payment_terms_menu()
        page_pq.click_on_button_agree_on_payment_terms()
        page_pq.click_btn_save_pq()
        page_pq.check_visible_type_of_agreement(type_of_agreement_visible_after_save_after_change_condition, num_pq)
        page_pq.send_for_approval_pq_page()
        page_pq.status_of_checkpoint_must_be_approval()
        for key, value in expected_status_agreement.items():
            page_pq.checking_approval_status(type_agreement=key, expected_status_agreement=value)

    return _emergence_of_different_types_of_agreements


@pytest.fixture(scope='function')
def browser(request):
    browser_name = request.config.getoption('browser_name')
    options_add_experimental_option_detach = True  # не закрывать окно браузера по завершении теста
    driver = None

    if browser_name == 'chrome':
        get_cpu_usage()
        get_memory_usage()

        headless = 0  # Безголовый режим 0 - false
        user_agent = 'RIDAN_RND_TEST'

        options = Options()
        options.add_argument("--disable-notifications")
        options.add_argument(f"user-agent={user_agent}")
        options.add_argument('--no-sandbox')
        options.add_argument("--log-level=3")
        options.add_experimental_option('excludeSwitches', ['enable-logging', '--dns-prefetch-disable'])

        options.add_experimental_option("detach", options_add_experimental_option_detach
                                        )  # не закрывать окно браузера по завершении теста (True - не закрывать)
        prefs = {
            'profile.default_content_setting_values.automatic_downloads': 1,
            'plugins.always_open_pdf_externally': True  # It will not show PDF directly in chrome
        }
        options.add_experimental_option("prefs", prefs)  # разрешение на скачивание нескольких файлов

        if optionConfig.RUN_HEADLESS_BROWSER == '1':
            # options.add_argument("--headless")
            options.add_argument("--headless=new")
            headless = 1  # Безголовый режим 1 - true

        print('\nstart chrome driver for test...')

        #  При инициализации драйвера через менеджер драйвера
        # driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)

        # global driver
        driver = webdriver.Chrome(options=options)
        # При абсолютном пути драйвера
        # service = Service(executable_path=r'.\chrome_driver\chromedriver.exe')
        # driver = webdriver.Chrome(service=service, options=options)

        if headless == 1:
            driver.set_window_size(width=1920, height=1080)
        else:
            driver.maximize_window()

    yield driver
    print('\nquit driver..')

    page_base = BasePage(driver, '')
    cookie = page_base.get_cookie_session()
    helper.release_all_substitutions_crm(cookie)
    driver.close()
    driver.quit()
